#!/usr/bin/env ruby
#------------------------------------------------------------------------------
# autoautoconf -- recursively generate Makefile.am's
# Copyright (C) 2004 Uwe Hermann
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#------------------------------------------------------------------------------

require 'getoptlong'

$version    = '0.1'
$program    = 'autoautoconf'
$bugreports = 'Uwe Hermann <uh1763@hermann-uwe.de>'

$startdir   = 'syneight'


#------------------------------------------------------------------------------
# Print version.
#------------------------------------------------------------------------------
def print_version
  puts "#{$program} #{$version}"
end


#------------------------------------------------------------------------------
# Print a help screen.
#------------------------------------------------------------------------------
def print_usage
  puts "\
#{$program} #{$version}, Copyright (C) 2004 Uwe Hermann

#{$program} comes with ABSOLUTELY NO WARRANTY. This is free software,
and you are welcome to redistribute it under the terms of
the GNU General Public License. See COPYING for details.

Traverse all subdirectories of the dirname(s) given on the command-line and
generate a Makefile.am for each of them.

Usage: #{$program} [options] dirname(s)...
 -h, --help                  Show this help.
 -v, --version               Print the version number.

Report bugs to #{$bugreports}."
end


#------------------------------------------------------------------------------
# Parse commandline arguments.
#------------------------------------------------------------------------------
def parse_commandline
  opts = GetoptLong.new(
    ["--help", "-h", GetoptLong::NO_ARGUMENT],
    ["--version", "-v", GetoptLong::NO_ARGUMENT]
  )

  opts.each do |opt, arg|
    case opt
      when "--help" then print_usage; exit
      when "--version" then print_version; exit
      else raise "Invalid option '#{opt}'"
    end
  end
end


#------------------------------------------------------------------------------
# Return the contents of the to be generated Makefile.am in 'dir' as a string.
#------------------------------------------------------------------------------
def makefile_am_contents(dir)

  # Makefile.am header.
  contents = "\
#------------------------------------------------------------------------------
# Syneight - A soft-realtime transaction monitor
# Copyright (C) 2003-2004 The Syneight Group
#
# TODO: License.
#------------------------------------------------------------------------------

# Generated by autoautoconf #{$version}."
 
  contents += "\n\n"

  # Get variables.
  subdirs     = get_subdirs(dir)
  cpps        = get_files(dir, "^[-a-zA-Z0-9_]+\\.cpp$")
  headers     = get_headers(dir)
  sources     = get_files(dir, "^[-a-zA-Z0-9_]+\\.[ch]pp$")
  tests       = get_files(dir, "^[-a-zA-Z0-9_]+\\.t\\.cpp$")
  testsupport = get_files(dir, "^[-a-zA-Z0-9_]+\\.ts\\.[ch]pp$")
  binary      = get_files(dir, "^[-a-zA-Z0-9_]+\\.b\\.cpp$").strip
  dirname     = File.basename(dir)
  
  # Subdirs.
  if (subdirs != "")
    contents += "## Subdirectories to process.\n"
    contents += "SUBDIRS = #{beautify(subdirs)}\n"
    contents += "\n"
  end

  # Headers.
  if (headers != "")
    contents += "## Header files.\n"
    contents += "noinst_HEADERS = #{beautify(headers)}\n"
    contents += "\n"
  end

  # Library.
  if (cpps != "" or testsupport != "")
    ltlibs = ""
    ltlibs += "lib#{dirname}.la " if (sources != "")
    ltlibs += "libts#{dirname}.la " if (testsupport != "")

    contents += "## Not to be installed helper-libraries.\n"
    contents += "noinst_LTLIBRARIES = #{ltlibs}\n"
    #contents += "lib_LTLIBRARIES = #{ltlibs}\n"
    contents += "\n"

    contents += "## Helper-library sources.\n"
    contents += "lib#{dirname}_la_SOURCES = #{beautify(sources)}\n"
    contents += "\n"

    subdirlibs = ""
    if (subdirs != "")
      subdirs.split.each do |subdir|
	if (get_files("#{dir}/#{subdir}", "^[-a-zA-Z0-9_]+\\.cpp$") != "")
        	subdirlibs += "#{subdir}/lib#{subdir}.la "
	end
      end
      subdirlibs.strip! if (subdirlibs != "")
    end

    # Libraries (not in subdirectories) we need to link against.
    otherlibs = get_dependencies(dir)

    libs = "#{subdirlibs} #{otherlibs}".strip

    if (libs != "")
      contents += "## Libraries we link against.\n"
      contents += "lib#{dirname}_la_LIBADD = #{beautify(libs)}\n"
      contents += "\n"
    end

    # Test support library.
    if (testsupport != "")
      contents += "## Testsupport library sources.\n"
      contents += "libts#{dirname}_la_SOURCES = #{beautify(testsupport)}\n"
      contents += "\n"
    end
  end

  # Programs.
  if (binary != "" or tests != "")
    bins = ""
    bins += "#{binary[0..-5]} " if (binary != "")
    tests.split.each do |test|
      bins += "#{test[0..-5]} "
    end
    bins.strip!

    contents += "## The executable programs to be built.\n"
    contents += "bin_PROGRAMS = #{beautify(bins)}\n"
    contents += "\n"
  end

  if (binary != "")
    contents += "## Binary '#{binary[0..-7]}'.\n"
    binary2 = binary[0..-5].gsub(/\./, "_")
    contents += "#{binary2}_SOURCES = #{binary}\n"
    contents += "#{binary2}_LDADD = lib#{dirname}.la\n"
    contents += "\n"
  end

  if (tests != "")
    tests.split.each do |test|
      contents += "## Test for '#{test[0..-7]}'.\n"
      test2 = test[0..-5].gsub(/\./, "_")
      contents += "#{test2}_SOURCES = #{test}\n"
      if (testsupport != "")
        contents += "#{test2}_LDADD = lib#{dirname}.la libts#{dirname}.la\n"
      else
        contents += "#{test2}_LDADD = lib#{dirname}.la\n"
      end
      contents += "\n"
    end
  end

  # Recursive targets.
  contents += get_recursive_targets(dir)

  # Makefile.common include.
  contents += "# Include some common Makefile fragments.\n"
  contents += "include $(top_srcdir)/Makefile.common\n"
  contents += "\n"

  return contents
end


#------------------------------------------------------------------------------
# Building recursive targets.
#------------------------------------------------------------------------------
def get_recursive_targets(dir)
  doxygen_conf = get_files(dir, "^doxygen\\.conf\\.in$")

  # Check if we have to descend deeper in the directory structure to
  # invoke other doxygen generators.
  doxy_subdirs = get_doxy_subdirs(dir)

  if (doxy_subdirs != "")
    # Enable recursive targets.
    docs_api_recursive = " docs-api-recursive"
    docs_recursive = " docs-recursive"

    recursion = "\n"
    recursion += "## Recursive helper targets.\n"
    recursion += "docs-api-recursive:\n"
    recursion += "	@subdirs=\'#{doxy_subdirs}\'; \\\n"
    recursion += "	target=\'docs-api\'; \\\n"
    recursion += "	echo \"Making $@ in $$subdirs\"; \\\n"
    recursion += "	for subdir in $$subdirs; do \\\n"
    recursion += "		(cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$target) || exit 1; \\\n"
    recursion += "	done;\n\n"
    recursion += "docs-recursive:\n"
    recursion += "	@subdirs=\'#{doxy_subdirs}\'; \\\n"
    recursion += "	target=\'docs\'; \\\n"
    recursion += "	echo \"Making $@ in $$subdirs\"; \\\n"
    recursion += "	for subdir in $$subdirs; do \\\n"
    recursion += "		(cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$target) || exit 1; \\\n"
    recursion += "	done;\n\n"
  end

  contents = "## Recursive Makefile targets.\n"
  contents += "#{recursion}"
  contents += "docs-ps:\n"
  contents += "docs-pdf:\n"
  if (doxygen_conf != "")
    contents += "docs-api:#{docs_api_recursive} doxygen\n"
    contents += "docs:#{docs_recursive} docs-api\n"
  else
    contents += "docs-api:#{docs_api_recursive}\n"
    contents += "docs:#{docs_recursive}\n"
  end
  contents += "\n"

  return contents
end


#------------------------------------------------------------------------------
# Return a string containing a space-separated list of all subdirs of 'dir'.
#------------------------------------------------------------------------------
def get_subdirs(dir)
  absdir = File.expand_path(dir)

  subdirs = `find '#{absdir}' -maxdepth 1 -type d ! -path "*/.svn*" -print`
  subdirs = subdirs.split

  subdirs_string = ""
  subdirs.each do |subdir|
    # Don't return 'dir' itself, just its subdirectories.
    if subdir != absdir
      subdirs_string += File.basename(subdir) + " "
    end
  end

  return subdirs_string.strip
end

#------------------------------------------------------------------------------
# Return a string containing a space-separated list of all subdirs of 'dir'
# that lead to doxygen.conf.in files.
#------------------------------------------------------------------------------
def get_doxy_subdirs(dir)
  absdir = File.expand_path(dir)

  subdirs = `find '#{absdir}'  -name "doxygen.conf.in" ! -path "*/.svn*" -print`
  subdirs = subdirs.split

  subdirs_string = ""
  subdirs.each do |subdir|
    if subdir != absdir
      subdir = subdir.sub( Regexp.new("#{absdir}/"), "")
      subdir =~ /(\w+)\//
      subdirs_string += "#$1"
    end
  end

  return subdirs_string.strip
end


#------------------------------------------------------------------------------
# Return all files in 'dir' which match the given regex.
#------------------------------------------------------------------------------
def get_files(dir, regex)
  absdir = File.expand_path(dir)

  files = `cd '#{absdir}' 2>/dev/null && ls 2>/dev/null`.split()

  return "" if (files == "")

  files_string = ""
  files.each do |file|
    if Regexp.new(regex) =~ file
      files_string += File.basename(file) + " "
    end
  end

  return files_string.strip
end


#------------------------------------------------------------------------------
# Get headers which don't have a respective cpp file.
#------------------------------------------------------------------------------
def get_headers(dir)
  hpps = get_files(dir, "^[-a-zA-Z0-9_\\.]+\\.hpp$")

  headers = ""
  hpps.split.each do |hpp|
    if (!File.exists?(dir + '/' + hpp.gsub(/\.hpp/, ".cpp")))
      headers += "#{hpp} "
    end
  end

  return headers.strip
end


#------------------------------------------------------------------------------
# Add some line continuations and newlines to a list of files/directories.
#------------------------------------------------------------------------------
def beautify(list)

  # Only beautify long lines.
  return list if (list.length < 50)

  newlist = "\\\n"
  list.split.each do |l|
    newlist += "#{l} \\\n"
  end 

  # Strip off the last line continuation and the last newline.
  newlist = newlist[0..-4]

  return newlist
end


#------------------------------------------------------------------------------
# Recursively create Makefile.am's in all subdirs of 'dir'.
#------------------------------------------------------------------------------
def create_makefiles_recursive(dir)
  absdir = File.expand_path(dir)

  dirlen = File.dirname(File.expand_path($startdir)).length
  reldir = absdir[dirlen+1..absdir.length]
  puts "#{$program}: creating #{reldir}/Makefile.am"

  subdirs = `find '#{absdir}' -maxdepth 1 -type d ! -path "*/.svn*" -print`
  subdirs = subdirs.split

  # Write the contents to the Makefile.am.
  file = open("#{absdir}/Makefile.am", "w")
  file.write(makefile_am_contents(absdir))
  file.close

  subdirs.each do |subdir|
    if subdir != absdir
      create_makefiles_recursive(subdir)
    end
  end
end


#------------------------------------------------------------------------------
# Get all library names on which files in the given directory depend.
#------------------------------------------------------------------------------
def get_dependencies(dir)

  # Temporarily disable this function.
  return ""

  i = `grep "#include" #{dir}/*.[ch]pp 2>/dev/null`

  return "" if (i.strip == "")

  includes = []
  i.each do |incfile|
    incfile = incfile.strip.split[1][1..-2]

    # Get source files in the directory we might need a library from.
    sources = get_files(File.dirname(incfile), "^[-a-zA-Z0-9_]+\\.cpp$")

    # Only consider our own includes (those in syneight/), not iostream etc.
    # Only add the .la files if there actually *is* a library in that subdir.
    # TODO: Remove library in our directory.
    if (incfile =~ /^syneight\// and sources != "")
      includes << "$(top_srcdir)/" \
                  + File.dirname(incfile) + "/lib" \
                  + File.basename(File.dirname(incfile)) + ".la"
    end
  end

  # Remove duplicates.
  includes.uniq!

  # Return a string with a list of space-separated library names.
  return includes.join(" ").strip
end


#------------------------------------------------------------------------------
# Main program.
#------------------------------------------------------------------------------

parse_commandline

dirs = ARGV.collect { |dir| File.expand_path(dir) }

# TODO: If there are no dirs given on the command-line abort with an error.

dirs.each do |dir|
  $startdir = dir
  create_makefiles_recursive(dir)
end

