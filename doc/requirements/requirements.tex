%------------------------------------------------------------------------------
% Syneight - A soft-realtime transaction monitor.
% Copyright (C) 2003-2004 The Syneight Group.
%
% TODO: License.
%------------------------------------------------------------------------------

\documentclass[a4paper, 12pt]{book}

\setcounter{secnumdepth}{3}

\usepackage{fullpage}
\usepackage{varioref}
\usepackage{epic}
\usepackage{ecltree}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{hhline}
%\usepackage{german}

\sloppy

\input{syneight/env.tex}
\input{syneight/definedterms.tex}
\input{syneight/abbreviations.tex}

%\renewcommand{\dt}[1]{#1}

\newcommand{\INTERFACE}[1]{$\Rightarrow\left\{#1\right\}$}

\begin{document}

\begin{titlepage}
To do:
\begin{itemize}
\item what about locking groups?
\item fill Cluster Management System -> XXX0
\item fill Serialization -> XXX1
\item add examples for the isolation levels. I postponed this issue to
make quick progress and thus I want to focus on more pressing things. 
\end{itemize}


Ideas (stuff not covered by this document, which should be included
into it someday):
\begin{itemize}
\item \textbf{journaling entities:} entities which are able to report its own
history, and which can be updated by receiving a journal -- even after
a crash. That is to say, it would be just an entity which the
SYNEIGHT is collecting the update-diffs for.
\end{itemize}
\end{titlepage}

\title{Syneight\\Requirement-Analysis}
\author{Christian Schallhart}
\catcode`\$=12
\date{\texttt{$Id: requirements.tex 287 2004-02-26 16:26:33Z hermanuw
$}}
\catcode`\$=3
\maketitle

\newpage

\tableofcontents

\newpage

\chapter{Introduction}


\section{\SYNEIGHT}
\begin{question*}{blablubber}
hallo Christian
\end{question*}

The easiest way to start thinking about \SYNEIGHT is thinking of
it as a \DSM system. We will prove later that \SYNEIGHT is much more but
for the beginning it is less complex.\\

\SYNEIGHT is providing a \emph{Distributed Shared Memory}
architecture and implementation. The basic functionality of
\SYNEIGHT is to provide a memory which is shared by a set of
processes and which is subdivided into so-called \dt{entities}. An
\dt{entity} is characterized by its \emph{identity} and its
\emph{state}, thus \dt{entities} can be seen as objects minus behavior.
We call any process which shares a \SYNEIGHT-Database with other
processes a \dt{participating process}. A typical system-environment for
the \SYNEIGHT will be a cluster of ordinary PCs which are operated
by Linux.\\

% ACCESS
The first set of responsibilities faced by the \SYNEIGHT is sole
access, which has to allow the \dt{client} to lock \dt{entities}, to
access their state, and to commit associated changes.\\

% DATABASE MANAGEMENT
Besides the requirement of shared database access, the \SYNEIGHT
is also responsible for ensuring the reliability and durability of the
entrusted \SYNEIGHT-databases, as well as for backup-generation.
Moreover the \SYNEIGHT must balance the distribution of the
\SYNEIGHT-databases within the cluster.\\

% 
These management responsibilities have to rely on information which has
to be provided explicitly by the \dt{client} of the \SYNEIGHT.\\

% PARTICIPATING PROCESS MANAGEMENT
Each \dt{participating process} must offer some overall configuration
capabilities, such as determining the amount of memory which can be used
by the \SYNEIGHT internally.\\

% CLUSTER MANAGEMENT
Finally, in a clustered environment, where a possibly large number of
\dt{participating processes} maintain one or more \SYNEIGHT-databases
collectively, several \dt{client}-issued operations will have to be
coordinated throughout the cluster. These functionalities will have to
be integrated into a \dt{cluster management system}.

The \SYNEIGHT will be used by a \emph{Distributed Object Data Base
(DODB)} as means for object representation and communication. The
\SYNEIGHT will be responsible for distributing data, while the
DODB will have to wrap the behavior-less data into objects. The
\SYNEIGHT will encapsulate most of the underlying issues which are
risen by the distribution of data and by the concurrent data-access. 


%%\section{Textual Units}
%%
%%To state and group the requirements of the \SYNEIGHT we employ the
%%following emphasized and titled paragraphs:
%%\begin{itemize}
%%\item \emph{Definitions:} Each definition declares a term (sometimes more than
%%  one) and gives it a specific meaning. When we use a defined term within the
%%  text, we mark it by a \underline{underline}. Definitions should declare
%%  clear-cut units, and should avoid long lists of items which are defined on
%%  the fly, in particular, if there are references to these items within the
%%  document.  
%%\item \emph{Requirements:} Requirements define what the system must be able to
%%  do at the end of the development process. A requirement must have a precise
%%  meaning, thus it must be formulated in defined terms. Requirements should be
%%  short, i.e., it should not contain lists of items, which are described in
%%  the requirement itself. A perfect requirement contains one or two
%%  sentences. We distinguish the following forms of requirements:
%%  \begin{itemize}
%%  \item \emph{Functional Requirements:} A requirement is functional, if it
%%    implies certain characteristics of a system interface. 
%%  \item \emph{Non-Functional Requirements:} A requirements is non-functional,
%%    if it implies certain restrictions on the behavior of the system, without
%%    requiring anything with respect to a system's interface (besides
%%    implementation details).
%%  \end{itemize}
%%  We do not allow requirements which have a functional and a non-functional
%%  part. 
%%\item \emph{Non-Requirements:} Non-requirements should follow the same
%%  guidelines as requirements -- but whereas requirements declare what a system
%%  must be able to do, a non-requirement states what a system is not
%%  required to accomplish. 
%%\item \emph{Responsibilities:} A responsibility stands for a group of
%%  requirements which establish collectively an isolated characteristic of the
%%  system. Thus responsibilities are orthogonal to each other, while
%%  requirements might be dependent on each other and/or might not make sense in
%%  isolation. We distinguish the following responsibilities:
%%  \begin{itemize}
%%  \item \emph{Functional Responsibilities:} Responsibilities which contain
%%    functional requirements are themselves functional. The only allowed
%%    exception are non-functional requirements which declare performance
%%    characteristics of certain interface methods, such as, ``subsequent
%%    invocations must employ caching''. 
%%  \item \emph{Semi-Functional Responsibilities:} Responsibilities which have a
%%    non-functional goal, such as cluster-balancing, but which will be
%%    implemented in terms of designated peaces of code. For example, the
%%    ``function load balancing'' will be implemented by this and that module
%%    within a system. Another characteristic of a semi-functional
%%    responsibility is the possibility of extensive configuration, since
%%    configuration data implies designated code which handles the
%%    responsibility. 
%%  \end{itemize}
%%\item \emph{Remarks:} Remarks are emphasizing critical points in the
%%  interpretation of some other statement of the document. Another application
%%  of remarks is the avoidance or summary of long lists of forward-references.
%%\end{itemize}
%%
%%
%%\section{Structure}
%%
%%The structuring of the requirements will follow two orthogonal threads: First,
%%there are the responsibilities which have to covered by the \SYNEIGHT,
%%and second, there are the different interfaces of the \SYNEIGHT.\\
%%In this section, we will start
%%\begin{itemize}
%%\item with a number of basic definitions, which will allow us to give a loose
%%  definition of the \SYNEIGHT. Based on this defined language, we will
%%  describe the
%%\item interfaces which are employed by the \SYNEIGHT, 
%%\item the responsibilities of the \SYNEIGHT itself,
%%\item the global requirements of the \SYNEIGHT and,
%%\item the interfaces which are offered by the \SYNEIGHT, and finally,
%%\item we finish up with a thorough definition of the \SYNEIGHT.
%%\end{itemize}
%%
%%Afterwards, we will present for each responsibility a dedicated section. In
%%each of those sections, we start with the corresponding specific definitions
%%and present the associated requirements. 
%%
%%%%The general structure of the document will follow the responsibilities but we
%%%%will also show the influence of each requirement or each group of requirements
%%%%on the different interfaces. 
%%%%\MISSING{MORE}
%%
%%%% \emph{Non-Functional Responsibilities:} A non-functional
%%%%    responsibility contains only non-functional requirements. An example is
%%%%    scalability. In our case, the system will provide a lot of subsystems
%%%%    which should enhance scalability, such as load-balancing, however,
%%%%    different forms of scalability (with respect to the number of
%%%%    \dt{entities}, the number \dt{participating processes}) will leave their
%%%%    footprint all over the final system.
%%


\section{Definitions}

The overall \SYNEIGHT\footnote{See definition \vref{def:syneight1}.}
has the sole purpose of maintaining a collection of \dt{entities} in an
efficient, reliable, durable and scalable way. In this section, we will
define \SYNEIGHT more carefully and give some other fundamental
definitions. We will not define any use-cases within this document, but we
will refer to an unspecified user of the \SYNEIGHT, the \dt{client}:

\begin{definition*}{Client}
  \label{def:client}
  A \dt{client} is any system which is not part of the \SYNEIGHT and
  employs one of the \SYNEIGHT's interfaces.
\end{definition*}

An \dt{entity} is a classical object minus behavior, since it has
\emph{state} and \emph{identity}. \dt{Entities} are the unit of
processing within the \SYNEIGHT, so for example primitives such
as locking, accessing, or updating are formulated in terms of
\dt{entities}. Reliability, durability and other management issues is
also configured on a per-\dt{entity} basis.

% we quote this text later
\newcommand{\defentitytext}{An \dt{entity} encapsulates an uninterpreted
  %structured 
  state and is a uniquely identifiable unit (within an
  \dt{entity-database}).}

\begin{definition*}{Entity}
  \label{def:entity} 
  \defentitytext
\end{definition*}
%
%%First we want to note, that ``uninterpreted'' means that the data which
%%represents the state of an \dt{entity} might be structured in some way, but
%%that the \SYNEIGHT has no means to interpret this data in any way. This
%%has an important consequence:
First we want to note, that ``uninterpreted'' means that the \SYNEIGHT
has no means to interpret an \dt{entity's state}\footnote{The precise
  meaning of an \dt{entity's state} is given in definition
  \vref{def:entitys-state}.} directly in any way. This has the following
consequence:
\begin{remark*}{Interpretation Framework}
  The \SYNEIGHT must set up a framework to interpret
  each \dt{entity's state}. Please note that
  interpretation is not only needed for purposes which are external to the
  \SYNEIGHT such as accessing the state itself, but also for internal
  ends such as marshaling the \dt{entity's state} for transmission. Please
  compare with responsibility \vref{resp:entity-state-representation}.
\end{remark*}
%%\begin{remark*}{Marshaling of Entities}
%%  The \SYNEIGHT is only able to transmit an \dt{entity} (internally or
%%  externally) as it is -- which means that if different host architectures are
%%  in use, the \SYNEIGHT needs outside help to do marshaling of data.
%%  Please confer with responsibility \vref{resp:interpretation-framework}.
%%\end{remark*}
%%Related to this issue, one should keep in mind, that \dt{entities} are
%%employed to represent objects. The question arising in this context is how we
%%are going to bind behavior to an \dt{entity}. 
%%\begin{remark*}{Binding Behavior with Entities}
%%  The DODB will be responsible for this binding -- but to do so, it will be
%%  need \emph{hooks} to establish this binding effectively. Again, the arising
%%  requirements are covered by the responsibility
%%  \vref{resp:interpretation-framework}. 
%%\end{remark*}

%%Second, the wording ``structured state'' might need clarification. As we will
%%see, \dt{entities} will be required to handle complex and dynamic states. To
%%do so, it must be possible to subdivide the state into several, identifiable
%%units.
%%\begin{remark*}{Dynamically Managed and Subdivided Entity-States}
%%  \label{remark:dynamically-managed-and-subdivided-entity-states}
%%  The responsibility \vref{resp:entity-state-representation} is collecting all
%%  requirements which are related to these questions. Basically, it must be
%%  possible to allocate/free chunks of memory on a dynamic basis as well as to
%%  identify them within the corresponding entity's state.
%%\end{remark*}

\begin{definition*}{Entity-Database\footnote{This definition will be refined
  by definition \vref{def:entity-database-2}. The definition given here is sufficient
  to understand the chapters which precede chapter \vref{sec:database-access}.}}
  \label{def:entity-database}
  An \dt{entity-database} is a collection of \dt{entities}. Within an
  \dt{entity-database} every \dt{entity} is uniquely identifiable.
\end{definition*}

For the rest of the document, ``\dt{database}'' is always referring to
``\dt{entity-database}''. When we consider other types of databases we will
qualify database further.
%
%%To access a \dt{database}, the following interface has to be employed. The
%%precise meaning of the operations which are supported by this interface will
%%be described in the course of this document. 

For the purpose of this document, we do not consider the underlying hardware
platform. The \dt{databases} to be handled by the \SYNEIGHT are distributed over
\dt{participating processes} where the actual physical distribution of those
processes is only seen in an abstracted way. Again, we will use ``\dt{process}'' as
a short form of ``\dt{participating process}''.
\begin{definition*}{Participating Process}
  \label{def:participating-process}
  A \dt{participating process} is a process which reads from, writes into, or
  maintains an \dt{entity-database} by employing one or more interfaces of the
  \SYNEIGHT.
\end{definition*}
The collection of \dt{participating processes} which support a given
\dt{database} are called the \dt{database's supporting group}. 
\begin{definition*}{Database's Supporting Group}
  \label{def:supporting-participating-process}
  We call the collection of \dt{participating processes} which jointly
  maintain and access a \dt{database} the \dt{database's supporting group}. 
\end{definition*}
%
If it is clear to which \dt{database} we are referring to, we will also speak
about the \dt{supporting group}.
%
\begin{remark*}{Accessing more than one Entity-Database in parallel}
  It will be possible for a \dt{participating process} to access several
  \dt{databases} in parallel.\\
  But in all cases where the parallel access is not essential for the
  discussion, we will only talk about access to a single \dt{database}.
\end{remark*}

Now, we are ready to give a rough definition of the Distributed Shared Memory
itself. This definition will be refined within this chapter, when we have all
the responsibilities of the \SYNEIGHT at hand. The rest of the document
will clarify the requirements which are collected for each of the
responsibilities, thus the precise definition of the \SYNEIGHT will be
constituted by the whole document.

\begin{definition*}{\SYNEIGHT}
  \label{def:syneight1}
  The \SYNEIGHT underlies \dt{participating process} and must allow
  \begin{itemize}
  \item to access and maintain \dt{entity-databases} and
  \item their \dt{entities} on an individual basis, and
  \item must allow to manage and control \dt{participating processes}.
  \end{itemize}
\end{definition*}

\section{Used Interfaces}

In this section we enlist all interfaces which are employed by the
\SYNEIGHT. We do not define the precise responsibilities of these
interfaces, however, we will give a rough circumscription of their
responsibilities and list the requirements which are established by
the needs of the \SYNEIGHT.\\
Please note that the statements about these interfaces are much more sloppy
than the rest of the document. The more precise formulations are to be written
in the respective requirement analysis documents which introduce the
respective modules.\\
Finally, we want to remark, that when we are referring to interfaces, we do not
want to impose any premature structuring of them -- they can be merged,
subdivided, organized in any number of modules.

\subsection{Logical Communication Layer}

\begin{definition*}{Logical Communication Layer (LCL) and LCL-Enabled Processes}
  \label{def:LCL}
  We call a process which uses the \dt{Logical Communication Layer}, \dt{LCL} for
  short, for its communication \dt{LCL-enabled process}. The \dt{LCL} is
  responsible for
  \begin{itemize}
  \item \emph{Abstracting the Underlying Network Topology:} It must provide a
    list of accessible services which are addressable directly. This implies
    that the host which offers the service is transparent as well as the
    network which establishes the connection to this host.
  \item \emph{Support of Uni-, Multi-, Broad-, and Any-Cast:} The \dt{LCL} must
    allow to employ all the mentioned casting mechanisms for message
    transmission. 
  \item \emph{Message Prioritizing:} Messages transmitted from one \dt{LCL-enabled
      process} to another \dt{LCL-enabled} process must be scheduled according
    to a configurable priority.
  \item \emph{Message Reliability:} Messages which are exchanged between 
    \dt{LCL-enabled processes} can be either reliable or unreliable to a
    certain degree. Reliable messages must be guaranteed to arrive at their
    destination, while unreliable messages might get lost. 
  \item \emph{Efficient Protocol Selection:} The \dt{LCL} must choose a
    protocol for transmitting a message depending on the cast-type. It should
    do so in an efficient way, for example, sending a multi-cast message in
    reliable way could be non-trivial. 
  \item \emph{Balancing and Reliability:} If two hosts are
    connected by more than one network, the \dt{LCL} has to balance the
    traffic on these networks and has to establish reliability by detecting a
    network break-down and by reacting accordingly. 
  \end{itemize}
\end{definition*}

The \dt{LCL} might be used by several other components besides the
\SYNEIGHT. It should be designed to levitate a given, complex
network topology, which interconnects a set of hosts in a cluster, to
an easily accessible while efficient, as well as reliable and uniform
communication system.\\
%
The requirements which are brought to the \dt{LCL} by the \SYNEIGHT are
encapsulated in the responsibilities which were listed in the above
definition.

%% \begin{requirement*}{Decoupling}
%%   The \dt{LCL} must be formulated in terms of an interface, which allows to
%%   use different implementations along with this interface.
%% \end{requirement*}
%% 
%% \begin{nonrequirement*}{Binary Packaging}
%%   Although the \dt{LCL} is required to be formulated in terms of an interface,
%%   it is not required to be non-intrusive, i.e., it is not required to provide
%%   the possibility of a dynamic reloading and exchanging of different
%%   \dt{LCL}-implementations.
%% \end{nonrequirement*}
%% 
%% \begin{nonrequirement*}{Compatibility}
%%   Two \dt{LCL-enabled processes} which employ the same \dt{LCL}-implementation
%%   must be compatible with each other but two different
%%   \dt{LCL}-implementations do not need to be compatible with each other. 
%% \end{nonrequirement*}

% XXX0
\subsection{Cluster Management System}


% XXX1
\subsection{Serialization}
\label{sec:introduction:used-interfaces:serialization}


\section{Responsibilities and Global Requirements}

Each responsibility will treated in a dedicated chapter, which has the same
title as the corresponding responsibility described here. Thus, this
subsection servers as an overview over all the functionality which has to be
provided by the \SYNEIGHT. Also, it outlines the general structure of
the document. 

\subsection{Functional Responsibilities}



\newcommand{\respentitystaterepresentation}{ The \SYNEIGHT is
  responsible for providing a sufficiently general representation for the
  state of \dt{entities}. This representation must be abstract from the
  \SYNEIGHT's perspective but provide general methods to integrate
  specific state interpretations into the \SYNEIGHT which might differ
  from \dt{entity} to \dt{entity}, i.e., different types of \dt{entities} must
  be supported. In contrast, the \dt{client's} view of the \dt{entities}
  should be type-safe. The \SYNEIGHT's representation framework should
  allow to employ a wide range of different representation and implementation
  strategies as well as dynamic configuration of these implementations.}


\begin{responsibility*}{Entity State Representation}
  \label{resp:entity-state-representation}
  \respentitystaterepresentation
\end{responsibility*}

\newcommand{\respentityaccess}{The \SYNEIGHT has to provide a sufficient set of access-modes
  which allow efficient (and loosely synchronized) as well as tightly
  synchronized (and less efficient) operations on the states of
  \dt{entities}. In particular, different access-modes are necessary such
  that it is possible to choose different trade-offs between classical
  ACID-semantics\footnote{Atomic, Consistent, Isolated, Durable} and softer
  semantics. This includes direct access as well as message passing.\\
  These access-modes must be matched by a corresponding set of lock-types, which
  allow the \dt{client} to control access to the \dt{entities}.}


\begin{responsibility*}{Entity State Access}
  \label{resp:entity-state-access}
  \respentityaccess
\end{responsibility*}

\newcommand{\respdatabaseaccess}{The \SYNEIGHT is responsible for
  managing the way a \dt{participating process} accesses a \dt{database} as a
  whole. In particular, this responsibility covers all requirements which are
  related to joining and leaving a \dt{database's supporting
  group}. Because of the distributed and replicated nature of the
  \SYNEIGHT, these group-membership operations must include the
  protocols to establish a commonly shared and consistent view on the
  corresponding \dt{database}.}

\begin{responsibility*}{Database Management}
  \label{resp:database-access}
  \respdatabaseaccess
\end{responsibility*}

%%\begin{responsibility*}{Interpretation Framework}
%%  \label{resp:interpretation-framework}
%%  The \SYNEIGHT is not responsible for interpreting the \dt{entities'}
%%  state in any way. However, it must provide means to integrate interpretation
%%  methods. This is the topic of this responsibility. More specifically, the
%%  \SYNEIGHT must allow the \dt{client} to integrate methods for
%%  marshaling and for the interpretation of messages sent to an \dt{entity}. 
%%\end{responsibility*}


\subsection{Semi-Functional Responsibilities}


\begin{responsibility*}{Reliability}
  \label{resp:reliability}
  Based on information provided by the \dt{Logical Network Layer}, the
  \SYNEIGHT is required to ensure a configurable degree of reliability.
  The reliability parameters must be configurable on a per-\dt{entity}
  basis. On the other hand, the overall behavior of a \dt{participating
  process} with respect to \dt{reliability} has to be configurable.
\end{responsibility*}

\begin{responsibility*}{Balancing}
  \label{resp:balancing}
  The \SYNEIGHT must be able to balance the distribution of the
  \dt{database} over the \dt{participating processes} with respect to CPU,
  network-bandwidth and memory consumption. It must be possible for the
  \dt{client} to enhance the balancing by feeding application level
  information about the grouping of \dt{entities} into the balancing system.
\end{responsibility*}

\begin{responsibility*}{Swapping}
  \label{resp:swapping}
  The \SYNEIGHT is responsible for managing the amount of memory which
  is allocated by a \dt{participating process} to keep \dt{entities} within
  the host's  main memory.\\
  If the main memory is not sufficient to keep all required \dt{entities} in
  the main memory, the \SYNEIGHT must be able to swap out those
  \dt{entities} which are least likely used in the near future. 
\end{responsibility*}


\begin{responsibility*}{Durability}
  \label{resp:durability}
  The \SYNEIGHT has to provide means for making a \dt{database} durable,
  i.e., save it to some kind of non-volatile storage\footnote{Examples for
    non-volatile storage are ordinary files, a disk-partition which is managed
    directly by the \SYNEIGHT, or a relational database system.}. The
  behavior of a \dt{participating process} as a whole as well as the
  durability characteristics of each \dt{entity} must be configurable.
\end{responsibility*}


\begin{responsibility*}{Backup Generation}
  \label{resp:backup-generation}
  The \SYNEIGHT must be able to generate a \dt{snapshot} of the current
  state of a \dt{database} during full system operation without incurring a
  large delay. In contrast to the requirement that such a snapshot
  must be consistent, i.e., transactions are atomic with
  respect to snapshots, the generation of the snapshot might be
  deferred over a longer period of time.
\end{responsibility*}



\subsection{Global Requirements}

\begin{responsibility*}{Portability}
  The \SYNEIGHT should be usable on standard UNIX platforms,
  specifically it should be usable on Linux and BSD systems.
\end{responsibility*}

\begin{responsibility*}{Scalability}
  The \SYNEIGHT should be scalable with respect to several load-factors: 
  \begin{itemize}
  \item number of \dt{entities} within a \dt{database}
  \item size of an \dt{entity}
  \item number of simultaneously open \dt{databases}
  \item number of \dt{participating processes}
  \item number of involved hardware components
  \item number of employed threads
  \end{itemize}
\end{responsibility*}


\section{Provided Interfaces}

The \SYNEIGHT provides four different interfaces to the \dt{client},
where each different interface has a different perspective on the
\SYNEIGHT. 
%
We start with the Database Access Interface which is used to access
the contents of a \dt{database}, i.e., its \dt{entities}.
%
The next interface is the Local Database Management Interface, which
is used to configure a \dt{participating process} with respect to a
\dt{database}. 
%
The general configuration of a \dt{process}, i.e., the configuration
which is not specific to a \dt{database}, will be done by using the
Process Management Interface.
%
For operations on a \dt{database} as a whole and for the configuration
of a \dt{database}, we will use the Database Management Interface. 
%
%%from
%%%
%%the access of \dt{databases} and their \dt{entities} itself,
%%%
%%over the process-local management of a \dt{database} as a whole,
%%%
%%to the management of a \dt{participating process},
%%%
%%and the management of a distributed \dt{database} as a unit.
%%%
We will give a brief definition of each of those interfaces, the precise
definitions are an architectural issue.
%
\begin{remark*}{Relationship and Structure of these Interface}
  We want to stress that we do not know at this point the way these
  interfaces are going to be implemented, and how these interfaces are
  going to interact.\\
  %
  We introduce these interfaces to structure the different
  requirements according to their scope of influence for two reasons:
  First, it will allow us to categorize different requirements. And
  second, starting with an abstract architectural conceptualization
  will allow us to understand more thoroughly the true structure of
  the \SYNEIGHT, probably by discarding this initial effort.
\end{remark*}
%
Each interface will be described in a brief paragraph which gives some examples
on what the interface will include. After that we will give a short and concise
definition, which is kept abstract by intention -- we are not able to list all
operations which will be made accessible by each of those interfaces. Instead
we try to establish criteria for what has to be included in each of those
interfaces.

\subsection{Database Access Interface}

The \dt{database access interface} will be the most frequently used
interface of the \SYNEIGHT. It allows a \dt{client} to
read/write data from and to \dt{entities}, to create and delete
\dt{entities}. The necessary management of such operations involves
the locking of \dt{entities}, the configuration of locking
strategies. Finally, as stated in the above responsibilities, there
are several configuration options, which are required to have
per-\dt{entity} granularity. These options will be made accessible by
this interface.

%\newcommand{\DBAI}{{\normalfont\textsc{dbai}}\xspace}

\newcommand{\DBAIText}{This interface allows a \dt{client} to
  \begin{itemize}
  \item access \dt{entities} (this includes transactional support,
  locking, binding, and the access itself) and to
  \item configure the handling of individual \dt{entities}.
  \end{itemize}
  An operation is to be included in this interface if it is issued on a
  per-\dt{entity} basis. 
}

\begin{definition*}{Database Access Interface (\DBAI)}
  \label{def:database-access-interface}
  \DBAIText
\end{definition*}
%
\begin{example*}{Configuration of Individual Entities}
  This formulation might need clarification. For example, it must be possible
  to configure the replication parameters of each given \dt{entity}, see
  responsibility \vref{resp:reliability}. An example for such an parameter
  would be the minimum number of replica-copies to be maintained
  simultaneously. 
\end{example*}
%
The requirements to be fulfilled by this interface will be presented in
chapter \vref{sec:entity-state-access}. 

\subsection{Local Database Management Interface}

The \dt{Local database management interface} will be used to get
access to a database by instantiating it, and it will be used to set
up database access interfaces, which, in turn, allow to access the
\dt{entities} of a \dt{database}. The \dt{local database management
interface} will also allow to control any operations which are issued
on a \dt{database} as a whole \emph{with respect to a
\dt{participating process}} (therefore, this interface is attributed
with \emph{local}).

\begin{example*}{What is Local?}
  There might be \dt{participating processes} which are allowed to accept
  \dt{entity}-copies for replications, while others do not maintain such
  copies. This option might be configurable for each \dt{database} separately
  -- thus it is in the intersection between a \dt{database} and a
  \dt{participating process}. And therefore it would be located in this
  interface.
\end{example*}

%% This means, that the \dt{local database
%%   management interface} allow only, for example, to configure whether a
%% \dt{participating process} is allowed 
%% 
%% that a backup of all
%% \dt{entities} managed by the underlying \dt{participating process} should be
%% backed up, but it does not allow the \dt{client} to issue a backup of the
%% whole \dt{database}.

\newcommand{\LDBMI}{{\normalfont\textsc{ldbmi}}\xspace}

\begin{definition*}{Local Database Management Interface (\LDBMI)}
  \label{def:local-database-management-interface}
  This interface contains all methods which operate on an \dt{entity-database}
  as a whole with respect to a \dt{participating process}\footnote{This means,
  that this interface does not allow to issue global operation on the overall
  \dt{database}, but only on the way a \dt{participating process} handles a
  \dt{database}. It will also serve as the backend for truly
  \dt{database}-global operations.}.
\end{definition*}


\subsection{Process Management Interface}

The \dt{process management interface} will allow a \dt{client} to
configure the resources which are allocated by the overall
\SYNEIGHT for an individual \dt{participating process}. It does
not cover any operations, which are specific a \dt{databases} and
their \dt{entities}.\\ 
An example is the number of threads the \SYNEIGHT is allowed to
use within a \dt{participating process} or the stable storage devices
which are enabled in the \dt{process}. In other words, the \dt{process
management interface} controls the resources which are generally
available in the \dt{process}.

\newcommand{\PMI}{{\normalfont\textsc{pmi}}\xspace}

\begin{definition*}{Process Management Interface (\PMI)}
  This interface allows a \dt{client} to control all resources and
  configuration options which are global to a \dt{participating
  process} and which are \emph{not specific} to any \dt{database}.
\end{definition*}



\subsection{Database Management Interface}

The \dt{database management interface} will be used to manage a
\dt{database} as a whole. Its operations will build upon the
configuration provided by the \dt{client} via all three interfaces
introduced so far within this section.  Typical operation will include
the creation of a backup of a \dt{database}.\\ By the nature of this
interface, it will have to deploy commands to other \dt{participating
processes}, and it is unclear, and intentionally kept unclear, where
the \dt{database management interface} will reside. The two locations
which are conceivable at the moment are any one of \dt{participating
process} which is in the corresponding \dt{database's supporting
group} as well as a dedicated console.

\newcommand{\DBMI}{{\normalfont\textsc{dbmi}}\xspace} 

\newcommand{\DBMIquote}{This interface allows a \dt{client} to issue
  \dt{database}-global operations, which are to be executed by and to be
  synchronized between all \dt{participating processes} which share a
  \dt{database}.}

\begin{definition*}{Database Management Interface (\DBMI)}
  \label{def:database-management-interface}
  \DBMIquote
\end{definition*}



\section{\SYNEIGHT revised}
\label{sec:introduction:syneight-revised}

In this section, we will give a more careful definition of the
\SYNEIGHT. Not all information presented in this section is evident,
especially our overview over the interfaces and responsibilities builds
upon information, which is not presented so far. However, this subsection should
give the reader a through feeling what the \SYNEIGHT is required to
handle, and which \dt{client}-visible interfaces  will be there to work with
the \SYNEIGHT.

\subsection{Interfaces vs. Responsibilities}


The following table lists all of the above responsibilities as rows, and all
interfaces as columns. Each entry shows which kind of impact the
corresponding responsibility has on the associated interface. We use the
following terms in the table-entries:
\begin{itemize}
\item \emph{control} indicates that the operations required by the
  corresponding responsibility are controlled from the associated
  interface. More specifically, control stands for an interface whose methods
  trigger the core operations of the responsibility.
\item \emph{entity config.~}stands for a configuration which happens on a
  per-\dt{entity}-basis. Those configurations might trigger internal
  actions, but they are not observable on any interface.
\item \emph{process config.~}indicates that an interface is used to
  configure a \dt{participating process} with respect to a \dt{database}.
\item \emph{resources config.~}stands for resource configurations which are
  global to a \dt{participating process}.
\item \emph{audit} indicates that the interface will allow to read statistical
  data, but will not allow to manipulate the underlying components of
  the \SYNEIGHT.
\end{itemize}
%
\begin{center}\begin{footnotesize}
\begin{tabular}{|l||c|c|c|c|}
\hline
                            & Database        & Local Database      & Process            & Database       \\ \hhline{|~||~|~|~|~|}
                            & Access (\DBAI)  & Manag.~(\LDBMI)     & Manag.~(\PMI)      & Manag.~(\DBMI) \\ \hhline{=#====}
Entity State Representation & --              & process config.     & resource config.   & control        \\ \hhline{=#====}
Entity State Access         & control         & --                  & --                 & --             \\ \hhline{=#====}
Database Management         & --              & control             & --                 & control        \\ \hhline{=#====}
Reliability                 & entity config.  & process config.     & resource config.   & audit          \\ \hline
Balancing                   & entity config.  & process config.     & resource config.   & audit          \\ \hline
Swapping                    & entity config.  & process config.     & resource config.   & audit          \\ \hhline{=#====}
Durability                  & entity config.  & process config.     & resource config.   & control        \\ \hline
Backup Generation           & entity config.  & process config.     & resource config.   & control        \\ \hline
\end{tabular}
\end{footnotesize}\end{center}
%
There are five different types of responsibilities with respect to the above
table, which are summarized in the following list.
\begin{itemize}
\item The first responsibility (Entity State Representation)
  deals with the integration of entity state representations into the
  \SYNEIGHT. This responsibility covers the management of
  different implementations for the representation of the \dt{entity
  states} (in the \PMI). These implementations must be made available
  for usage in a database by employing the \DBMI and the
  \LDBMI.\footnote{The correspondingly configured entity type
  implementations will be made available for usage in the \DBAI, i.e.,
  the effects of the configuration will be observable at the
  \DBAI. But the impact of the Entity Type Representation on the
  \DBAI has neither a controlling nor an auditing character.}
\item The next responsibility, Entity State Access,  has only an impact on the \DBAI. It
  deals with the access of \dt{entities} -- locking them, binding them to
  type-safe stubs, and accessing their contents. 
%\item Behavior framework responsibilities are configuration options which are
%  only used to integrate higher level systems into the \SYNEIGHT. 
\item The responsibility Database Management allows the \dt{client} to gain
  access to a \dt{database}. These operations are controlled via the
  \LDBMI and the \DBMI.
\item The next three responsibilities (i.e., Reliability, Balancing,
  and Swapping) are concerned with requirements which
  are non-functional but which have to be configured. That is, they produce no
  result, they only affect the behavior of the \SYNEIGHT.
\item Finally, the last two responsibilities (i.e., Durability and
Backup-Generation) deal with creating persistent images of a
\dt{database}. Such an effort has to be coordinated, thus there is a
control indicator, but at the same time, these responsibilities need
configuration on all levels.
\end{itemize}

%%\subsection{IPC Interface}
%%The fourth interface presented here, the \dt{IPC interface} is an internal
%%interface -- it defines how a \dt{participating process} is going to
%%communicate with another \dt{participating process} by employing the
%%\dt{LCL}. Thus the \dt{IPC interface} can only defined at the end of the
%%design phase. 


\subsection{A Definition}
\label{sec:a-definition}

The definition shown here is refining the original one\footnote{See definition
  \vref{def:syneight1}.} by replacing the formerly employed phrases by now
well-defined terms. The \SYNEIGHT has to provide
the enlisted interfaces and has to achieve the responsibilities shown above.\\
For first time, we also mention tools in this definition. It might be possible
that certain tasks required by the \SYNEIGHT are not achieved by
\dt{participating processes} but by dedicated and specialized tools. The
decision, whether we are going to employ external tools is beyond the scope of
this document.

\begin{definition*}{\SYNEIGHT}
  \label{def:syneight2}
  The \SYNEIGHT consists of a library or several libraries which are
  linked into \dt{participating processes} along with a set of tools, which
  provide the 
  %
  \dt{database access interface}, the
  %
  \dt{local database management interface}, the
  %
  \dt{database management interface}, and the
  %
  \dt{processes management interface}
  %
  to achieve the responsibilities 
  %
  Entity State Representation,
  %
  Entity State Access,
  %
  Database Management,
  %
  Reliability,
  %
  Balancing,                   
  %
  Swapping,                    
  %
  Durability,                  
  %
  Backup Generation.
\end{definition*}


%% \section{Implicit Decisions}
%% \label{sec:implicit-decisions}
%% 
%% This section will present decisions, which are already encapsulated in
%% the definitions, interfaces and  responsibilities which were postulated in
%% this chapter. 
%% 
%% 
%% 
%% \subsection{Domain of the \SYNEIGHT}
%% 
%% \subsection{Process Architecture}
%% 
%% 
%% \begin{decision*}{The \SYNEIGHT is Part of any Participating Process}
%%   The \SYNEIGHT will be linked into the each \dt{participating
%%   process}. Thus the target system will consist mainly of a multi-threaded
%%   monolithic process.
%% \end{decision*}
%% 
%% \begin{rationale*}{One Process, Quicker Context Switch, One Host, One Process}
%%   First, we plan to utilize the \SYNEIGHT within a cluster where each
%%   host is dedicated to the target application. Thus we decided that it would
%%   be the most efficient solution to have one major process running on each
%%   host.\\
%%   In consequence, only one process per hosts needs to access the database(s)
%%   -- thus there is no gain in maintaining the database(s) within one process
%%   which shares its data with all other processes running on the
%%   system. Moreover, sharing and synchronizing over process-boundaries is much
%%   more expensive than between threads. 
%% \end{rationale*}
%% 
%% Naturally, the \SYNEIGHT could be implemented in a way which would
%% counter the efficiency problems with processes which are residing on the same
%% host: 
%% 
%% \begin{remark*}{Implementing several Participating Processes on the same Host}
%%   It would be possible to implement a shared memory architecture which would
%%   allow several \dt{participating processes} to access \dt{databases} and
%%   communicate effectively. 
%% \end{remark*}
%% 
%% \begin{question*}{A Shared Memory Architecture?}
%%   There are several levels where such an optimization (which treats
%%   \dt{processes} which are co-located at the same host in a special manner)
%%   could take place. This is definitely an architectural question. 
%% \end{question*}
%% 


\section{Generally Used Definitions}

This section contains definitions will be useful to state other definitions
and requirements in the course of the document. 

\begin{definition*}{Logically Equivalent}
  We say two instances of an object which implements a data type are
  logically equivalent, if they are indistinguishable by any client which
  accesses them.
\end{definition*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Entity State Representation}
\label{sec:entity-state-representation}


\section{Starting Point}
\label{sec:esr-goal}

In this chapter, we will present all the requirements, which arise from 
responsibility \ref{resp:entity-state-representation} ``Entity State
Representation'', described on page
\pageref{resp:entity-state-representation}. The responsibility was worded as
follows:
\begin{quote}
  \respentitystaterepresentation
\end{quote}
Let us remember the definition \ref{def:entity}
of an \dt{entity} printed on page \pageref{def:entity} which is phrased as follows:
\begin{quote}
  \defentitytext
\end{quote}
We will describe in more detail the structure of an
\dt{entity's state} and we will state the requirements which specify the
\SYNEIGHT's view on an \dt{entity's state}. 
%
More specifically, we will focus on the requirements of \dt{entity type 
  implementations}\footnote{See definition \vref{def:encapsulated-state-implementation}.}. 
%
These implementations are provided by the \dt{client} and are responsible for
the maintenance of the part of an \dt{entity's state}, which is used by the
\dt{client} for its own purposes (we call this part of an \dt{entity's state}
the \dt{entity's encapsulated state}\footnote{See definition
  \vref{def:encapsulated-state}.}). 
%
The \dt{client} has the possibility to load these \dt{entity type
  implementations} dynamically into the \SYNEIGHT. Each \dt{entity type
  implementation} defines an \dt{entity type}. Whenever a new \dt{entity} is
created by the \dt{client}, one of the available \dt{entity types} has to be
specified -- subsequently the management of the \dt{encapsulated state} is
delegated to the associated \dt{entity type implementation}.
%
%Finally, we describe how this internal representations are mapped to
%\dt{client}-visible representations.

%%In this section we disregard the required contents of the \dt{configuration
%%  state} and the \dt{static configuration state}. The contents of these states
%%will be described throughout this document, because different responsibilities
%%require different configuration options and audit information which are
%%orthogonal to each other.\\
%%%
%%Thus we will specify the requirements for the \dt{encapsulated state
%%  implementation} which consists of implementations for its \dt{entity's encapsulated state}
%%as well as the requirements for the \dt{static encapsulated state}

%%As noted in the introduction after this definition in remark
%%\vref{remark:dynamically-managed-and-subdivided-entity-states}, we will focus
%%here on the requirements which have to be met by the ``structured state'',
%%i.e., we will explicate the required structure of each \dt{entity's state}.

%%\section{Leading Requirements}
%%
%%This section presents the leading requirements, which motivate the definitions
%%of this chapter and which lead to the detailed requirements. These
%%requirements are directly derived from the wording of the herein covered
%%responsibility.
%%
%%\begin{requirement*}{The Entities' Representation must be Abstract for the \SYNEIGHT}
%%  It is required that the representation of the \dt{entities} is abstract from
%%  the point of view of the \SYNEIGHT. It must be abstract enough, such
%%  that big variety of implementation strategies for these representations can
%%  be employed. 
%%\end{requirement*}
%%
%%\begin{requirement*}{Entities have Type}
%%  It must be possible to implement different types of \dt{entities}.
%%\end{requirement*}
%%
%%\begin{requirement*}{Entities must have Static State, depending on their Type}
%%  It must be possible to store type-static information for each type of \dt{entity}.
%%\end{requirement*}
%%
%%\begin{requirement*}{The Entities' Representation must be Accessed Type-Safe
%%    by the Client}
%%  The \dt{client} must have a type-safe access interface to the entities'
%%  representation. In particular, the \dt{client} must have to possibility to
%%  incorporate a type-safe binding of stubs to the \dt{entities}. 
%%\end{requirement*}
%%
%%\begin{requirement*}{
%%  
%%\end{requirement*}

\section{Definitions}
\label{sec:esr-definitons}

%%\subsection{State-Taxonomy Summary}
%%
%%The following table summarizes the different states which will be defined in
%%what follows. The two rows distinguish between the states which are stored for
%%each \dt{entity}, and the states which are stored for each \dt{entity type}.
%%The first two columns distinguish between the state information which is
%%interpreted exclusively by the \dt{client} and the state information which is
%%shared by the \SYNEIGHT and the \dt{client}. The third column shows the
%%name of the state which consists of the states displayed in the two former
%%columns of the same row.
%%
%%\begin{center}\begin{small}\begin{tabular}{|l||l|l|l|} \hline
%%                   & Client                           & Client/\SYNEIGHT                 & Total               \\ \hhline{====}
%%per Entity         & Entity's Encapsulated State      & Entity's Configuration State      & Entity's State      \\ \hline
%%per Entity Type    & \hfill Static Encapsulated State & \hfill Static Configuration State & \hfill Static State \\ \hline
%%\end{tabular}\end{small}\end{center}


\subsection{State Structure}
\label{sec:entity-representation:definitions:state-structure}

So far we treated an \dt{entity's state} as a data collection which is somehow
accessible to the \dt{client}. When we talked about an \dt{entity's state}, we
talked about the data which is accessible to the \dt{client} and which is
employed by the \dt{client} for a purpose which is unknown by the
\SYNEIGHT. We also talked about configuration options which are given on
a per-\dt{entity}-basis.
%
We have to explicate our notion of an \dt{entity's state} with respect to these
terms.
%
%%Besides the \dt{entity's encapsulated-state} other state information has to be
%%maintained for each \dt{entity}, namely the \dt{entity's configuration state}.
First, let us define, what we mean by an \dt{entity's state}.
\begin{definition*}{Entity's State}
  \label{def:entitys-state}
  An \dt{entity's state} consists of all state information stored within an
  \dt{entity}, disregarding whether it is used by the \SYNEIGHT, or the
  \dt{client} or both.  
\end{definition*}
%
An \dt{entity's state} is divided into several sub-states. We will use the
following two definitions to distinguish the different parts of an
\dt{entity's state}.
%
The first part is the state which is used and interpreted exclusively by the
\dt{client}, i.e., it is the part of the state we were referring to implicitly
-- the \SYNEIGHT is only responsible for distributing this data.
\begin{definition*}{Entity's Encapsulated State}
  \label{def:encapsulated-state}
  An \dt{entity's encapsulated state} is the part of an \dt{entity's state}
  which consists of the data which is exclusively used by the \dt{client} for its
  own purpose. 
\end{definition*}
As mentioned in the responsibilities, the way an \dt{entity} is
handled by the \SYNEIGHT must be configurable. Thus the corresponding
state is accessed by the \dt{client} as well as by the \SYNEIGHT.
\begin{definition*}{Entity's Configuration State}
  The \dt{entity's configuration state} is the part of an \dt{entity's state}
  which is employed by the \dt{client} to control the handling of the
  \dt{entity} by the \SYNEIGHT.
\end{definition*}
Finally, the \SYNEIGHT will maintain internal state information to
comply with the \dt{client's} requests. But this state-information is an
implementation detail, which is not of interest at this moment.

\subsection{Entity Type}

We said that the \SYNEIGHT's perspective on an \dt{entity's state} must
be abstract. Using the new, more explicit definitions of this chapter, we
formulate this statement more precisely: The \dt{entity's encapsulated state}
must offer an abstract interface to \SYNEIGHT which allows the
\SYNEIGHT to delegate all tasks which are related to the interpretation
of the \dt{entity's encapsulated state} to the \dt{entity type
  implementation}.
\begin{definition*}{Entity Type Implementation and its Implementation
    Id}
  \label{def:encapsulated-state-implementation}
  An \dt{entity type implementation} implements concretely the structure and
  interpretation of \dt{entities' encapsulated states}. Each \dt{entity 
    type implementation} is uniquely identifiable by an \dt{implementation id}
  with respect to the whole \SYNEIGHT\footnote{This means that the
  \dt{implementation id} must be unique not only with respect to a fixed
  \dt{database} but with respect to all \dt{databases} which might be loaded
  simultaneously by a \dt{participating process}.}. 
  %
  Each \dt{entity type implementation} must adhere to the abstract interface
  imposed by the \SYNEIGHT.
\end{definition*}
%
In the above definition, we mentioned an abstract interface, which is imposed
by the \SYNEIGHT on each \dt{entity type implementation}. We give this
interface a specific name:
\newcommand{\ETI}{\normalfont\textsc{eti}\xspace}
\begin{definition*}{Entity Type Interface (\ETI)}
  The \dt{entity type interface} describes the way an \dt{entity type
    implementation} has to be set up, i.e., it specifies precisely the
  requirements which have to be met by every \dt{entity type implementation}
  to be integratable into the \SYNEIGHT.
\end{definition*}
%
That is to say that the \dt{implementation id} of the \dt{entity type
  implementation} which is employed by the \dt{client}\footnote{The choice for
  the implementation to be used for a specific \dt{entity} is a
  \dt{client}-side choice.} for a specific \dt{entity} is its
type:
\begin{definition*}{Entity's Type}
  The \dt{entity's type} is the \dt{implementation id} of the \dt{entity type
    implementation} which is responsible for this \dt{entity}.
\end{definition*}

\subsection{Static Entity}

Each \dt{entity type implementation} will have an associated \dt{static
  entity}. We use the term ``static'' in resemblance of the C++-naming, i.e.,
the \dt{static state}, which is associated with an \dt{entity type
  implementation} can be accessed by specifying the corresponding
\dt{implementation id}. Let us turn this notion into definitions:

\begin{definition*}{Static Entity}
  Each \dt{entity type implementation} has an associated, unique \dt{static
    entity}. Such a \dt{static entity} is used to store information which is
  shared and aggregated from all \dt{entities} which are managed by the
  corresponding \dt{entity type implementation}.
\end{definition*}
We subdivide the \dt{static entity's state} as we do in the case of ordinary
\dt{entity's states}, i.e., they have an \dt{encapsulated state} and an
\dt{configuration state}. Its \dt{encapsulated state} is entirely managed by
the corresponding \dt{entity type implementation} -- thus it is
\dt{client}-defined. The \dt{configuration state} of a \dt{static entity}
differs from the \dt{configuration state} of an ordinary \dt{entity}, since
the configuration options which are accessible per \dt{entity type} are
different from the configuration options which are necessary on a
per-\dt{entity}-basis.

Sometimes we will have to distinguish between the
\dt{encapsulated/configuration states} which are provided by the
\dt{entity type implementation} for the ordinary \dt{entities} and for
the \dt{static entities}. In such cases we call these states
\dt{entity's/static encapsulated/configuration states}.

%%into two sub-states, where
%%the first one is used by the \dt{client} and the second one is employed by the
%%\dt{client} and the \SYNEIGHT for configuration purposes.
%%\begin{definition*}{Static Encapsulated State}
%%  \label{def:encapsulated-static-state}
%%  The \dt{static encapsulated state} is the part of an \dt{entity type
%%    implementation's} \dt{static state} which is handled by the \dt{client}
%%  only for means which are unknown by the \SYNEIGHT.
%%\end{definition*}
%%\begin{definition*}{Static Configuration State}
%%  The \dt{static configuration state} is the part of an \dt{entity type
%%    implementation's} \dt{static state} which is used by both, the \dt{client}
%%  and the \SYNEIGHT for configuration and audit purposes, i.e., the
%%  \dt{client} will use it to control the \SYNEIGHT's handling of the
%%  associated \dt{entity type implementation} and the \SYNEIGHT
%%  will communicate audit information through \dt{static configuration state}
%%  to the \dt{client}.
%%\end{definition*}
%%



\subsection{Entity Type Configuration}
\label{sec:entity-type-representation:def:entity-type-configuration}

We will need some further definitions to state the requirements for the
configuration of \dt{entity type implementations}. These definitions make the
possible states of an \dt{entity type implementation} explicit. We distinguish
\dt{available}, \dt{active} and \dt{used} \dt{entity type implementations}.

\begin{definition*}{Available Entity Type Implementations}
  \label{def:available-entity-type-implementation}
  An \dt{entity type implementation} is \dt{available}
  \begin{itemize}
  \item \dt{with respect to a participating process} if it is integrated into
    the underlying \SYNEIGHT.
  \item \dt{with respect to a database} if the \SYNEIGHT enforces that
    the \dt{entity type implementation} is \dt{available} in all
    \dt{participating processes} which maintain this \dt{database}.
  \end{itemize}
  If an \dt{entity type implementation} is not \dt{available}, we say it is
  \dt{unavailable}. 
\end{definition*}
%
The availability of an \dt{entity type implementation} does not imply
that the \dt{client} is allowed to create an \dt{entity} of the
corresponding \dt{type}. To create \dt{entities} of this \dt{entity
type}, the \dt{entity type implementation} must be made \dt{active}.
%
If an \dt{entity type implementation} is available on all \dt{participating
  processes} which maintain a \dt{database} collectively, if can be made
active with respect to that \dt{database}.
\begin{definition*}{Active Entity Type Implementation}
  An \dt{entity type implementation} is \dt{active} 
  \begin{itemize}
  \item \dt{with respect to a database} if the \dt{processes} of the
    \dt{database's supporting group} are allowed to activate this
  \dt{entity type implementation}.
  \item \dt{with respect to a participating process and a database} if it can
    be used by the \dt{client} within this \dt{process} to create
  \dt{entities} of the \dt{entity type} which is 
    provided by the \dt{entity type implementation} in the
    corresponding \dt{database}.
  \end{itemize}
  If an \dt{entity type implementation} is not \dt{active}, we say it is
  \dt{inactive}. 
\end{definition*}
Even if an \dt{entity type implementation} is not \dt{active with respect to a
  database}, it can be still in use to support one or more \dt{entities}
within the corresponding \dt{database}. The \dt{entity type implementation} is
said to be in \dt{use with respect to this database}, as long as an
\dt{entity} of the corresponding \dt{entity type} exists. 
\begin{definition*}{Used Entity Type Implementation}
  An \dt{entity type implementation} is \dt{in use with respect to a database}
  if this \dt{database} contains at least one \dt{entity} whose \dt{type} is
  supported by the \dt{entity type implementation} in concern.\\
  If an \dt{entity type implementation} is not \dt{used}, we say it is
  \dt{unused}. 
\end{definition*}

Let us summarize how these states interact with each other. First we describe
how to \emph{enter} one of these states in the following table. In the first
column we write the state to be entered, in the next column the describe the
corresponding prerequisites to enter this state. The third column
displays the interface which is used to issue the transition, and finally, the
fourth column gives some more details on the transition.
\begin{center}\begin{small}
\begin{tabular}{|p{3cm}|p{3cm}|l|p{7cm}|} \hline
  \textbf{New State}         & \textbf{Prerequisite}              & \textbf{Interface} & \textbf{Transition} 
  \\ \hhline{====}

  \multicolumn{4}{|c|}{\textbf{Available}}
  \\ \hline

  wrt.~process               & --                                 & \PMI               &
  loading the implementation into the process \\ \hline

  wrt.~database              & available in the supporting group  & \DBMI              &
  declaring the implementation as database-wide available \\ \hhline{====}
  
  \multicolumn{4}{|c|}{\textbf{Active}}
  \\ \hline
  wrt.~database              & available wrt.~database            & \DBMI              &
  declaring the implementation as active \\ \hline

  wrt.~process \& \newline database   & active wrt.~database      & \LDBMI             &
  declaring the implementation as active wrt.~the process \& database \\ \hhline{====}
  
  \multicolumn{4}{|c|}{\textbf{Used}}
  \\ \hline
  wrt.~database              & active wrt.~process \& database    & \DBAI              &
  this process creates an entity of the corresponding entity type
  \\ \hline
\end{tabular}
\end{small}\end{center}
Please note that the states in the above table form one serial chain, i.e.,
starting from \dt{availability wrt.~process}, the \dt{client} has to go
through all other immediate states until the \dt{client} can bring the
\dt{implementation} to usage. While \dt{activity} is an option, if a
\dt{process} joins the \dt{supporting group} of a \dt{database},
\dt{availability} is not. If the \dt{database} locked the \dt{availability} of
an \dt{entity type implementation}, every process has to have the \dt{entity
  type implementation} in the \dt{available} state.\\
%
Now we give the reverse transitions, i.e., how to haul back from \dt{usage} to \dt{unavailability}.
\begin{center}\begin{small}
\begin{tabular}{|p{3cm}|p{3cm}|l|p{7cm}|} \hline
  \textbf{New State}                & \textbf{Prerequisite}                 & \textbf{Interface} & \textbf{Transition} 
  \\ \hhline{====}

  \multicolumn{4}{|c|}{\textbf{Unused}}
  \\ \hline
  wrt.~database                     & --                                    & \DBAI              &
  all entities of the corresponding entity type are destructed/converted
  \\ \hhline{====}

  \multicolumn{4}{|c|}{\textbf{Inactive}}
  \\ \hline
  wrt.~process \& \newline database & --                                    & \LDBMI             &
  declaring the implementation as inactive wrt.~the process \& database \\ \hline

  wrt.~database                     & --                                    & \DBMI              &
  declaring the implementation as database-wide inactive \\ \hhline{====}


  \multicolumn{4}{|c|}{\textbf{Unavailable}}
  \\ \hline

  wrt.~database                     & unused and inactive wrt.~database     & \DBMI              &
  declaring the implementation as database-wide unavailable \\ \hline

  wrt.~process                      & unavailable wrt.~all supported databases & \PMI            &
  unloading the implementation from the process \\ \hline
\end{tabular}
\end{small}\end{center}
As the above table shows, it is perfectly possible, that an \dt{entity state
  implementation} is \dt{used} in a \dt{database} but not \dt{active} in this
\dt{database}. If an \dt{entity type implementation} is declared \dt{inactive}
wrt.~a \dt{database}, it is implicitly set \dt{inactive} wrt.~this
\dt{database} in all \dt{processes} in the \dt{database's supporting group}.


\subsection{Entity Type Evolution}

The \SYNEIGHT must be able to exchange the \dt{entity type
  implementations}. More precisely, upon a corresponding request by the
\dt{client} to change from \dt{entity type implementation} $A$ to \dt{entity
  type implementation} $B$ , each \dt{encapsulated state} which was of type
$A$ must be feed into a \dt{converter} which converts the original
\dt{encapsulated state} into an \dt{encapsulated state} of type $B$. 
%
Distinguishing \dt{static} and \dt{entities' encapsulated state} we have the
following definitions:
\begin{definition*}{Entity's/Static Encapsulated State Converter}
  An \dt{entity's/static encapsulated state converter} converts an
  \dt{entity's/static encapsulated state} managed by an original \dt{entity
    type implementation} $A$ into an \dt{entity's/static encapsulated state}
  which is to be handled by the new \dt{entity type implementation}.
\end{definition*}
%
To provide efficient conversion, it will be necessary, that the new \dt{entity
  type implementation} $B$ understands all messages which arise from the old
\dt{entity type implementation} $A$. We summarize this notion into the
following definition:
\begin{definition*}{Message Compatible Encapsulated State Implementation}
  An \dt{encapsulated state implementation} $B$ is \dt{message compatible} to
  another \dt{encapsulated state implementation} $A$, if it can interpret and
  accept all messages arising from \dt{entity's/static encapsulated states}
  which are managed by $A$.
\end{definition*}


%%The reason, why we chose the name \dt{entity type implementation}
%%instead of talking about classes or types is the following:
%%\begin{rationale*}{Encapsulated State Implementation vs.~Types}
%%  From the perspective of the \SYNEIGHT it does not matter whether two
%%  \dt{encapsulated state implementations} implement the same
%%  \dt{client}-visible type or not -- the \SYNEIGHT does not know
%%  anything about the structure of an \dt{encapsulated state} (besides its
%%  \dt{implementation id}).
%%  %
%%  Moreover \SYNEIGHT has no knowledge about possible relationships
%%  between these different implementations. Thus we prefer the term
%%  ``implementation'', since this naming reflects the \SYNEIGHT's more
%%  accurately. 
%%\end{rationale*}
%%The reader might ask where we are going to introduce types, or even more
%%specifically, where we are going to introduce the classes of the objects which
%%will represented by the \dt{entities}. A precise answer is beyond the scope of
%%this document, but the next remark should clarify this issue.
%%\begin{remark*}{Representation of Objects within Entities' Encapsulated States}
%%  We are required to provide means to ``employ a wide range of different
%%  representation and implementation strategies''\footnote{Last sentence of the
%%    responsibility \vref{resp:entity-state-representation}.} --
%%  \dt{encapsulated state implementations} will be provided by the \dt{client}
%%  of the \SYNEIGHT. To allow an cost-efficient production and usage of
%%  these implementations, a module in its own will be needed. This module is
%%  the DODB.
%%\end{remark*}



\subsection{Binding and Anchoring}
\label{sec:entity-state-representation:def:binding-and-anchoring}

Since the \SYNEIGHT has no clue about the contents of an
\dt{encapsulated state} but the \dt{client} must be able to access each
\dt{encapsulated state} in a structured and safe way, there must be some
binding mechanism which allows a \dt{client} to bind an \dt{encapsulated
  state} to a high-level interface.
%
For uniformity reasons, we will require the \SYNEIGHT to manage the
access to \dt{entity's/static configuration states} in the same way. 
%
We do not specify in which way this binding has to be implemented, however, we
define the following abstract states on an \dt{encapsulated/configuration state}:
\begin{definition*}{Bound Encapsulated/Configuration States, Bound Count}
  An \dt{encapsulated/configuration state} is \dt{bound} if it is accessible
  by the \dt{client} through some high-level interface. This binding lasts as
  long as the associated access is possible. We say that a state which
  is not \dt{bound} is \dt{unbound}.\\
  %
  If a state is \dt{bound} several times, the state's bound count equals this
  number. The \dt{bound count} equals zero, if the state is \dt{unbound}.
\end{definition*}
%
The \dt{client} will employ so-called \dt{binders} to settle such a
\dt{binding}. The \dt{binder} will offer the above-mentioned high-level
interface.
\begin{definition*}{Binder}
  \label{def:binder}
  A \dt{binder} is used by the \dt{client} to setup a \dt{binding} between a
  high-level interface and a state. The \dt{binder} will grant access to the
  state only via the corresponding well defined high-level interface.
\end{definition*}
%
In the case of \dt{encapsulated states}, the \SYNEIGHT does only know
that there are \dt{binders}, thus they have to be treated within the
\SYNEIGHT in an abstract way.


Thus \dt{bindings} represent the use of a state by the \dt{client}. The
\SYNEIGHT has its own mechanism to manage the use of an \dt{encapsulated
  state}. This mechanism is called \dt{anchoring}.
\begin{definition*}{Anchored Encapsulated State, Anchor Count}
  An \dt{encapsulated state} is said to be \dt{anchored} if it is maintained
  and referenced by the \SYNEIGHT. There might be several parallel
  references to an \dt{encapsulated state}, thus there is an \dt{anchor count}
  which reflects the number of \SYNEIGHT-internal references to an
  \dt{encapsulated state}.\\
  An \dt{encapsulated state} which is not \dt{anchored} is called
  \dt{unanchored}. 
\end{definition*}
% XXX
% the binding will be separated from the typifying, i.e., an encapsulated
% state will be bound, which locks the encapsulated state. Then the \SYNEIGHT
% typify a binder. Maybe, we will use another terminology:
% A encapsulated state will be access-locked and then, it will be bound?!
%

The reader might ask, why we should employ two different reference counts to
the \dt{encapsulated states}. The following remark should clarify this
issue:
\begin{remark*}{Anchor vs.~Binding}
  As long as an \dt{anchor} for an \dt{encapsulated state} exists, the
  \dt{database} might sill need the \dt{encapsulated state} in the future. In
  contrast, as long as a \dt{binder} to an \dt{encapsulated state} exists,
  the \dt{client} is accessing the \dt{encapsulated state}.\\
  That is to say, \dt{binders} signify a temporary view while \dt{anchors}
  signify persistence.
\end{remark*}
%
The mechanics behind \dt{anchors} are not of interest now, since these issues
are a design question of \SYNEIGHT. However, \dt{binders} are an
interface-issue and have to be discussed in an abstract way in this document. 



Besides direct access to a state by connecting to it a \dt{binder}, the
\SYNEIGHT will also provide a message-passing mechanism.
%
In analogy to the \dt{binder} defined above, the message-passing is based on a
\dt{message binder}.

\begin{definition*}{Message Binder}
  \label{def:message-binder}
  A \dt{message binder} is used by the \dt{client} to send messages to a
  pre-specified \dt{encapsulated/configuration state}.\\
  %
  If the \dt{encapsulated/configuration state} answers with another message,
  the \dt{message binder} will allow optionally to receive the message and
  inspect it through a well-defined interface.
\end{definition*}






\subsection{Architecture Independence}

The last issue to be defined is architecture independence. We say that
\dt{entity type implementation} is \dt{architecture independent} if it is able
to provide all messages which are meant to be exchanged between different
\dt{participating processes} in an \dt{architecture independent} way, e.g., it
has to encode all numeric values in a fixed format. 

\begin{definition*}{Architecture Independence of Entity Type Implementations}
  An \dt{entity type implementation} is said to be \dt{architecture
  independent}, if it is able to generate all messages which are meant to be
  sent to another \dt{participating process} in an architecture independent
  way.\\
  Whether such an \dt{entity type implementation} is generating architecture
  independent messages or not, must be decidable at run-time.
\end{definition*}
Clearly, an \dt{entity type implementation} can generate architecture
independent messages by default. However, this can include overhead, thus, the
\SYNEIGHT will not ask for architecture independent messages, if it does
not need them.


\section{Requirements}
\label{sec:esr-requirements}

\subsection{Entity Type Configuration}
\label{sec:entity-type-representation:req:entity-type-configuration}

We start with the requirements which are related to the configuration of
\dt{entity type implementations}, since without configuring at least one
\dt{entity type implementation}, it is impossible to create an \dt{entity}
within a \dt{database}.\\
%
With the ``configuration'' of an \dt{entity type implementation}, we mean the
switching between the states of an \dt{entity type implementation} defined
above, see the three definitions starting with definition
\vref{def:available-entity-type-implementation}. 


\begin{requirement*}{Process-Wide Availability of Entity Type Implementations}
  It must be possible to make an \dt{entity type implementation} \dt{available
    with respect to a participating process} dynamically, as well as to
  make it \dt{unavailable} if it is \dt{inactive with respect to this
    process} and \dt{unavailable} in all \dt{databases} which are
    \dt{supported} by this \dt{process}.\\
  \INTERFACE{\PMI}
\end{requirement*}
%
\begin{requirement*}{Database-Wide Availability of Entity Type Implementations}
  It must be possible to make an \dt{entity type implementation} \dt{available
    with respect to a database} dynamically if it is \dt{available with
    respect to the database's supporting group}.\\ On the other hand, it must
  be possible to make an \dt{entity type implementation} \dt{unavailable with
    respect to a database}, if it is \dt{inactive} and \dt{unused with respect
    to this database}.\\
  \INTERFACE{\DBMI}
\end{requirement*}
\begin{requirement*}{Database-Wide Activation of Entity Type Implementations}
  It must be possible to make an \dt{entity type implementation} \dt{active
    with respect to a database}, if it is \dt{available with respect to this
    database}.\\
  On the other hand, it must be possible to make an \dt{entity type
    implementation} \dt{inactive with respect to a database} \emph{at any
    time}. This means, that no new \dt{entity} of the corresponding \dt{entity
    type implementation} can be created, while it might be still \dt{used}.\\
  \INTERFACE{\DBMI}
\end{requirement*}

Once an \dt{entity type implementation} is \dt{active with respect to a
  database} it might become \dt{used with respect to this database}. This
state transition is not controlled by one of the management interfaces but
happens by creating an \dt{entity} of the corresponding \dt{type}
via the \DBAI.\\
%
Since we need to know whether an \dt{entity type implementation} is \dt{used
  with respect to a database} to check whether we can make it \dt{unavailable},
we have to provide an efficient method for this purpose. 

\begin{samepage}\begin{requirement*}{Efficient Use-Count of Entity Type Implementations}
  It must be possible to get an \emph{approximate} use-count for each
  \dt{entity type implementation} with respect to any given
  \dt{database}. This approximation must have the following properties: 
  \begin{itemize}
  \item It must follow the true use-count slowly, for example five second
    intervals, while it is not required to be precise at any time.\\
    Each \dt{participating process} might display a different use-count to the
    \dt{client}. 
  \item However, if an \dt{entity type implementation} is \dt{inactive}, the
    approximate use-count must be monotonically decreasing and if it equals
    zero, it must be guaranteed, that 
    \begin{itemize}
    \item each \dt{participating process} will display zero use-count within
      some possibly slow updating interval. 
    \item the \dt{entity type implementation} must be truly unused, once all
      \dt{participating processes} display the zero use-count.
    \end{itemize}
  \end{itemize}
  \INTERFACE{\DBMI}
\end{requirement*}\end{samepage}


Since each \dt{participating process} might have different configurations of
\dt{entity type implementations}, we need some requirements for assuring
safety when a \dt{participating processes} joins a \dt{database's supporting
  group}. These requirements will be stated in chapter \vref{sec:database-access}.


\subsection{Entity Type Evolution}

We need to support to different modes of implementation changes: A lightly
synchronized and a tightly synchronized form. Let us start with the tightly
synchronized form, since its semantics are easier.

\begin{requirement*}{Tightly Synchronized Implementation Change}
  If the \dt{client} issues a tightly synchronized implementation change from
  \dt{entity type implementation} $A$ to $B$, from the \dt{client's}
  perspective, all \dt{encapsulated states} of $A$ must be converted within
  one step \dt{database}-wide.\\
  To do so, the \dt{client} has to provide the corresponding \dt{entity/static
  encapsulated state converters}.\\
  \INTERFACE{\DBMI,\ETI}
\end{requirement*}
%
In contrast to this scheme, the lightly synchronized implementation change,
allows \dt{client} visible co-existence of $A$ and $B$:
\begin{requirement*}{Lightly Synchronized Implementation Change}
  If the \dt{client} issues a lightly synchronized implementation change from
  \dt{entity type implementation} $A$ to $B$, $B$ must be \dt{message
  compatible} to $A$ and the corresponding converters need to be provided by
  the \dt{client}. Then each \dt{participating process} of the \dt{database
  support group} switches over from $A$ to $B$ at an efficient moment in the
  near future.\\ 
  \INTERFACE{\DBMI,\ETI}
\end{requirement*}
%
That is to say, each \dt{participating process} might choose a welcome
moment to do the switch, but it must be in the ``near future''. ``Near
future'' will be determined in other documents and can be heavily
implementation dependent. The above requirement implies that instances
which are managed by $A$ within one \dt{process} and by $B$ within
another \dt{process} can coexist. Thus the \dt{client}
self-responsible to utilize the corresponding \dt{entities} in a
sensible way.



\subsection{Allocation, Freeing and Cloning}


\begin{requirement*}{Allocation of Encapsulated States}
  It must be possible to allocate a new \dt{encapsulated states}
  with no arguments. The newly created \dt{encapsulated state} must be in a
  defined state.\\
  \INTERFACE{\DBAI,\ETI}
\end{requirement*}
%
We speak about allocation, since no parameters can be passed to the newly
created state. The overall creation-process of an \dt{entity's encapsulated
  state} will be embedded in broader interface which will be provided by the
\dt{client}. 
%
Corresponding to the allocation-operation, there is a \dt{free}-operation. This operation
should not be mixed up with the destruction of an \dt{encapsulated state} --
the former removes the \dt{encapsulated state} from the main-memory, the
latter removes it from the \dt{database}. 
\begin{requirement*}{Freeing of Encapsulated States}
  It must be possible to free an \dt{encapsulated state}, i.e., to remove it
  from the main-memory.\\
  There should be different levels of enforcement -- in the default case, it
  should only free the memory, if it is \dt{unbound}, if enforced, it should
  ignore \dt{bindings}.\\
  \INTERFACE{\ETI}
\end{requirement*}
Moreover, if an \dt{entity} becomes \dt{unanchored} and \dt{unbound}, it
should be automatically freed.
\begin{requirement*}{Automatic Freeing of Encapsulated States}
  If an \dt{encapsulated state} becomes \dt{unanchored} and \dt{unbound} it
  should free itself.\\
  \INTERFACE{\ETI}
\end{requirement*}

\begin{requirement*}{Encapsulated States are Clone-able}
  An \dt{encapsulated state} must be clone-able, i.e., it must be possible to
  generate a \dt{logically equivalent} copy of an original copy which is
  independent of the original one, i.e., it must be a deep-clone.\footnote{It
    might be copy-on-write clone, however, the implementation must work under
    multi-threaded conditions -- see requirement
    \vref{req:eti-thread-awareness}. Multi-threading usually makes classical
    copy-on-write data-structures such as strings ineffective.}\footnote{
  With the terms we have at hand, we can identify a difference of the
  original and the clone: The clone is always \dt{unbound} and
  \dt{unanchored}. However, information like the anchoring/binding
  state are internal to the \SYNEIGHT -- all state information
  which is observable by the \dt{client} must be identical.}\\
  \INTERFACE{\ETI}
\end{requirement*}


\subsection{Main-Memory Consumption}

The following requirements arise from the \SYNEIGHT's need to overview
the current memory consumption of \dt{entities}. 
%
\begin{requirement*}{Compression Option of Entity Type Implementations}
  An \dt{entity type implementation} must be able to report whether it can or
  cannot compress its \dt{encapsulated states}. Compressing of
  \dt{encapsulated states} means to remove any unused chunks of memory which
  might be reminiscent from former dynamic operations.\\
  \INTERFACE{\ETI}
\end{requirement*}
%
\begin{requirement*}{Reporting its Current Size}
  Each \dt{encapsulated state} must be able to report the overall size of its
  currently employed internal data-structures.
  This method must be quick, i.e., rely on precomputed data.\\
  \INTERFACE{\ETI}
\end{requirement*}
%
\begin{requirement*}{Report its Minimal Size, and Compressing}
  Each \dt{encapsulated state} must be able to report its minimal size, i.e.,
  the minimal size of a representation which is logically equivalent to its
  current contents. This method must be quick, i.e., rely on precomputed
  data.\\
  The \SYNEIGHT might issue a compression of the current state, which
  needs to represent the current state at most with the size reported by the
  above described method.\\
  If the \dt{entity type implementation} is unable to compress \dt{encapsulated}
  states, the minimal size must be equal to the current size.\\
  \INTERFACE{\ETI}
\end{requirement*}

\subsection{Serialization}

\begin{requirement*}{Serialization of Encapsulated States}
  Both forms of \dt{encapsulated states} must be serializable, and must be
  registered for that purpose within the general serialization
  framework\footnote{See subsection
    \vref{sec:introduction:used-interfaces:serialization}.}.\\
  In particular, it must be ensured, that the information contained in the
  serialized byte-stream is sufficient to reconstruct a \dt{logically
    equivalent} \dt{encapsulated state}. The \dt{entity type implementation}
  is not allowed to rely on any information which is not directly owned by the
  corresponding
  \dt{encapsulated state} or by the \dt{entity type implementation} itself.\\
  Specifically, if data is shared between \dt{encapsulated states}, it must be
  entirely contained within the serialized byte-stream.\\
  \INTERFACE{\ETI}
\end{requirement*}




\subsection{Binding}

\begin{requirement*}{Binding of Encapsulated States}
  There must be a mechanism which allows to \dt{bind} any \dt{encapsulated
  state} in a type-safe way to a \dt{client}-provided \dt{binder}. Type-safety
  has to be ensured by the \dt{entity type implementation} and the \dt{binder}
  cooperatively.\\
  \INTERFACE{\DBAI,\ETI}
\end{requirement*}
%
The \dt{client} must be able to release a \dt{binding} after usage, to
release its claim on the particular copy of the \dt{encapsulated state}.
\begin{requirement*}{Releasing a Binding of an Encapsulated State}
  There must be a mechanism to release a binding between a \dt{binder} and the
  corresponding  \dt{bound encapsulated state}.\\
  \INTERFACE{\DBAI,\ETI}
\end{requirement*}
%
Different contexts might require different binding conditions. For example, if
an \dt{encapsulated state} is not shared between different \dt{participating
  processes}, it might be advisable to drop update-generation. Thus the
binding mechanism will allow the \SYNEIGHT to give the \dt{encapsulated
  state implementation} hints about the surrounding context, which can be used
for optimization. 


\begin{requirement*}{Bound Count}
  The number of \dt{bindings} must be reported by the \dt{encapsulated state}
  at any time to the \SYNEIGHT.\\
  \INTERFACE{\ETI}
\end{requirement*}


\subsection{State Updating}

When an \dt{encapsulated state} is modified by the \dt{client} the changes
have to be distributed into the whole \dt{database's supporting group}. To do so,
each \dt{encapsulated state} is required to generate a corresponding
update-message. 

\begin{requirement*}{Encapsulated States Must Generate Updates}
  If an \dt{encapsulated state} becomes modified, it must be
  able to generate an update which describes the difference somehow. This
  message must be understood by an \dt{encapsulated state} which was logically
  equivalent to the sending \dt{encapsulated state} before the modification
  occurred.\\
  \INTERFACE{\ETI}
\end{requirement*}
%
The above requirement is quite weak, since it leaves it entirely to the
\dt{encapsulated state implementation} to provide a compact and efficient
update description. In the production system, efficient mechanisms will be
needed, however, these requirements are written intentionally in way which
makes this decision deferrable. 


\subsection{Message Passing}

The message passing of the \SYNEIGHT is based upon the \dt{message
  binders}. The \dt{client} sets up a \dt{message binder} by identifying the
corresponding \dt{entity} within its \dt{database} and by specifying the
\dt{entity's type}. The \dt{message binder} will allow the \dt{client} to use
a high-level interface to construct the message to be sent to the
corresponding \dt{entity}. After sending the message, the \dt{client} might
want to receive an answer or not.
%
The \SYNEIGHT must provide the means to make this possible -- worded in
the following requirements.

\begin{requirement*}{Setting up Message Binders}
  There must be a mechanism which allows to set up a \dt{message binder} which
  is addressing a fixed \dt{encapsulated/configuration state} by specifying its
  \dt{database}-wide identification and its \dt{entity-type}.
  There should be no network-traffic, as long as the message is not sent.\\
  \INTERFACE{\DBAI,\ETI}
\end{requirement*}

\begin{requirement*}{Message Passing}
  The \SYNEIGHT must be able to access the message constructed by the
  \dt{message binder} to deliver it the corresponding
  \dt{encapsulated/configuration state}. If the message requires an answer,
  \emph{and} the \dt{client} is waiting for it, the answer must be generated
  by the \dt{encapsulated/configuration state} and must
  be delivered back to the \dt{client}.\\
  \INTERFACE{\DBAI,\ETI}
\end{requirement*}


\subsection{Architecture Independence}

If an \dt{entity type implementation} announces that it is able to work
architecture independently, it has to able to generate all messages in a
machine independent form. 

\begin{samepage}\begin{requirement*}{Architecture Independence}
  An \dt{entity type implementation} which claims to be architecture
  independent has to be able to generate the following messages in an
  architecture independent way, \emph{if asked to do so}:
  \begin{itemize}
  \item update messages
  \item serialization
  \item messages arising from \dt{message binders}
  \end{itemize}
\end{requirement*}\end{samepage}



\subsection{Thread Awareness}


\begin{samepage}Whenever an \dt{encapsulated state} is entered, it is assured
that one of the following two conditions is met:
\begin{itemize}
\item the thread will employ both, read/write methods, and is working
  exclusively on the \dt{encapsulated state}\footnote{If the \dt{client} gains
    write access to the \dt{encapsulated state}, it is responsible for
    controlling the usage of the corresponding \dt{binder}. Thus if several
    threads are using the same \dt{binder}, the \dt{client} has the choice of
    providing an \dt{entity type implementation} which is thread-safe, or
    guaranteeing mutual exclusion of the \dt{binder}.}. The only exception are
  access governed by \dt{concurrent read locks} and \dt{concurrent write locks}\footnote{See
    definitions \vref{def:concurrent-read-lock} and
    \vref{def:concurrent-write-lock} respectively.} -- in these two access
  modes, the \dt{client} is responsible for providing sufficient mutual
  exclusion.
\item the thread will only employ read methods, but there might be other
  threads, which access the same \dt{encapsulated state} concurrently.
\end{itemize}\end{samepage}
We require that the \dt{entity type implementation} works properly under these
conditions: 
\begin{requirement*}{Thread Awareness of Entity Type Implementations}
  \label{req:eti-thread-awareness}
  Each \dt{entity type implementation} must work properly, if several threads
  access read-only methods of an \dt{encapsulated state} concurrently, or if
  one thread accesses read/write methods of an \dt{encapsulated state}
  exclusively.
\end{requirement*}
The reader might be tempted to assume that \dt{entity type implementations} do
not need any thread awareness, but this is only true, if they are properly
implemented:
\begin{remark*}{Thread Awareness relies on Conventions}
  If an \dt{entity type implementation} uses static variables in a method,
  read-only or not, it is thread-safe under the above conditions. While this
  example is pretty obvious, and static variables should be avoided by default
  in multi-threaded applications, there are cases where thread awareness is
  needed, not by bad implementation, but complex implementation
  strategies. For example, if an \dt{entity type implementation} has its own
  memory management, this memory management needs to be implemented in a
  thread-safe way.
\end{remark*}

\subsection{Coupling}


\begin{requirement*}{Completeness of the Entity Type Implementation}
  Each \dt{entity type implementation} must be complete, i.e., it must contain
  an implementation for the associated \dt{entity's encapsulated state} and
  the associated \dt{static encapsulated state} along with two corresponding
  factory methods.\\
  If an \dt{entity type implementation} should be able to replace another
  \dt{entity type implementation}, it must contain an associated \dt{migration
    system}.\\
  \INTERFACE{\ETI}
\end{requirement*}

\begin{requirement*}{Dynamic/Static Loading of Entity Type Implementations}
  It must be possible to load an \dt{entity type implementation} dynamically
  at run-time. This means that the \SYNEIGHT must offer suitable
  interfaces which allow the integration of dynamically loaded \dt{entity type
    implementations}.\\
  But the \SYNEIGHT should not be built upon the assumption that the
  \dt{entity type implementations} are always dynamically loaded.\\
  \INTERFACE{\PMI}
\end{requirement*}




\subsection{Configuration State}

While the contents of the \dt{configuration states} will be
discussed throughout the document, we formulate here some general requirements
about the way these states are represented and about the way these
representations are mapped to the \dt{client}-visible configuration
representations.

\begin{requirement*}{Entity Type Implementation knows nothing about Configurations}
  The \dt{entity type implementations} must be built in way which does not
  require any knowledge of the representation of \dt{configuration
    states}\footnote{The code of an \dt{entity type implementation} is allowed
    to access a \dt{configuration state} over the usual \dt{client}
    interface.}.\\
  \INTERFACE{\ETI}
\end{requirement*}
We do not specify the mechanics which map the \SYNEIGHT's internal view
of the \dt{configuration states} to the \dt{client}-accessible
structures, however, we require uniformity with respect to the
\dt{encapsulated states}.\\
%
Since the we already require the usage of the \dt{binder}-concept in the case
of \dt{encapsulated states}, this means that \dt{binders} will be used in this
case too. 
\begin{requirement*}{Uniform Representation: Binders}
  The \dt{configuration states} must be accessible to the
  client in a way which is uniform with respect to the representation of
  \dt{encapsulated states}, i.e., \dt{binders} must be used at the interface.\\
  \INTERFACE{\DBAI}
\end{requirement*}


\subsection{Call-backs to the Entity Type Implementation}

An \dt{entity type implementation} might need to be informed on several
state-changes of an \dt{entity}. The required call-backs are listed in this
subsection. 

When an \dt{entity} is destructed and removed from the \dt{database}, the
\SYNEIGHT will call a special destruct-method of the corresponding
\dt{encapsulated state}.
%
This method can be used to destruct other \dt{entities}, just as in an
ordinary destructor. 
\begin{requirement*}{Destruction}
  There must be a destruction call-back. The \SYNEIGHT is required to
  invoke this method before the \dt{entity} is destructed, and the \dt{entity
  type implementation} is required to all necessary clean up operations within
  this method. This method should be treated like an ordinary write method,
  i.e., it should generate an update (if the locking context requires an
  update).\\
  \INTERFACE{\ETI}
\end{requirement*}
%
But this method must be distinguished from the destructor of the
\dt{encapsulated state} which is called when the \dt{encapsulated state} is
removed from a \dt{participating process's} main-memory.

%%
%%
%%
%%
%%
%%The requirements presented in this sec
%%
%%\begin{requirement*}{The Client must adhere the Entity-State-Type}
%%  All ways to access an \dt{entity's} state must employ the
%%  \dt{entity-state-type} and must respect its associated protocol. Violations
%%  must lead to be caught by exceptions. 
%%\end{requirement*}
%%
%%\begin{rationale}
%%  This requirement is effectively decoupling the \dt{client} from the concrete
%%  representation of the \dt{entity's} state -- as worded in the responsibility
%%  \vref{resp:entity-state-representation}. 
%%\end{rationale}
%%
%%So far we do not know whether there will be one \dt{entity-state-type} or
%%whether there will be a set of different such types. We even do not know
%%whether such a set is dynamically extendible or not. 
%%
%%\begin{requirement*}{The Configuration-State must be Uniformly Represented}
%%  Each \dt{entity's configuration-state} must be represented to the
%%  \dt{client} in uniform way.
%%\end{requirement*}
%%
%%
%%We start with a list of questions to be resolved in this section.
%%
%%The entity state must be structured, and this structure must be abstracted to
%%the \dt{client}. The first question is whether there we require several
%%different entity-state-types or not. This requirement is fundamental, for the
%%following reasons:
%%\begin{itemize}
%%\item Having one entity-state-type allows to inline a lot of code -- which
%%  might lead to a performance gain. 
%%\item Having only one entity-state-type might require us to employ generalized
%%  methods we perform poorly in central use-cases. Thus it might be required to
%%  employ multiple entity-state-types. 
%%\end{itemize}
%%
%%\begin{question*}{Do we need more than one structure-type for entities?}
%%\end{question*}
%%
%%\begin{question*}{Replacing the representation-implementation: Statically vs. Dynamically?}
%%  
%%\end{question*}
%% 
%% 
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Entity State Access}
\label{sec:entity-state-access}

\section{Starting Point}

This chapter will describe all requirements which arise from 
responsibility \ref{resp:entity-state-access} ``Entity State Access'', which
was introduced on page \pageref{resp:entity-state-access}. Let us quote
the responsibility:
\begin{quote}
  \respentityaccess
\end{quote}
%
Thus this chapter will introduce the different locking semantics we are going
to provide and the transaction management which will allow the \dt{client} to
use these primitives effectively within its applications.\\
%
In particular, we will start with the definition of a transaction and augment
this definition in the course of the chapter with a list of commands which
have to be supported. 
%
The necessary calls will include a set of raw-locks and a set of
transactional-locks. 
%
The former give the \dt{client} direct and unrestrained access to an
\dt{entity's state} while 
%
the latter provide a controlled and more secure access (e.g., in the
case of a transaction abort, modifications are automatically
undone). 
%
Together, these locks allow the \dt{client} to settle an
application-specific trade-off between guarantees to be established by
the \SYNEIGHT and self-responsibility.\\
%
The transactional system itself is subdivided into a number of calls to
``acquire access to an entity'' and into a ``raw commitment control'' as well
as into a ``transactional commitment control''. While the way of acquiring
access is uniform for raw-locks and transactional-locks, the preferred way of
committing is different -- raw commitment control allows the \dt{client} to
control the underlying \dt{locks} directly, while the transactional commitment
control is meant for full transactional semantics along with sub-transactions
and atomic commitment. 
%
Again, the \dt{client} can choose its scope of responsibilities. Using
raw-locks and raw commitment control can lead to more efficient solutions, but
it is far more complex to develop applications based on these primitives. 

%%
%%Because of the distributed nature of the \SYNEIGHT, there will be
%%several copies of the same state, and usually, there will be several
%%different versions of the same state, which can even coexist within the same
%%\dt{participating process}. Thus we will introduce version numbers,
%%\dt{outdated entity's states} and \dt{accurate entity's states}.
%%
%%Using these terms, we will define the \SYNEIGHT's \dt{locks}, and the
%%rights they grant the owner on a state. In addition to raw \dt{locks} we will
%%also introduce a transactional model, which will allow the \dt{client} to
%%specify flexibly its required consistency guarantees. 
%%
%%To get access to a state, a \dt{lock} must be acquired and afterwards, a
%%\dt{binding}\footnote{See subsection
%%  \vref{sec:entity-state-representation:def:binding-and-anchoring}.} must be
%%established.
%%%
%%Since the \SYNEIGHT leaves all internal issues of an \dt{encapsulated
%%  state} representation to the corresponding \dt{entity type implementation},
%%each such implementation is self-responsible for setting up an
%%access-interface in each \dt{binder} which is proper to the acquired to rights.
%%%
%%We will give a proposed approach for structuring these interfaces.


\section{Definitions}


\subsection{Transaction}


%%First let us refined the definition of the \dt{database access interface}
%%(\DBAI). The original definition\footnote{See definition
%%  \vref{def:database-access-interface}.} was worded as follows:
%%\begin{quote}
%%\DBAIText
%%\end{quote}
The \dt{database access interface} (\DBAI)\footnote{See definition
  \vref{def:database-access-interface}.} allows the \dt{client} to instantiate
a \dt{transaction} to operate on a specified \dt{database}. The
\dt{transaction} checks all operations for their correctness (with respect to
concurrency control) and provides all means for accessing the \dt{encapsulated
  state} and the \dt{configuration state} of \dt{entities}. Thus the
\dt{transaction} covers the core functionality of the \DBAI.
\newcommand{\TRANSACTION}{{\normalfont\textsc{ti}}\xspace}
\begin{definition*}{Transaction}
  \label{def:transaction}
  A \dt{transaction} is instantiated for a particular \dt{database} and
  allows to access the individual \dt{entities' states}. It also provides all
  means for controlling the concurrency management of all operations
  which are issued on these \dt{entities}.
  %
  The \dt{transaction}-interface is called \TRANSACTION.\\
  \INTERFACE{\DBAI}
\end{definition*}

\begin{remark*}{Access Covering Several Databases}
  The above definition has an important consequence: It is impossible to set
  up a \dt{transaction} which accesses \dt{entities} which are distributed
  over several \dt{databases}.
  %
  Such a feature is not required at the moment being.
\end{remark*}


The \SYNEIGHT's \dt{transaction}-interface (\TRANSACTION) will give the
\dt{client} an uncontrolled and redundant set of primitives to develop complex
transaction-processing strategies.
%
In particular, the \TRANSACTION comes with \dt{raw locks} and \dt{raw
  commitment control} as well as with \dt{transactional locks} and
\dt{transactional commitment control}.\\
The raw primitives allow the \dt{client} to build his own transaction
processing strategies, but they the responsibility of using them in a
  correct way might be a burden for the \dt{client}-developer.\\
The transactional primitives give the \dt{client} a ready-to-use transaction
system.
%
Thus, the \SYNEIGHT will have to provide more specialized
transaction-classes which will provide a narrower interface.
%
%%The \dt{access monitor} allows to control the processing of each \dt{entity}
%%individually. Modifications executed under the control of an \dt{access
%%  monitor} have to committed at end to make them persistent and visible. The
%%\dt{client} has the option of an \dt{atomic commit}, i.e., all modification
%%which are grouped together in one \dt{atomic commit} are treated as one
%%logical unit -- specifically, either all modifications of an \dt{atomic
%%  commit} are executed or none.  In turn, the \dt{client} can utilize several
%%\dt{isolation-levels} to proscribe the \SYNEIGHT whether it wants to see
%%only modifications in atomic commit steps or not\footnote{See subsection
%%  \vref{sec:entity-access-isolation}.}.
%%%
%%\begin{definition*}{Atomic Commit and Transactions}
%%  An \dt{atomic commit} makes all modifications done to a group of
%%  \dt{entities} persistent within one atomic step. Either all modification are
%%  executed or not. We say that all read and write operations on such a group
%%  of \dt{entities} from a single \dt{transaction}.
%%\end{definition*}
%

%%The reader might ask what the difference between the \DBAI and the
%%\dt{transaction} interface is. The \DBAI allows to set up one or more
%%\dt{transactions} in parallel.

The access to \dt{entities} is controlled by locks. Each lock is
acquired through a \dt{transaction}. By acquiring a lock on an
\dt{entity}, the owner of the \dt{transaction} gains certain rights
and guarantees on this \dt{entity}. So we arrive at the following
definition.
\begin{definition*}{Lock-Owner}
  The \dt{lock-owner} of a lock is the owner of the \dt{transaction}
  which is used to gain the \dt{lock} in concern.
\end{definition*}


\subsection{Entity State Versions}

So far we were referring to an \dt{entity} without concerning the
issues which arise from the fact that an \dt{entity} will be
distributed over several \dt{participating processes}. At this point,
we have to consider the distributed character of \dt{entities} and
thus we have to replace this abstract perspective by a more detailed
one.
%
In particular, the \SYNEIGHT might maintain several different versions
of the state of the same \dt{entity} at the same time. Thus we assign to an
\dt{entity's state} a \dt{version number}. The \dt{entity id} and a
corresponding \dt{version number} will uniquely identify an \dt{entity's
  state}. The \dt{encapsulated state} and the \dt{configuration state} share
one \dt{version number}, therefore their development over time cannot be
subdivided, it is one integral evolution. 
\begin{definition*}{Entity State Version Number and Committed Entity State}
  The \dt{entity state version number} is an integer\footnote{We assume that
    integers are ideal, i.e., that they are unbounded. In other words, here we
    do not consider the problems which will arise from rollover or saturation
    arithmetics.}  which is set to 0 when the initial \dt{entity state} of an
  \dt{entity} is created.
  %
  Each new \dt{committed entity state} gets an incremented \dt{entity state
    version number}.
  %
  A \dt{committed entity state} is an \dt{entity state} which is made public
  and persistent by a specific commit command. 
\end{definition*}
%
In this definition we are referring to a \emph{commit command}. We will
discuss the process of committing a modified \dt{entity's state} later within
this chapter -- basically, when a modified state is committed into the
\dt{database} it is made persistent and accessible. In contrast, the
states of an \dt{entity} which are in-between two committed states, are called
\dt{intermediate entity states}.
%
\begin{definition*}{Intermediate Entity State}
  A modified \dt{entity state} which is not committed into the \dt{database}
  is called \dt{intermediate entity state}.
\end{definition*}
%
As we will see, \dt{intermediate entity states} are only visible to the
\dt{client} which causes them. There will be also a management for these
\dt{intermediate entity states} -- the rollback-management, which is presented
in the next subsection.

%
If there are different versions of the same \dt{entity} at the same time, then
there are \dt{accurate entities} and \dt{outdated entities}, which are defined
next. 
%
\begin{definition*}{Accurate/Outdated Entity State}
  An \dt{entity's state} which has the maximum version number within the set
  of all existing states of this \dt{entity} is called \dt{accurate entity
    state}. All other \dt{entity states} are \dt{outdated entity states}.
\end{definition*}
%
Now we are able to describe precisely what we were referring to, when we
talked about the ``entity's state'' -- it is just the \dt{accurate entity
  state}. 
%
\begin{remark*}{The Entity's State -- Revised}
  When we talked about the \dt{entity's state}, we implicitly talked about the
  \dt{entity's accurate state}. We will go on to the term \dt{entity's
  state}, with precisely the meaning which we identified at this point.  
\end{remark*}



\subsection{Rollbacks}
\label{sec:def:rollback}

The \SYNEIGHT has to provide means which allow a \dt{client} to undo its
intermediate modifications within an \dt{entity}, i.e., a way to manage
\dt{intermediate entity states}.

Thus the \SYNEIGHT allows a \dt{client} to define \dt{rollback-points}
on \dt{entities}. After defining such a \dt{rollback-point}, the \dt{client}
can issue a \dt{rollback} to this point, which has the effect of restoring the
\dt{entity's state} as it was at the time of the definition of the
\dt{rollback-point}. 
%
\dt{Rollback-points} can be defined on the last \dt{committed entity state} and
on all \dt{intermediate entity states} during a transaction which modifies an
\dt{entity}. 
%
\begin{definition*}{Rollback, rollback-point}
  Defining a \dt{rollback-point} on an \dt{entity} makes the current
  \dt{entity's intermediate state} recoverable in the future by issuing a
  \dt{rollback}.\\
  When a \dt{intermediate entity state} is committed, all \dt{rollback-points}
  are deleted. 
\end{definition*}


\subsection{Raw Locks}
\label{sec:esa:def:raw-locks}

\newcommand{\UNLOCKED}{{\normalfont\textsc{ul}}\xspace}
\newcommand{\CONCREAD}{{\normalfont\textsc{cr}}\xspace}
\newcommand{\CONCWRITE}{{\normalfont\textsc{cw}}\xspace}
\newcommand{\PROTREAD}{{\normalfont\textsc{pr}}\xspace}
\newcommand{\PROTWRITE}{{\normalfont\textsc{pw}}\xspace}
\newcommand{\EXCLUSIVE}{{\normalfont\textsc{ex}}\xspace}


In this subsections we will define all \dt{raw-locks} which are provided by the
\SYNEIGHT. The \dt{raw-locks} are directly managed by the \dt{client},
i.e., the \SYNEIGHT allows the \dt{client} to gain raw-access to
\dt{entities} by using these locks, however, the \dt{client} is also fully
responsible for maintaining these \dt{entities} in a valid state.


\begin{definition*}{Unlocked -- \UNLOCKED-lock}
  The lock \dt{unlocked} (\UNLOCKED-lock) gives the \dt{lock-owner} no special
  rights, i.e., these rights are given to everybody without explicit locking. 
\end{definition*}
%
We introduce the lock \dt{unlocked}, since there are certain
operations on \dt{entities} which are accessible even without having a
\dt{lock} on the respective \dt{entity}.

The following two locks allow the \dt{lock-owner} to continuously
watch the evolution of an \dt{entity} and to make some own changes within this
evolution. The underlying concept can be compared with a synchronized class,
or monitor class, which guards its methods by some mutual exclusion mechanism.
%
Another notion which describes the following two locks is short-term
locking: Each operation on an \dt{entity} which is controlled by 
such a lock is protected internally by a lock which is released
immediately upon the termination of the operation in concern. 
%
\begin{definition*}{Concurrent Read -- \CONCREAD-lock}
  \label{def:concurrent-read-lock}
  The lock \dt{concurrent read} (\CONCREAD-lock) gives the \dt{lock-owner} the right
  to access the possibly continuously changing associated \dt{entity}.\\ 
  %
  Thus two different accesses to the same value within the \dt{entity's
    state} might return two different values. 
  %
  The version(s) accessible to the \dt{lock-owner} might be \dt{outdated}, but
  not very old\footnote{The term ``not very old'' is to be determined
    and might be implementation dependent.}.  Moreover, actualization can be
  enforced manually, and will be done automatically in an
  implementation-dependent rhythm.
\end{definition*}
%
\begin{definition*}{Concurrent Write -- \CONCWRITE-lock} 
  \label{def:concurrent-write-lock}
  The lock \dt{concurrent write} (\CONCWRITE-lock) allows the \dt{lock-owner} to read from
  and write to the possibly continuously changing associated \dt{entity}.\\
  It is guaranteed that the version onto which the \dt{lock-owner} writes is
  \dt{accurate}, however, when the \dt{lock-owner} reads from the \dt{entity},
  the changes initiated by the \dt{lock-owner} itself might not be reflected. 
\end{definition*}

The next locks are the classical shared read and exclusive write locks.
They allow to base clean ACID-transactions upon pessimistic locking. Thus
might be preferable on high contention data -- at the same time they reduce
the potential of concurrency, especially if the accessed data has low
contention.
%
\begin{definition*}{Protected Read -- \PROTREAD-lock}
  The lock \dt{protected read} (\PROTREAD-lock) allows the \dt{lock-owner} to read
  from the \dt{entity's accurate state}. It is guaranteed, that the
  \dt{entity} is not altered as long as such a \dt{lock} is held by the
  \dt{lock-owner}. 
\end{definition*}
%
\begin{definition*}{Protected Write -- \PROTWRITE-lock}
  The lock  \dt{protected write} (\PROTWRITE-lock) allows the \dt{lock-owner} to read from
  and write to the \dt{entity's accurate state}. Every initiated change is
  immediately reflected in the altered \dt{entity's state}. 
\end{definition*}

The following lock is a ``just block everybody'' lock. It is not
useful in normal operation, but it might be necessary for some maintenance
operations.
\begin{definition*}{Exclusive -- \EXCLUSIVE-lock}
  The lock \dt{exclusive} (\EXCLUSIVE-lock) allows the \dt{lock-owner} to gain read
  and write access to an \dt{entity's accurate state} and to block any other
  access to this \dt{entity}. 
\end{definition*}

Throughout this document we will use the following abbreviations for these
locks: \UNLOCKED, \CONCREAD, \CONCWRITE, \PROTREAD, \PROTWRITE and
\EXCLUSIVE. These locks are also called \dt{raw-locks}, since
they give a \dt{lock-owner} uncontrolled access rights to an \dt{entity}.
\begin{definition*}{Raw-Lock: \UNLOCKED, \CONCREAD, \CONCWRITE, \PROTREAD, \PROTWRITE and
    \EXCLUSIVE}
  The locks  \UNLOCKED, \CONCREAD, \CONCWRITE, \PROTREAD, \PROTWRITE and
    \EXCLUSIVE are called \dt{raw-locks}. 
\end{definition*}


The following table, shows the compatibility of the different raw-locks. E.g.,
two different \dt{lock-owners} might have a \CONCREAD-lock and a
\PROTWRITE-lock on the same \dt{entity} (signified by a \textbullet). On the
other hand, if one \dt{lock-owner} holds a \PROTWRITE-lock on an \dt{entity}
no other \dt{lock-owner} can acquire a \CONCWRITE- or a \PROTREAD-lock.

\begin{center}\begin{tabular}{|l||c|c|c|c|c|c|} \hline
                   & \UNLOCKED   & \CONCREAD   & \CONCWRITE  & \PROTREAD   & \PROTWRITE  & \EXCLUSIVE  \\ \hhline{=#======}
  \UNLOCKED        & \textbullet &  \textbullet & \textbullet & \textbullet & \textbullet & \textbullet \\ \hline
%  \SNAPREAD        & \textbullet& \textbullet & \textbullet & \textbullet & \textbullet &             \\ \hline
  \CONCREAD        & \textbullet &  \textbullet & \textbullet & \textbullet & \textbullet &             \\ \hline
  \CONCWRITE       & \textbullet &  \textbullet & \textbullet &             &             &             \\ \hline
  \PROTREAD        & \textbullet &  \textbullet &             & \textbullet &             &             \\ \hline
  \PROTWRITE       & \textbullet &  \textbullet &             &             &             &             \\ \hline
  \EXCLUSIVE       & \textbullet &              &             &             &             &             \\ \hline
\end{tabular}\end{center}



\subsection{Isolation Levels and Inter-Entity Consistency}
\label{sec:entity-access-isolation}

The above defined raw-locks give the \dt{lock-owner} two very different
guarantees with respect to inter-\dt{entity} consistency. The concurrent locks
allow the \dt{lock-owner} to read and write concurrently, but there is no
guarantee that the information which is gained from two different
\dt{entities} is in any way consistent. After all, the concurrent locks employ
short-term locking. On the other hand, the protected locks and the exclusive
lock represent pessimistic and long-term locking, thus they ensure
serializability. 

\newcommand{\isoCOMMITTED}{{\normalfont\textsc{committed}}\xspace}
\newcommand{\isoMONOTONICITY}{{\normalfont\textsc{monotone}}\xspace}
\newcommand{\isoCONSISTENT}{{\normalfont\textsc{consistent}}\xspace}
\newcommand{\isoACCURATE}{{\normalfont\textsc{accurate}}\xspace}
\newcommand{\isoPESSIMISTIC}{{\normalfont\textsc{pessimistic}}\xspace}
\newcommand{\isoEXCLUSIVE}{{\normalfont\textsc{exclusive}}\xspace}

Since there are many levels in-between, we introduce isolation levels. 
Isolation-Levels are formulated in terms of a \dt{transaction} and
describe the isolation from the operations which are governed by other
\dt{transactions}. 
%
To use an isolation-level, an \dt{entity} has to be locked under a
transactional lock\footnote{Transactional Locks will be introduced in the next
  subsection.}.  However, each \dt{entity} can be locked under an individual
\dt{isolation-level}.
%
Now, we define six different isolation levels, which are briefly presented in
the following table:
\begin{center}
  \begin{tabular}{|l|p{80mm}|} \hline
    \isoCOMMITTED     & only committed entity states can be read \\ \hline
    \isoMONOTONICITY  & the view on the database is monotone, i.e.,
    once the modifications caused by one transaction are seen by the \dt{lock-owner}, all
    its modifications are visible to the \dt{lock-owner} \\ \hline
    \isoCONSISTENT    & the database view is consistent, i.e., the
    modifications of a transaction on interdependent \dt{entities} is seen
    either entirely or not \\ \hline
    \isoACCURATE      & the database view is accurate, i.e., upto-date\\ \hline
    \isoPESSIMISTIC   & the database view is accurate and locked\\ \hline
    \isoEXCLUSIVE     & the database view is accurate and exclusively locked\\ \hline
  \end{tabular}
\end{center}
%
The guarantees of the isolation-levels are ordered as shown in the above
table, i.e., the constraints of \isoCOMMITTED are a subset of all other
isolation-levels, and the constraints of \isoMONOTONICITY are a part of the
constraints of \isoCONSISTENT, \isoACCURATE etc.

We start with the lowest isolation-level, \isoCOMMITTED. Please note, that
\isoCOMMITTED does not restrict write access in any way. Thus, under
\isoCOMMITTED, it is \emph{not} guaranteed that the effect of other
transactions is either seen as a whole or not, as well as it is \emph{not}
guaranteed that no lost update problem occurs.
%
\begin{definition*}{Isolation-Level: \isoCOMMITTED}
  \isoCOMMITTED guarantees that only committed entity states are seen by a
  \dt{lock-owner}, i.e., the \dt{lock-owner} is unable to see intermediate
  states of \dt{entities} which are generated by other \dt{lock-owners} before
  they commit their modifications.
\end{definition*}
%

The next isolation-level adds the assurance, that once a \dt{lock-owner} sees
the effect of a \dt{transaction}, then in what follows, this effect is seen
everywhere. \isoMONOTONICITY does not restrict write-access in any way, thus
as in the case of \isoCOMMITTED, the lost-update problem can occur. 
%
\begin{definition*}{Isolation-Level: \isoMONOTONICITY}
  The isolation-level \isoMONOTONICITY guarantees a monotonic view of the
  development of the \dt{database}. The \SYNEIGHT guarantees, that once the
  effect of a \dt{transaction} is seen by the \dt{client} (in terms of a
  version of an \dt{entity} which incorporates changes which are caused by
  this \dt{transaction}) all \dt{entities} which are locked afterwards
  under \isoMONOTONICITY-isolation, will reflect all changes caused by this
  \dt{transaction}.
  %
  In other words, \dt{entities} which are locked under \isoMONOTONICITY,
  share this monotonic behavior.
\end{definition*}
%
\isoMONOTONICITY does not guarantee, that the effect of another
\dt{transaction} is treated in an atomic manner, since it is perfectly
possible, that a \dt{transaction's} modification of one \dt{entity} is
observed by the \dt{lock-owner} while other \dt{entities} which are also
altered by the same \dt{transaction} are seen in their original state.

\isoCONSISTENT allows the \dt{client} to enforce consistency between a group of
\dt{entities}, i.e., if a \dt{transaction} alters more than one \dt{entity} in
the group, then all modifications or none of modifications in this group must
be observed.
%
\begin{definition*}{Isolation-Level: \isoCONSISTENT and Consistency-Groups}
  \isoCONSISTENT is used to require consistent access to a group of
  \dt{entities}. Such a group is called \dt{consistency-group}. The guarantee
  is that a \dt{transaction} which affects members of a \dt{consistency-group}
  is reflected either in all states seen by the \dt{lock-owner} or in none.
  %
  Also, \dt{entities} which are modified under \isoCONSISTENT are not allowed
  to be modified by other transactions in the meantime. 
\end{definition*}
%
In the case of reading \dt{entities}, \isoCONSISTENT guarantees that
all those \dt{entities} are mutually consistent which are contained in
the same consistency-group.
%
In the case writing, \isoCONSISTENT enforces that no update is lost.
Thus it is ensured that all original \dt{entities states} which are
changed are accurate. 
%
Thus, \isoCONSISTENT does not allow full serialization.

The following isolation-level is even more restrictive, \isoACCURATE enforces
that all accessed data is \dt{accurate} and that all write operations are
fully serializable. Thus \isoACCURATE gives the \dt{client} the classical
ACID-guarantees.
%
\begin{definition*}{Isolation-Level: \isoACCURATE}
  All operations on an \dt{entity} which is accessed under \isoACCURATE must
  be fully serializable, i.e., all operations of a \dt{transaction}
  which are based upon an \isoACCURATE-lock must be placeable
  before or after any other \dt{transaction}.
\end{definition*}

There are two other isolation-levels, \isoPESSIMISTIC and
\isoEXCLUSIVE. These two levels allow full serialization, but the
\dt{client} enforces a pessimistic locking by employing them. The
other isolation-levels presented so far, might employ any concurrency
resolution, e.g., locking, timestamping, or optimistic
algorithms. Possible applications are high contention \dt{entities}.
%
\begin{definition*}{Isolation-Levels: \isoPESSIMISTIC and \isoEXCLUSIVE}
  Semantically, these two isolation-levels are the same as
  \isoACCURATE, i.e., they provide full serializability.
  %
  However, they employ direct locking to achieve this goal. \isoPESSIMISTIC
  uses the locks \PROTREAD and \PROTWRITE and \isoEXCLUSIVE uses \EXCLUSIVE.
\end{definition*}
%%
%%Let us summarize the different possible combinations of run-time and
%%commitment isolation-levels.
%%


\subsection{Transactional Locks}
\label{sec:esa:def:transactional-locks}

\newcommand{\TRANSREAD}{{\normalfont\textsc{tr}}\xspace}
\newcommand{\TRANSWRITE}{{\normalfont\textsc{tw}}\xspace}


Besides the \dt{raw-locks}, there will be two \dt{transactional-locks}
\dt{transactional read} (\TRANSREAD) and \dt{transactional write} (\TRANSWRITE).
%
From the \dt{client's} point of view, they have a similar effect as the
\dt{raw-locks}, but they give the \dt{client} a larger set of guarantees
than the \dt{raw-locks} -- for the price of a larger overhead. The additional
guarantees include the implicit setup of a \dt{rollback-point} when a
\dt{transactional lock} is acquired and a configurable degree of isolation
from other \dt{transactions} based upon the isolation-levels formulated
in the last subsection.

\begin{definition*}{Transactional Read and Transactional Write: \TRANSREAD, \TRANSWRITE}
  The lock \dt{transactional read} (\TRANSREAD) allows the \dt{lock-owner} to
  read from an \dt{entity} under full transactional control. Similarly, the
  lock \dt{transactional write} (\TRANSWRITE) allows the \dt{lock-owner} to
  read and write from an \dt{entity} under transaction semantics. Full
  transactional control means
  \begin{itemize}
  \item All operations can be undone, i.e., a \dt{rollback-point} is always
    defined when a \TRANSWRITE-lock is acquired.
  \item The isolation from other \dt{transactions} is
    configurable in terms of a run-time \dt{isolation level} and a
    \dt{commitment isolation-level}. 
    \begin{itemize}
    \item The run-time \dt{isolation-level} specifies the guarantees which
      have to be given during the access itself -- thus only guarantees on the
      inter-\dt{entity} consistency of read data has to be ensured.\\
      Therefore the \dt{client} can control the degree of isolation during the
      run-time of the transaction itself, and can write its own code based on
      inter-\dt{entity} consistency assumptions. 
    \item The commitment \dt{isolation-level} specifies the guarantees to be
      checked when the \dt{transaction} is committed. The commitment
      \dt{isolation-level} has be enforced at commit-time, i.e., all
      constraints on  read or write accesses are checked and the commit is
      only allowed to succeed if all conditions can be satisfied.  
    \end{itemize}
  \end{itemize}
\end{definition*}


\subsection{Direct Access and Messaging Access Locks}
\label{sec:esa:def:direct-and-remote-locks}

Any lock on an \dt{entity} supports either direct or messaging
access. If the lock supports direct access, then the \dt{entity} has
to be located within the same \dt{process} (if it is not located
within the same \dt{process}, the \SYNEIGHT has to provide this
\dt{process} with a new \dt{entity instance}) and can be bound with an
ordinary \dt{binder} or with \dt{message binder}\footnote{See
definition \vref{def:binder} and definition \vref{def:message-binder},
respectively.}.
%
Contrarily, if the lock is messaging, then the \dt{entity} might be
located only within some other \dt{process}. In this case, the
\dt{client} can only bind a \dt{message binder} \footnote{The
\SYNEIGHT might use a special \dt{message binder}, if the bound
\dt{entity} happens to be located within the same \dt{process} --
however, this is am implementation detail.}.

\begin{definition*}{Direct Access Lock}
  A \dt{lock} is a \dt{direct access lock}, if the associated
  \dt{process} has to contain an \dt{entity instance} which supports
  the \dt{entity} in concern.\\
  %
  If no such \dt{entity instance} exists when the \dt{lock} is
  acquired, then the \dt{process} has to gain such an instance.\\
  %
  A \dt{direct access lock} supports both, \dt{binders} and
  \dt{message binders}.
\end{definition*}

\begin{definition*}{Messaging Access Lock}
  A \dt{lock} is a \dt{messaging access lock}, if the associated
  \dt{process} may not contain an \dt{entity instance} which supports
  the \dt{entity} in concern.\\
  %
  A \dt{messaging access lock} supports only \dt{message binders}.
\end{definition*}


\subsection{Synchronization}

There a several different ways to synchronize access primitives, such as
\dt{synchronous invocation}, \dt{timed invocation} or \dt{asynchronous
  invocation}. We will define these three \dt{synchronization modes}.

\begin{definition*}{Synchronous Invocation}
  If a method is \dt{invoked synchronously}, the caller is blocked until the
  operation has been entirely completed or failed. 
\end{definition*}
%
\begin{definition*}{Invocation with Timeout}
  If a method is \dt{invoked with a timeout}, the caller is blocked until the
  operation has been entirely completed, or failed, or a time-out of pre-specified
  length elapsed. 
\end{definition*}
%
\begin{definition*}{Asynchronous Invocation}
  If a method is \dt{invoked asynchronously}, the caller is not blocked, i.e.,
  the control-flow returns immediately to the caller. To receive the results
  of the invocation and to check for its completeness, a so-called future or a
  similar technique has to be employed. 
\end{definition*}
%
To clarify the last definition, we also define the future design
pattern at this point.
%
\begin{definition*}{Future}
  A \dt{future} is an object which is used to control the completion
  of asynchronous method invocation. The future is passed as argument
  to the method which is invoked asynchronously and will allow the
  caller subsequently to check for completion or to wait for
  completion, as well as to read the optional results of the call. 
  %
  We further require that a number of calls can be booked onto one
  so-called completion port. All invocations which are booked onto the
  same completion port can be checked for completion and can be waited
  on. 
\end{definition*}


\subsection{Miscellaneous}

In this subsection we add a definition which is helpful for describing the
requirements in the next section. However, this definition is just grouping
some terminology. 

\begin{definition*}{Non-concurrent Write Locks}
  The \dt{locks} \PROTWRITE, \EXCLUSIVE and \TRANSWRITE are the
  \dt{non-concurrent write locks}.
\end{definition*}
%
A \dt{non-concurrent write lock} gives a \dt{lock-owner} the guarantee that
nobody else is \emph{modifying} the \dt{entity} -- it is perfectly possible that
somebody is reading from an \dt{outdated state} of this \dt{entity} in the
meantime.



\section{Requirements}


\subsection{Transaction Instantiation}

\begin{requirement*}{Arbitrary Number of Transactions in Parallel}
  It must be possible to maintain an arbitrary number of \dt{transactions}
  in parallel within a single \dt{participating process}.\\
  \INTERFACE{\DBAI}
\end{requirement*}

%%\begin{requirement*}{Multi-Threaded Access based upon a Single Transaction}
%%  The \SYNEIGHT is required to allow the \dt{client} to access a
%%  \dt{database} based upon the same \dt{transaction} within multiple
%%  threads.\\
%%  \INTERFACE{\DBAI}
%%\end{requirement*}
%%%
%%The above requirement has far-fetching consequences. In particular, the
%%\SYNEIGHT is responsible for keeping write-access mutually
%%exclusive. There are several means to provide this feature. Specifically, the
%%boundary between \dt{client}-responsibility and \SYNEIGHT-responsibility
%%is flexible. However, the common case must have good performance:
%%\begin{requirement*}{Single-Threaded Access must have no Performance-Penalty}
%%  The \SYNEIGHT must be optimized for single-threaded use of a
%%  \dt{transaction}.
%%\end{requirement*}
%%%
%%It is also conceivable to have multiple implementations of the
%%\dt{transaction}, one for single-threaded use and one for multi-threaded use
%%(or to employ policies).

For the sake of load-balancing, each \dt{transaction} must be assigned
to a \dt{balancing account}\footnote{See definition \vref{def:balancing-account}.}.
A \dt{balancing account} contains a set of \dt{entities} which are scheduled
by the load-balancing as a unit. Each \dt{transaction} is seen as caused by a
\dt{balancing account} -- this account is called the \dt{issuing balancing
  account}.
%
There will also be an anonymous balancing account, to be able to issue
\dt{transaction} which should have no consequence on the load-balancing
system.
\begin{requirement*}{Issuing Balancing Account}
  It must be possible to book a \dt{transaction} onto a given \dt{balancing
    account}. To do so, the \dt{transaction} will be instantiated
  \emph{for} a \dt{balancing account}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\subsection{Entity Versions}

\begin{requirement*}{The History of an Entity is Linear}
  An \dt{entity's id}, a \dt{database id} and an associated \dt{version
    number} identify uniquely a \dt{committed entity state}.
\end{requirement*}
%%%
%%The above statement is not entirely true: Later, in chapter
%%\vref{sec:database-access}, we will introduce \dt{database revisions}. The
%%\SYNEIGHT allows a \dt{client} to branch a \dt{database} into two
%%independent \dt{database revisions}. Each \dt{database revision} can be
%%accessed in isolation, and modified in isolation. This mechanism will be used
%%to generate backups. However, for the moment being, we look at a \dt{database}
%%as it would contain only a single \dt{revision}. 

\begin{requirement*}{The History knows only Committed State}
  There is no version of an \dt{entity} which is not committed. That is to
  say, that intermediate state are only visible during the modification
  generating these intermediate versions.
\end{requirement*}


%% \begin{requirement*}{Same Distribution Model for Static Entities}
%%   \dt{Static entities} are required to be accessible in the exactly the same
%%   way as ordinary \dt{entities}. Only the way of identifying a \dt{static
%%   entity} might differ.
%% \end{requirement*}


\subsection{Creation and Destruction}

\newcommand{\dbaiCREATE}{{\normalfont\textsc{create\_entity}}\xspace}
\newcommand{\dbaiDESTRCUT}{{\normalfont\textsc{destruct\_entity}}\xspace}
\begin{requirement*}{Creation of Entities: \dbaiCREATE}
  It must be possible to create new \dt{entities} within the \dt{database}. To
  create a new \dt{entity}, the required type has to be specified in terms of
  the corresponding \dt{entity type implementation}. The newly created
  \dt{entity} must be \dt{locked} under an
  \EXCLUSIVE-lock.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\begin{requirement*}{Destruction  of Entities: \dbaiDESTRCUT}
  It must be possible to destruct an \dt{entity} and remove it from the
  \dt{database}. To do so, a \dt{non-concurrent write lock} has to be acquired.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
The destruction of an \dt{entity} has to be committed such as any other write
access. Thus, it might fail in the case of a \TRANSWRITE-lock. 

\subsection{Rollbacks}

\begin{requirement*}{Availability of Rollbacks}
  \dt{Rollbacks} must be available on all \dt{entities} which are 
  \dt{non-concurrently write locked}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}


\begin{requirement*}{Recursive Rollback Management}
  The \SYNEIGHT is required to handle a stack of \dt{rollback points},
  i.e., an arbitrary number of \dt{rollback points} must be definable on the
  same \dt{entity}. Subsequently, it must be possible to jump back to any of
  these \dt{rollback points}. \\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
The last requirement forces the \SYNEIGHT to provide the two classical
stack operations, push and pop, as well as the rollback-command
itself. Beside these operations, there must be a way to gain status
information about the currently available \dt{rollback-points}. 

\newcommand{\dbaiPUSHROLLBACK}{{\normalfont\textsc{push\_rollback\_pt}}\xspace}
\newcommand{\dbaiPOPROLLBACK}{{\normalfont\textsc{pop\_rollback\_pt}}\xspace}
\newcommand{\dbaiROLLBACK}{{\normalfont\textsc{rollback}}\xspace}
\newcommand{\dbaiNETRECOVER}{{\normalfont\textsc{net\_recover}}\xspace}

\begin{requirement*}{Defining a Rollback-Point: \dbaiPUSHROLLBACK}
  Issuing the command \dbaiPUSHROLLBACK on an \dt{entity} causes the
  \SYNEIGHT to define a \dt{rollback-point} for this \dt{entity} on its
  current state. Also a handle for this rollback-point must be returned.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\begin{requirement*}{Removing a Rollback-Point: \dbaiPOPROLLBACK}
  Issuing the command \dbaiPOPROLLBACK on an \dt{entity} causes the
  \SYNEIGHT to remove the last \dt{rollback-point} of this \dt{entity}
  without rolling back. Alternatively, the \dt{client} can pop a
  \dt{rollback-point} by providing its handle (and all later defined
  \dt{rollback-points}).\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\begin{requirement*}{Rollback : \dbaiROLLBACK}
  Issuing the command \dbaiROLLBACK on an \dt{entity} causes the
  \SYNEIGHT to recover the \dt{entity's state} as it is defined by the
  last \dt{rollback-point}. Alternatively, the \dt{client} can provide a
  \dt{rollback-point's} handle to roll back to this particular
  \dt{rollback-point}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\begin{requirement*}{Rollback Status information}
  The \SYNEIGHT is required to provide means for getting information
  about the current stack of \dt{rollback-points}. In particular, there should
  be the possibility to read the number of currently defined
  \dt{rollback-points}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

Finally, the \SYNEIGHT should allow the \dt{client} to utilize the fact
that an \dt{entity} is replicated over several \dt{participating
  processes}. Thus there should be a primitive to recover the last committed
version of an \dt{entity} from another \dt{participating process}. 
%
In other words, if a \dt{process} is unable to reconstruct a
consistent version of an \dt{entity}, it should be able to ask its
peers for the latest consistent and available version of this \dt{entity}.
%
\begin{requirement*}{Recovering the last committed state: \dbaiNETRECOVER}
  The \SYNEIGHT is required to provide means for recovering the last
  committed version of an \dt{entity} from another \dt{participating process}
  if such a replicated version exists.
  %
  The \SYNEIGHT must also provide the means to
  probe for this possibility.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}


\subsection{Acquiring Access to Entities}

\newcommand{\dbaiACQUIRE}{{\normalfont\textsc{acquire}}\xspace}
\newcommand{\dbaiBINDENC}{{\normalfont\textsc{bind\_enc}}\xspace}
\newcommand{\dbaiBINDCFG}{{\normalfont\textsc{bind\_cfg}}\xspace}

\newcommand{\dbaiACCRETAIN}{{\normalfont\textsc{retain}}\xspace}
\newcommand{\dbaiACCRENEWC}{{\normalfont\textsc{renew\_constrained}}\xspace}
\newcommand{\dbaiACCRENEWUC}{{\normalfont\textsc{renew\_unconstrained}}\xspace}
\newcommand{\dbaiACCPOSSSIBLY}{{\normalfont\textsc{possibly\_new}}\xspace}

The following three commands allow a \dt{client} to gain access to 
\dt{entities}. These commands allow to \dt{lock} an \dt{entity}
(\dbaiACQUIRE), and subsequently, to \dt{bind} the \dt{entity's encapsulated}
and {configuration state} (\dbaiBINDENC and \dbaiBINDCFG).  

The command \dbaiACQUIRE is used to acquire a lock. There are four
parameters to be specified when the \dt{client} issues such a
call. First, there is the set of \dt{entities} to be locked. If this
set contains more than one \dt{entity}, the \SYNEIGHT acquires
the locks one these \dt{entities} in an atomic manner. This feature
can be used to implement a simple concurrency control scheme which is
based upon raw-locks.\\
%
The next parameters is the type of lock to be acquired. We already
defined all different lock-types\footnote{See subsections
\vref{sec:esa:def:raw-locks} and
\vref{sec:esa:def:transactional-locks}.} to be provided by the
\SYNEIGHT.\\
%
The third parameter is the accuracy. When the \dt{client} locks an
\dt{entity} more than once, the \SYNEIGHT might come into the
situation that it could fulfill the request, but not without providing
a version of the \dt{entity} which is newer than the one already
locked by the \dt{transaction}. The accuracy parameter allows the
\dt{client} to control the corresponding behavior of the
\SYNEIGHT. There are four possible values for the accuracy:
\begin{itemize}
\item \dbaiACCRETAIN: If the \dt{transaction} has already a lock the
corresponding \dt{entity}, it must use the same version of the
\dt{entity} for the new \dt{lock}. If this is not possible, the
\dbaiACQUIRE-call fails. 
\item \dbaiACCRENEWC: The \dt{client} explicitly requires the
\SYNEIGHT to utilize the newest available version of the
\dt{entity} which satisfies the constraints which are imposed by the
lock-type. Thus if the transaction already holds a lock on the
\dt{entity} but there is newer version of the \dt{entity} which
satisfies the lock-type's constraints, the newer version is taken. 
\item \dbaiACCRENEWUC: The \dt{client} explicitly requires the
\SYNEIGHT to utilize the newest available version of the
\dt{entity}. If the lock-type imposes constraints which cannot be
satisfied by the newest version of the \dt{entity}, the call will
fail. 
\item \dbaiACCPOSSSIBLY: The \dt{client} does not constrain the choice
of the version. Thus the \SYNEIGHT can choose whatever version
it wants. 
\end{itemize}
Finally, the fourth parameter determines whether the lock has to
ensure direct access or messaging access\footnote{See subsection
\vref{sec:esa:def:remote-and-direct-access}.}. If direct access is
enforced, naturally the \dt{entity} must be co-located. If the
\dt{entity} is not locked for direct access, it might be located
within the local process or within another process. However, only the
message-passing interface of the \dt{entity} is
accessible\footnote{More precisely, only a \dt{message binder} is
allowed to be bound to the \dt{entity}. See definition
\vref{def:message-binder}.}.

\begin{requirement*}{Acquiring a Lock: \dbaiACQUIRE}
  The \dbaiACQUIRE-command allows a \dt{client} to gain a \dt{lock} on a
  specified \dt{entity} or on a set of \dt{entities}. It is possible to gain
  any defined lock-type with this primitive.
  The arguments of \dbaiACQUIRE have to specify 
  \begin{itemize}
  \item the set of \dt{entities} to be locked
  \item the type of lock
  \item the required accuracy 
  \item whether direct access is required or not
  \end{itemize}
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
\dbaiACQUIRE is the only way to get a \dt{lock} on an \dt{entity} -- thus
every access to an \dt{entity} must be preceded by a \dbaiACQUIRE-command on
the corresponding \dt{entity}. 
%
Once a \dt{lock} is acquired, the \dt{entity} has to be bound to a
corresponding \dt{binder}. Depending on whether the access is aimed at
the \dt{encapsulated state} or at the \dt{configuration state}, the \dbaiBINDENC-
or the \dbaiBINDCFG-command has to be used.
%
The set of \dt{binders} which can be used for a certain \dt{entity} depend on
the type of the locks which were previously acquired for the \dt{entity} in
concern. 
%

\begin{requirement*}{Binding: \dbaiBINDENC and \dbaiBINDCFG}
  The \dbaiBINDENC- and \dbaiBINDCFG-command allow the \dt{client} to bind the
  \dt{encapsulated state} and the \dt{configuration state} to a \dt{binder}
  once a corresponding \dt{lock} has been acquired.
  The arguments of \dbaiBINDENC and \dbaiBINDCFG must define
  \begin{itemize}
  \item the \dt{entity} to be bound
  \item the \dt{binder} to be used for the \dt{binding}
  \end{itemize}
  The \dt{binder} has to be a \dt{message-binder} if the underlying \dt{lock}
  is only supporting messaging, or if it is a \UNLOCKED-, \CONCREAD-, or
  \CONCWRITE-lock.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\subsection{Raw Commitment Control}

\newcommand{\dbaiVALIDATE}{{\normalfont\textsc{validate}}\xspace}
\newcommand{\dbaiCOMMIT}{{\normalfont\textsc{commit}}\xspace}
\newcommand{\dbaiRELEASE}{{\normalfont\textsc{release}}\xspace}

After acquiring a \dt{lock} on an \dt{entity}, establishing a \dt{binding} on
the \dt{entity}, and accessing\footnote{Read-only access has to be
  committed as well, since it is possible that the read-data was invalid.}
this \dt{entity}, the access has to be committed into the \SYNEIGHT.
%
This is true for write \emph{as well as for read} accesses, since
\TRANSREAD-locks might need a posteriori validation\footnote{For
example, if the \dt{client} acquired a \TRANSREAD-lock with
\isoACCURATE-isolation, the \SYNEIGHT might give the \dt{client}
access to a locally available version of the corresponding \dt{entity}
and check the accuracy of this version during commitment.}. In the case of raw-locks,
no commitment is needed, since all accesses based on raw-locks are
directly aimed at accurate\footnote{An access based on a  \CONCREAD-locked \dt{entity}
might be not be accurate -- a corresponding binding follows the
accurate copy, i.e., whenever a new version of the locked \dt{entity}
becomes available, the binding is ``patched'' to this new version.}
versions, and are directly writing on them -- without buffering. 
%
The \SYNEIGHT has to provide two different sets of primitives to control
the commitment of operations. The first one, called raw commitment control,
described in this subsection, allows the \dt{client} to control the commitment
directly on a per-\dt{entity}-basis. 
%
The raw commitment control comes with the three following primitives. 

\begin{requirement*}{Validating Operations on Entities: \dbaiVALIDATE}
  \dbaiVALIDATE takes a set of \dt{entities} and checks that all operations
  which occurred so far on these \dt{entities} can be committed. Once,
  validation succeeds, the \SYNEIGHT guarantees that all validated
  operations can be committed in the future. More precisely, all future
  operations on these \dt{entities} which do not require a change in the
  locking-status are guaranteed to be successfully validated.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
Please note, that if operations on validated \dt{entities} depend on
information which is read from other \dt{entities}, the overall
validation might be incorrect from the application's point of
view\footnote{The \SYNEIGHT will allow the \dt{client} to
commit, however on the logical level, such a commit is still
invalid. It is the \dt{client} who is responsible for deciding whether
such a commit is acceptable to its own consistency constraints or
not.}. Thus the \dt{client} is responsible to select a sensible set of
\dt{entities} for validation. The same is true for the next command,
\dbaiCOMMIT.
%
\begin{requirement*}{Committing Operations on Entities: \dbaiCOMMIT}
  \dbaiCOMMIT takes a set of \dt{entities} and makes all modifications which
  were done on these \dt{entities} persistent atomically, if all \dt{entities}
  can be validated. Otherwise the call fails and has no effects. A \dbaiCOMMIT
  kills all \dt{rollback-points} on the corresponding \dt{entities}.
  %
  \dbaiCOMMIT allows to the \dt{client} to enforce immediate storage of the
  changes onto stable storage.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
Commitment is only needed for transactional-locks. Since all
raw-locks allow the immediate modification of to the corresponding \dt{entity}.\\
%
When the access to an \dt{entity} is no more necessary, the \dt{lock} can
be released. If a \dt{lock} is released, without committing beforehand, then
all changes which still needed commitment, are lost. After releasing a
\dt{lock}, all bindings to the \dt{entity} in concern are invalid. To
re-access the \dt{entity}, a new \dt{lock} has to be acquired. 

\begin{requirement*}{Releasing Locks on Entities: \dbaiRELEASE}
  \dbaiRELEASE releases the \dt{lock} held on a set of \dt{entities}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\subsection{Transactional Commitment Control}

\newcommand{\dbaiTRNEST}{{\normalfont\textsc{tr\_nest}}\xspace}
\newcommand{\dbaiTRSPLIT}{{\normalfont\textsc{tr\_split}}\xspace}
\newcommand{\dbaiTRVALIDATE}{{\normalfont\textsc{tr\_validate}}\xspace}
\newcommand{\dbaiTRCOMMIT}{{\normalfont\textsc{tr\_commit}}\xspace}
\newcommand{\dbaiTRABORT}{{\normalfont\textsc{tr\_abort}}\xspace}
\newcommand{\dbaiTRCLOSE}{{\normalfont\textsc{tr\_close}}\xspace}


Besides the raw commitment control, the \SYNEIGHT has to provide a more
advanced commitment control. The primitives of the transactional commitment
control have no influence on \dt{raw-locks} -- they are only meant for dealing
with \dt{transactional locks}.\\
The two basic concepts, which underly transactional commitment control, are
\begin{itemize}
\item the subdivision of a \dt{transaction} into several sub-transactions.
  There are two ways to achieve this subdivision: \emph{Nesting} (\dbaiTRNEST)
  and \emph{splitting} (\dbaiTRSPLIT).
\item the atomic validation (\dbaiTRVALIDATE), commitment (\dbaiTRCOMMIT) and
  aborting (\dbaiTRABORT) of (sub-)transactions. Alternatively to
  \dbaiTRCOMMIT or \dbaiTRABORT, a sub-transaction can be closed (\dbaiTRCLOSE).
\end{itemize}
%
The \dt{client} can subdivide the \dt{transaction} into meaningful blocks and
validate and commit them as a whole, or aborted them if necessary.
%
We start with the two commands which are provided for subdividing a
\dt{transaction} into sub-transactions.

\begin{requirement*}{Nested Transactions: \dbaiTRNEST}
  \dbaiTRNEST opens a sub-transaction within the current one. All operations
  within this newly opened sub-transaction can be validated, committed,
  and aborted as a unit. Nesting must be supported in a recursive manner.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
There is one important characteristic of nesting: A (sub-)transaction
has at most one open nested transaction at the same moment in time,
thus nested transactions form a stack. Therefore it is only possible to open one
nested transaction after the other at the same level, just as it is
only possible to execute one procedure call after the other within the
same procedure.
%
Another way to visualize nested transactions is the block-oriented programming
paradigm. Each block (transaction) can contain other sub-blocks
(sub-transactions) recursively, each sub-block (sub-transaction) can
access the data (acquired locks and bindings) which is declared in the other
scopes. Also, the program can only be in one block (sub-transaction) at the
same time.

In contrast, splitting allows to setup several sub-transactions within a
transaction at the same time. This mechanism is meant to support the
multi-threaded processing of a \dt{transaction}. 
%
\begin{requirement*}{Splitting Transactions: \dbaiTRSPLIT}
  \dbaiTRSPLIT opens a set of sub-transaction within the current one. 
  Once these sub-transactions are opened, the \dt{client} can use
  these transactions independently and concurrently, i.e., the \dt{client}
  can acquire new locks and issue commitment commands (such as
  validation, commit, or abort) on these sub-transactions. All these
  operations can happen in different threads. 
  %
  The only interdependence between these sub-transactions is given by
  the parent transaction. Each sub-transaction can access all
  \dt{entities} which are locked by the parent transaction, too.\\
  %
  Splitting must be supported in a recursive manner.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
There are some questions to be resolved with respect to split
transactions. Especially, it has to be clarified how a sub-transaction which
runs concurrently with other sub-transactions can access the locks and
bindings of outer transactions. There has to be a concurrency management in
its own. 


So we can start sub-transactions. Now we have to finish them. To finish a
sub-transaction and a root-transaction itself, there is one primitive,
for validation (\dbaiTRVALIDATE), and three primitives to finish a
(sub-)transaction, the next two for commitment (\dbaiTRCOMMIT) and aborting
(\dbaiTRABORT). Finally, there is a command for closing (\dbaiTRCLOSE) to
merge a sub-transaction with its surrounding transaction.
%
\begin{requirement*}{Validation of Transactions: \dbaiTRVALIDATE}
  \dbaiTRVALIDATE checks whether all operations within a (sub-)transaction can
  be committed. Once validation succeeds, the \SYNEIGHT has to
  guarantee that every modification which is validated will be
  committable. More precisely, if the locking status of the \dt{entities}
  within the (sub-)transaction in concern does not change, the \SYNEIGHT
  is required to commit these (sub-)transaction successfully.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
A successful \dbaiTRVALIDATE-call is the precondition for a successful
\dbaiTRCOMMIT. In fact, validation is defined as an a-priori check for
commitment. However, \dbaiTRCOMMIT does its own validation, if necessary, and
makes, all changes persistent, if the validation is successful.
%
\begin{requirement*}{Commitment of Transactions: \dbaiTRCOMMIT}
  \dbaiTRCOMMIT makes the changes of a root-transaction persistent. 
  %
  The call succeeds if the (sub-)transaction can be validated, otherwise the
  call fails and is guaranteed to have no effect.
  %
  If a sub-transaction is committed, the sub-transaction is only validated.
  It will be committed, if the surrounding (sub-)transaction is committed.
  %
  \dbaiTRCOMMIT kills all rollback-points which were defined within the scope
  of the committed (sub-)transaction. 
  %
  \dbaiTRCOMMIT allows the \dt{client} to enforce immediate storage of the
  changes onto stable storage.\\
  %
  If the transaction has been a root-transaction, all transactional locks are
  released. If the transaction was not a root-transaction, no locks
  are released by \dbaiTRCOMMIT.
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
The opposite call to \dbaiTRCOMMIT is \dbaiTRABORT which discards all
changes. It is particularly useful in the context of sub-transactions. If it
was not possible to gain a certain lock, it is possible to abort and to
retry. 
%
\begin{requirement*}{Aborting of Transactions: \dbaiTRABORT}
  \dbaiTRABORT makes all actions of a (sub-transaction) undone, i.e.,
  all changes to \dt{entities} are discarded (thus all rollback-points
  are discarded as well) and all transactional locks which were
  acquired within the aborted (sub-)transaction are released. If the
  transaction has been a root transaction, \dbaiTRABORT releases all
  transactional locks.\footnote{Note the difference to \dbaiTRCOMMIT\ 
  -- \dbaiTRCOMMIT releases transactional locks only if the
  transaction has been a root-transaction while \dbaiTRABORT releases
  all transactional locks unconditionally.}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
Finally, \dbaiTRCLOSE allows the \dt{client} to merge a sub-transaction into
its surrounding transaction. This is useful, if the \dt{client} wants to avoid
the validation, which might require slow remote checks, without aborting the
sub-transaction. The validation is postponed to be done along with the validation
of the surrounding transaction.
%
\begin{requirement*}{Closing of Transactions: \dbaiTRCLOSE}
  \dbaiTRCLOSE allows a \dt{client} to merge a sub-transaction with the
  surrounding transaction without committing or aborting, i.e., this decision
  is deferred to the surrounding transaction. Consequently, all
  transactional locks are retained and transfered to the surrounding
  transaction.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}


\subsection{Mixing Raw/Transactional Locks/Commitment Control}

The co-existence of raw and transactional locks and the co-existence of
raw and transactional commitment control rise the question of their
mutual influence. We do not want to be specific about these issues
since we regard these questions as an architectural issue. However, we
require that it must be possible to intermix these different
strategies on a very fine-grained level.

\begin{requirement*}{Mixing Different Lock Types}
  It must be possible to intermix all defined lock-types within the
  same transaction. In all cases, if an \dt{entity} is only locked
  under once (therefore, it is only locked with a single lock type),
  the lock succeed (under the assumption that no other transaction
  holds a lock on this \dt{entity}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
Next, we require that a \dt{transaction} which has two or more
different \dt{locks} on the \dt{entity} must have the guarantees of
all these locks.
%
\begin{requirement*}{Locking Guarantees Add Up}
  If a \dt{transaction} holds more than one \dt{lock} simultaneously
  on the same \dt{entity}, the \SYNEIGHT must ensure all the
  guarantees which are associated with these locks.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
While these two statements are fairly straight forward, we do not
specify at which different lock types can be acquired at the same
time by the same \dt{transaction}. 
%
\begin{question*}{Which Lock-Types are Compatible within the same Transaction}
  There might be some restrictions between raw and transactional
  locks -- it might be impossible to hold a raw lock and a
  transactional lock at the same time. On the other hand, it might be
  possible to hold several transactional locks with different
  isolation-levels on the same entity.
  %
  However, the precise compatibility specification is still left
  open.\\
  \INTERFACE{\TRANSACTION}
\end{question*}

Now we turn our attention to mixing of commitment control. Since
raw locks are only affected by raw commitment control, the only open
question with respect to this issue is how we are going to treat
transactional locks. \dt{Transactional locks} can be manipulated by
\dt{raw commitment control} as well as by \dt{transactional commitment
control}. The rising question is, how we are going to assign the
responsibility between the raw and transactional commitment control.
%
\begin{requirement*}{Mixing Raw/Transactional Commitment Control}
   It must be possible to utilize raw and transactional commitment
   control within the same \dt{transaction}.\\
   \INTERFACE{\TRANSACTION}
\end{requirement*}
%
\begin{question*}{Which Commitment Control has to control
   Transactional Locks}
  During a \dt{transaction}, a \dt{transactional lock} might be
  validated, released or committed by utilizing the raw commitment
  control primitives. The question is, which of these operations we
  are going to allow, and how we treat cases such as a
  \dt{transactional lock} which has been committed manually, but whose
  transaction is aborted. Precise semantics are to be defined.\\
  \INTERFACE{\TRANSACTION}
\end{question*}



\subsection{Status Information}


A \dt{client} must be able to gain general status information from a
\dt{transaction}. We do not specify all required audit-methods, but require
only a general audibility (what the \dt{client} can alter within a
\dt{transaction} must be readable) and more specific audit-methods which serve
purposes which are different from the requirements formulated so far.

\begin{requirement*}{General Audibility}
  It must be possible for the \dt{client} to gain full status-information of a
  \dt{transaction}, i.e., whatever the \dt{client} can configure or modify
  within a \dt{transaction} must be readable.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

\newcommand{\dbaiTRLVALIDATE}{{\normalfont\textsc{tr\_validate\_locally}}\xspace}
\newcommand{\dbaiLVALIDATE}{{\normalfont\textsc{validate\_locally}}\xspace}
Also, we require the \SYNEIGHT to provide local validation in the
context of the raw commitment control and in the context of the transactional
commitment control. These calls must issue a local check for validation, i.e.,
instead of a full validation, a quick check should be done which indicates
whether the validation will go through or not.
%
\begin{requirement*}{Early Invalidation of Entities: \dbaiLVALIDATE}
  There must be a method to check for early invalidation of the \dt{entities}.
  Early invalidation means the detection of effectively checkable conditions
  which invalidate the current status of an accessed \dt{entity}. If
  \dbaiLVALIDATE fails, \dbaiVALIDATE has to fail, too. If
  \dbaiLVALIDATE succeeds, \dbaiVALIDATE might succeed or not.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
\begin{requirement*}{Early Invalidation of Entities: \dbaiTRLVALIDATE}
  There must be a method to check for early invalidation of the current
  (sub-)transaction. Early invalidation means the detection of effectively
  checkable conditions which make the current (sub-)transaction invalid. If
  \dbaiTRLVALIDATE fails, \dbaiTRVALIDATE has to fail, too. If
  \dbaiTRLVALIDATE succeeds, \dbaiTRVALIDATE might succeed or not.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}



\subsection{Synchronization}

First we require that every method in the \DBAI and
\TRANSACTION\footnote{See definition
\vref{def:database-access-interface} and definition
\vref{def:transaction}, respectively.} are invokable in all three
synchronization modes.
%
\begin{requirement*}{Synchronization-Modes of \DBAI- and \TRANSACTION-Methods}
  All methods of the \DBAI and \TRANSACTION which might contain a context
  switch must be executable in all three synchronization-modes, i.e., in
  \dt{synchronous},
  \dt{asynchronous} and \dt{timed} mode.\\
  \INTERFACE{\TRANSACTION,\DBAI}
\end{requirement*}

Besides this requirement on the two interfaces which were discussed in
this chapter (\TRANSACTION and \DBAI), we add three general
requirements on the asynchronous invocation management, which are
required to be fulfilled by all interfaces which provide asynchronous
method invocations.
%
\begin{requirement*}{Completion Control for Asynchronous Invocations}
  All \dt{asynchronous invocations} must be controllable for completion over a
  uniform interface, for example by booking each invocation on a future.
\end{requirement*}
%
Moreover, we require that there is a management for groups of calls, i.e., 
there must be means to handle large groups of asynchronous calls and there
must be an efficient way to check for the completion of one logical group of
calls. 
%
\begin{requirement*}{Grouping Asynchronous Invocations}
  It must be possible to book an arbitrary number of calls onto the same
  future. Moreover, it must be possible to group these calls into requests,
  and it must be possible to wait for the completion of all calls which are
  grouped together into one request.
\end{requirement*}
%
\begin{requirement*}{Completion Check: Synchronously or with Timeout}
  The check for completion itself must allow both, \dt{synchronous invocation}
  and \dt{invocation with timeout}.
\end{requirement*}


\subsection{Stale Locks and Unfinished Transactions}

We introduce transaction time-outs which are used to identify \dt{transactions}
which failed. In addition, a the occurrence of a transaction time-out is
considered to be a critical event, which is indicating a failure of the
\dt{process} (or the responsible thread) which issued the \dt{transaction}.\\
%
This mechanism is also covering all locks on \dt{entities} since they are
always issued in terms of a transaction. 
%
\begin{requirement*}{Transactions Time-Outs}
  Every \dt{transaction} must have a time-out. If the time-out of a
  \dt{transaction} is reached, all its \dt{locks} are unilaterally dropped and
  the \dt{transaction} is aborted. Moreover, the \SYNEIGHT is required
  to report this failure to lower levels of the reliability.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}
%
Please note that the time-out is the last resort for the \SYNEIGHT.
Thus, if a transaction time-out is reached, the \SYNEIGHT might have to
issue very inefficient operations for recovery. Also, the \SYNEIGHT has
to report this problem. Therefore, time-outs should be overestimated.
%
Sometimes, it is very hard to estimate how long a transaction might take. To
cope with this problem, a \dt{client} is allowed to expand a \dt{transaction
  time-out}. To handle endless-loops, each \dt{transaction} is required to
have a maximum time-out, which can not be altered during the running
transaction. Therefore, a \dt{client} can start a \dt{transaction} with a
short time-out but a long maximum time-out. If the \dt{client} encounters a
lot of data to be processed, it can expand the \dt{time-out}, but the
expansion will fail if it exceeds the fixed maximum time-out. 
%
\begin{requirement*}{Maximum Time-Outs and Expansion of Time-Outs}
  A \dt{client} must be able to expand the \dt{time-out} of any
  \dt{transaction} during the run-time of these \dt{transactions}. However,
  every \dt{transaction} has a maximum time-out. The \dt{client} is unable to
  modify the \dt{maximum time-out} and is unable to expand a \dt{transaction's
  time-out} beyond the \dt{maximum time-out}.\\
  \INTERFACE{\TRANSACTION}
\end{requirement*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Database Management}
\label{sec:database-access}

\section{Starting Point}

This chapter covers the requirements which arise from the responsibility
\vref{resp:database-access} which was formulated as follows:
\begin{quote}
  \respdatabaseaccess
\end{quote}

The central definition of this chapter is the \dt{revision}. A
\dt{revision} is a collection \dt{entities} with a
\dt{entity-database}. Each \dt{database} can contain an arbitrary
number of \dt{revisions}, where each \dt{revision} can has its own set of
\dt{entities}. We have to distinguish \dt{revisions} which are not
dependent on other \dt{revisions} and \dt{revisions} which depend on
another \dt{revision}.\\
%
In the first case, the \dt{revision} is created as ``diff'' on another
\dt{revision}, i.e., it originally contained exactly the same
\dt{entities} as the other \dt{revision} and subsequently, all
modifications are stored in the dependent \dt{revision} but not in the
underlying one. Consequently, such a dependent \dt{revision} is
meaningless without the underlying \dt{revision}.
%
In the second case, the \dt{revision} is independently meaningful and
might form the basis for another \dt{revision}.\\
%
Therefore \dt{revisions} might be used for maintaining different
versions of the same set of \dt{entities}\footnote{It also possible
that \dt{entities} are created or deleted in a dependent
\dt{revision}. Thus the term ``set of \dt{entities}'' is to be
understood in an abstract sense.}.\\
% When a \dt{database} is created, it contains only a single
% \dt{revision}, which will contain the \dt{entities} which are
% subsequently created and modified.  
%
When a \dt{database} is created by the \dt{client}, the
\SYNEIGHT might create some system-maintained \dt{revisions} to
manage meta-information on the \dt{database}. 
%
The \dt{client} has to create at least one own \dt{revision} to be
able to store any own data into the \dt{database}. The \dt{client} can
also maintain an arbitrary number of different \dt{revisions}.
%
Later in the development of the \dt{database}, the \dt{client} can
issue a revision-freeze on a particular \dt{revision}, which will
cause the creation of a dependent \dt{revision}. Thus this
\dt{revision} contains exactly the same \dt{entities} in exactly the
same state as the original \dt{revision}. One of these \dt{revisions}
will have the same name as the original one, and can be accessed in
the same way as the original one, the second \dt{revision} will have a
new name (to be specified by the \dt{client}) and will be accessible
in a read-only manner. The latter \dt{revision} can be saved onto
stable storage, thus a backup is generated.\\
%
Therefore, a \dt{participating process} creates, deletes, joins and leaves
\dt{revisions} instead of \dt{databases}.

Based on this definition, we will refine our picture of an
\dt{entity-database}, and describe all possible abstract states of a
\dt{database} and of its revisions, as well as the operations which
are necessary to switch the \SYNEIGHT from one of these states to
another.

The notions of this chapter also form the basis for the remaining
responsibilities. This chapter describes the vast part of the elements of
\SYNEIGHT's interface which are used by the \dt{client} to control the
responsibilities clustered around the stable storage management, i.e.,
swapping, durability and backup generation\footnote{These are the
  responsibilities \vref{resp:swapping}, \vref{resp:durability}, and
  \vref{resp:backup-generation}, respectively.}.
%
The two remaining responsibilities, which can be summarized under the
term distribution management, i.e., reliability and
balancing\footnote{Responsibility \vref{resp:reliability} and responsibility
  \vref{resp:balancing}, respectively.}
%
are seen as black-boxes within this chapter. 

\section{Definitions}



\subsection{Database Revisions}

The central definition of the chapter, the \dt{entity-database revision}, is
presented next. It introduces the last refinement step in our perspective of
the \SYNEIGHT, i.e., this is the last time we replace a simpler
concept by a more refined one. Afterwards, we will only add further 
requirements. 
%
\begin{definition*}{Entity-Database Revision}
  An \dt{entity-database revision} (or just \dt{revision}) is a collection of
  \dt{entities} within an \dt{entity-database}. Each \dt{revision} forms an
  accessible unit, i.e., all operations on \dt{entities} are issued in terms
  of a \dt{revision}.
\end{definition*}
%
We already discussed the distinction between \dt{independent
revisions} and \dt{dependent revisions} in the introduction to this
chapter. We define them now as follows.
%
\begin{definition*}{Independent and Dependent Entity-Database Revisions}
  A \dt{dependent entity-database revision} is based upon another
  \dt{revision} which might be dependent or independent. Such a
  \dt{dependent revision} is interpreted as ``diff'' to the underlying
  \dt{revision}, which means more specifically that
  \begin{itemize}
  \item the state of an \dt{entity} which is unknown to the dependent
  revision is to be queried from the underlying revision. In this case
  we say that the \dt{entity} is indirectly supported by the
  \dt{dependent revision}.
  \item if an indirectly supported \dt{entity} is changed, it is
  copied and inserted into the \dt{dependent revision}. 
  \end{itemize}
  The last two items mean that the \dt{dependent revision} implements
  ``copy-on-write'' semantics. However, a \dt{dependent revision}
  might copy unchanged \dt{entities} to improve the overall
  performance.\\
  %
  A \dt{revision} is an \dt{independent entity-database revision}, if
  it is not \dt{dependent}.
\end{definition*}
%
%The above definitions might need clarification. 
%
Please note that more than one \dt{revision} might be \dt{dependent}
on the same \dt{revision}. Therefore it is possible to maintain
branches within the \dt{database}. 

We defined a \dt{database} as a collection of \dt{entities}. And we
said that every \dt{entity} is uniquely identifiable within a
\dt{database}\footnote{See definition \vref{def:entity-database}.}. We
have to explicate this view now by revising the definition of an
\dt{entity-database}.
\begin{definition*}{Entity-Database (revised)}
  \label{def:entity-database-2}
  An \dt{entity-database} consists of a set of uniquely identifiable
  \dt{revisions}. Each \dt{revision} consists of a set of \dt{entities} which
  are uniquely identifiable within this particular
  \dt{revision}.
\end{definition*}
%
The idea behind \dt{revisions} is that during the production of a
\dt{database}, it might be necessary to generate a snapshot or a
branch into the \dt{database}-development. 
%
Based on what we already said so far, we will only need one
fundamental primitive to achieve this goal -- the creation of a
\dt{dependent revision}.
%%
%%There will be one fundamental primitive to achieve these
%%goals. It will be possible to construct a \dt{revision} as a
%%difference upon a given underlying \dt{revision}. 
%
To generate a snapshot, the \dt{revision} will be frozen, switched
into read-only mode, and a \dt{dependent revision} will be
set-up. Finally, with the help of some renaming, the effect will be
that a snapshot under a new name has been generated. To setup a
branch, a snapshot will be generated, and afterwards, a second
\dt{dependent revision} will be constructed.\\
%
In the preceding chapters, we looked at a \dt{database} as it would have only
a single \dt{revision} and we discussed how this \dt{revision} can be
accessed.
%
In this chapter, we discuss the management of \dt{revisions} and
\dt{databases} as a whole. 

\subsection{Entity Distribution}

At this point we need to introduce some definitions which allow us to speak
about the distribution of \dt{entities}. So far we looked at an \dt{entity} as
globally available within the \dt{revision's supporting group}. From now on we
have to cope with the fact that an \dt{entity} is represented by a number of
\dt{entity instances} which support the \dt{entity} in concern
collectively. Thus we speak about the \dt{entity's collective}. 
%
\begin{definition*}{Entity Instance}
  \label{def:entity-instance}
  Each \dt{participating process} might have its own copy of each
  \dt{entity} which is part of any given \dt{revision}. We call such a
  copy \dt{entity instance} of the \dt{entity} in concern.
\end{definition*}
%
In the above definition, we did not require a \dt{participating process} to be
a part of a \dt{revision's supporting group} to be allowed to keep its own
\dt{entity instances}. In fact, the case that a \dt{process} is not supporting a
\dt{revision} but retains \dt{entity instances} of this \dt{revision} is a
common case, e.g., during start-up, before a supporting group is established. 
%
So, each \dt{process} which has an \dt{entity instance} of a particular
\dt{entity} is said to retain this \dt{entity}.
%
\begin{definition*}{Processes which Retain/Support an Entity}
  \label{def:retaining-supporting-process-1}
  Each \dt{process} which has its own \dt{entity instance} of a given
  \dt{entity} is retaining this \dt{entity}.\\ A \dt{process}
  supports an \dt{entity} if it is a member of the corresponding
  \dt{revision's supporting group} and if it retains the \dt{entity}.
%%
%%  assumes that an \dt{entity instance} of a particular \dt{entity} is
%%  accurate and is a member of the \dt{revision's supporting group}, the
%%  \dt{process} is said to support the \dt{entity} (which implies that
%%  the \dt{process} retains the \dt{entity}).
\end{definition*}
%
We will further explicate the above specification by definition
\vref{def:retaining-supporting-process-2}. 
%
Each \dt{entity instance} can maintain different versions of the \dt{entity
  state}, the \dt{entity instance state}. In such a case, the newest
maintained version of the \dt{entity state} is used to determine the
  accuracy of the overall \dt{entity instance}. The older versions are
only used to allow quick concurrent access. 
%
We discussed the requirements with respect to the management of
different versions of the same \dt{entity} in the preceding chapter.\\
%
An \dt{entity} is not only represented by a set of different states,
which are partly outdated, and partly accurate, but is also
distributed over a number of \dt{processes}.
Thus, an \dt{entity} is represented by a group of \dt{entity instances} -- the
\dt{entity's collective}. This group has to work collaboratively such that,
from the \dt{client's} point of view, these \dt{entity instances} behave like
a single \dt{instance}. 
%
\begin{definition*}{Entity's Collective}
  An \dt{entity's collective} is the group of \dt{entity instances} which
  is supporting this \dt{entity}\footnote{Let us summarize our notion
  of support: A process can support databases, revisions and
  entities. If a process support an entity, it also supports the
  corresponding revision as well as the corresponding
  database. Moreover, if a process supports an entity, it contains an
  \dt{entity instance} which supports the corresponding \dt{entity}.}. 
\end{definition*}
%
Therefore, what we called \emph{the} \dt{entity} is in reality represented by
an \dt{entity's collective} -- the \dt{entity} is only an abstraction (which
we are going to use freely throughout the document, when it is not necessary
to distinguish different instances). 
%
\begin{remark*}{Existence of the Entity's Collective}
  It is important to note, that the \dt{entity's collective} does not
  exist, as long as there is no supporting group for the corresponding
  \dt{revision}. 
  %
  In other words, as long as the supporting group is not established,
  the state of the \dt{entity} is undefined. 
\end{remark*}
%
\begin{remark*}{Existence of a Database}
  First, let us examine the consequences of the last remark. If the
  \dt{entity's collective} does not exist, it means that the
  \dt{entity} does not exist -- after all, it is the \dt{entity's
  collective} which represents the more abstract \dt{entity}.\\
  %
  In other words, as long as the \dt{supporting group} of a
  \dt{revision} does not exist, the \dt{revision} itself does not
  exist. 
  %
  On a first glance, this might appear to be awkward. However, it is
  pointless to talk about the state of an \dt{entity}, if there is no
  defined group of process which define the state of the \dt{entity}
  in concern. But the \dt{supporting group} serves exactly for this
  purpose. Since this is true for every \dt{entity} within a
  \dt{revision}, the whole \dt{revision} is undefined as long as there
  is no \dt{supporting group} for this \dt{revision}.
\end{remark*}

Finally, we define the set of \dt{entity states} of a \dt{revision}
which are retained by a \dt{process} as the \dt{process' share} of
this \dt{revision}. 
%
\begin{definition*}{Participating Process' Share}
  The set of \dt{entity states} of a \dt{revision} which are retained by a
  \dt{participating process} is called the \dt{process' share} of this
  \dt{revision}. 
\end{definition*}


\subsection{Peer Process Groups}

We already introduced the Database Management Interface (\DBMI) which was
defined on page \pageref{def:database-management-interface} as follows:
\begin{quote}
  \DBMIquote
\end{quote}
%
Note that this definition talks about \dt{database}-global operations
without specifying precisely the meaning of global. Before making this
definition more explicit, we replace \dt{database}-global by
\dt{database}- and \dt{revision}-operations, since by now, we know,
that \dt{databases} are only shells for \dt{revisions}. 
%
So, let us clarify what global means. The \SYNEIGHT is
built upon the \dt{Logical Communication Layer} (\dt{LCL}), which
allows a \dt{participating process} to join groups of collaboratively
working \dt{processes}. In each such group a number of \dt{databases}
will be supported by one or more \dt{processes} of the group. It is
the shared and commonly supported view of these groups that
constitutes our notions of global consistency and global operations.
%
\begin{definition*}{Peer Process Group}
  A \dt{peer process group} is a group of \dt{participating processes}
  which are able to communicate with each other directly, i.e., their
  connectivity graph is complete\footnote{The completeness property must
  be provided by the LCL-interface, but the LCL can support any other
  network topology as long as it provides an abstracted interface
  to the \SYNEIGHT which satisfies the clique property.}. A
  \dt{peer process group} must contain at least one \dt{process} but
  can have an arbitrary number of members.\\ 
  % 
  Each member of a \dt{peer process group} can utilize uni-, multi-
  and broadcasting to communicate a message to other members in the
  group.
\end{definition*}
%
The term ``peer group'' is used instead of ``\dt{peer process group}''
whenever the context allows us to do so without incurring confusion.\\
%
Each \dt{process} can be a member of an arbitrary number of \dt{peer
process groups}. Most likely, these groups will be provided by the
\SYNEIGHT for different connection types. For example, there
will always be the \dt{private peer process group} which consists only
of one \dt{process}.
%
However, each \dt{database} can only be maintained within a single
\dt{peer process group}. 
%
\begin{definition*}{Private Peer Process Group}
  Each \dt{process} has its own \dt{private peer process group} which
  consists only of the \dt{process} itself.
\end{definition*}
%
Other examples of \dt{peer process groups} are a cluster \dt{peer
process group} or a tcp-connection \dt{peer process group}. Note that
these \dt{peer groups} might have specific types which define their
behavior. Each such group-type might be instantiated several times.
%
%
Neither these types nor specific groups are defined in this document,
however, each \dt{peer process group} will be used as an abstraction
for a corresponding connection. 
%
Some groups might allow an arbitrary number of members, others will
only allow a fixed or a restricted number of members. However, from the
conceptual point of view, these details are not of import.\\
%
The critical property for the \SYNEIGHT's architecture is the
fact that any member in the group can be reached via uni-, multi- and
broadcast mechanisms. 
%
\begin{remark*}{Communication Primitives}
  When we say that uni-, multi-, and broadcasting is available within
  a \dt{peer process group}, we think very much in abstract terms. The
  concrete design of the communication primitives will be much
  narrower -- for example, there is a good chance that there will be
  special primitives for commitment. 
\end{remark*}

The definition of \dt{peer group} is centered around communication
patterns. The definition's complete connection graph is required for
and is used as the context to open a \dt{database}. So let us return
to the motivation of this subsection. Whenever a \dt{process} wants to
open or create a \dt{database}, this has to happen in the context of a
\dt{peer process group}. Thus a \dt{peer process group} has to
maintain two tables: First a process table, and second a database
table.
%
\begin{definition*}{Peer Process Groups' Process Tables}
  The \dt{process table} of a \dt{peer process group} contains the id
  of each \dt{process} which is a member of the \dt{peer process
  group}. This id has to be durable -- the \dt{process} will be
  recognized by this id when it joins the group, and based on this
  identity, the other group members and the process itself will make
  assumptions about the quantity and quality of information which
  is available locally to the \dt{process} in concern.
\end{definition*}
%
\begin{definition*}{Peer Process Groups' Database Tables}
  The \dt{database table} of a \dt{peer process group} contains, for
  each \dt{database} which is loaded by one or more \dt{processes} of
  the \dt{peer process group}, the following information: The id of the
  \dt{database} which has to be unique within the \dt{peer process
  group} and the name of the \dt{database} which does not have to be
  unique.
\end{definition*}
%
We differentiate between the unique id of a \dt{database} and its name
to allow the application certain flexibilities. For example, after a
system crash, the application might load two versions of the same
\dt{database} within the same peer process group. In such a
situation, the possibility to use application-defined identifiers will be
helpful.

No other meta-information is directly maintained by data structures of
the \dt{peer process group}. All the missing information, such as
which process is supporting a given \dt{database}, is stored in the
meta-information of the \dt{database} in concern. Thus, these two
tables are only used to obtain the keys for accessing the
meta-data.


A \dt{process} can be in a number of states with respect to a \dt{peer
process group}. Most obviously, a \dt{process} can be a member of a
\dt{peer group} or not.\\
%
We do not specify the procedures which have to be taken by a process to
establish or join a peer group. The reason for this sloppiness is
simple: Depending on the type of peer group, the mechanics might be
different. However, we do require that every process can leave a peer
group, and we will state some requirements about the \dt{private peer
process group}. 


%
%% FROM THE OLD DEFINITION OF CONSISTENCY PROCESS GROUP
%% 
%% maintain a set of \dt{databases} collectively. Each
%%   \dt{consistent process group} must have a unique id\footnote{The id
%%   has to be unique with respect to all \dt{processes} with are
%%   reachable over the ``consistency relation'', i.e., the relation
%%   which contains every pair of \dt{processes} which are together in
%%   one consistent process group.}. 
%%   %
%%   The versions of all active \dt{revisions}\footnote{The precise meaning of active
%%   will be presented in definition
%%   \vref{def:revision-access-state-active}. For the moment being, it is
%%   sufficient to know that an active \dt{revision} is made ready for
%%   access within the corresponding consistent process group and is
%%   authoritative within this consistent process group.} within this group are
%%   maintained in a consistent manner, i.e., if two \dt{processes} of
%%   the same \dt{consistent process group} access the same \dt{revision}
%%   (identified by the \dt{database id} and \dt{revision id}), then the
%%   \SYNEIGHT ensures that both \dt{processes} access exactly the
%%   same data.
%%   %
%%   A \dt{database} can be opened only within one \dt{consistent
%%   process group} but a \dt{process} can be a member of several
%%   \dt{consistent process groups}. Only \dt{processes} within the corresponding \dt{consistent
%%     process group} can join the \dt{database's supporting group}.
%% 
%% 
%
%%
%%All meta-information about the \dt{databases} and the \dt{revisions}
%%which are maintained within a \dt{consistent process group} is collectively
%%called \dt{consistency directory} information. It is this information which is maintained
%%primarily within an \dt{consistent process group}.
%%%
%%\begin{definition*}{Consistency Directory}
%%  The \dt{consistency directory} contains the meta-information of the
%%  \dt{databases} and \dt{revisions} which are maintained within the
%%  corresponding \dt{consistent process group}.
%%\end{definition*}
%%%
%%The \dt{consistency directory} is organized as a table which contains for
%%each a \dt{process} and for each \dt{database} (and \dt{revision}) an
%%entry. This entry describes the current state of the \dt{database}
%%(\dt{revision}) with respect to this particular \dt{process}
%%and relative to the overall \dt{consistent process group}.

%%
%%
%%
%%\subsection{Database Management Locks}
%%
%%Each \dt{process} which maintains a \dt{database} (and thus is a member of the
%%corresponding \dt{consistent process group}) has its own local copy of
%%the \dt{consistency directory}.\\
%%%
%%Because of the replicated nature of the \dt{consistency directory} all
%%changes to it must be synchronized. To do so, we introduce a corresponding
%%locking scheme.
%%%
%%There are three kinds of \dt{locks} which correspond to the three different
%%organizational levels within the \dt{consistency directory}.
%%%
%%\begin{definition*}{Directory-Lock}
%%  The \dt{directory-lock} gives the \dt{process} which owns it the exclusive
%%  right to issue commands which modify the corresponding \dt{consistency
%%    directory}.
%%\end{definition*}
%%%
%%For example, the \dt{directory-lock} is used by a \dt{process} which joins
%%the \dt{consistent process group} to synchronize its own local copy of the
%%\dt{consistency directory}. 
%%%
%%The next organizational level is the \dt{databases} and accordingly, there is
%%a \dt{database-lock}. 
%%%
%%\begin{definition*}{Database-Lock}
%%  The \dt{database-lock} gives the \dt{process} which owns it the exclusive
%%  right to issue commands which modify the state of the corresponding
%%  \dt{database} within the \dt{consistency directory} which contains the
%%  \dt{database}.
%%\end{definition*}
%%%
%%Finally, there is a \dt{revision-lock} which gives the owning \dt{process}
%%only the right to modify the state of the corresponding \dt{revision}.
%%%
%%\begin{definition*}{Revision-Lock}
%%  The \dt{revision-lock} gives the \dt{process} which owns it the exclusive
%%  right to issue commands which modify the state of the corresponding
%%  \dt{revision} within the \dt{consistency directory} which contains the
%%  \dt{revision}.
%%\end{definition*}
%%
%%The above three locks are mutual exclusive in the following sense: If
%%a \dt{process} owns a \dt{directory-lock}, no other \dt{process} can
%%gain one of the above three \dt{locks} within for the same
%%\dt{consistency directory}. Similarly, if a \dt{process} owns a
%%\dt{database-lock}, no other \dt{process} can acquire a
%%\dt{revision-lock} for one of the \dt{revisions} of this
%%\dt{database}.
%%
%%
%%In the following subsections we will define the contents of the
%%\dt{consistency directory}.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%%
%%Since \dt{databases} and \dt{revisions} might be supported by several
%%\dt{processes}, accessing this interface requires synchronization. At the same
%%time, commands on this interface will not be used frequently, thus we can use
%%full locking. We introduce two locks, the \dt{database-lock} and the
%%\dt{revision-lock} We call these locks \DBMI-Locks.\\
%%There locks deal with the abstract state of the corresponding database or
%%revision. This abstract state defines which operations on the
%%database/revision are allowed and which are not, e.g., the abstract describes
%%whether a \dt{revision} is read-only or read-write accessible.
%%%
%%\begin{definition*}{Database-Lock}
%%  The \dt{database-lock} gives the \dt{process} which owns it the exclusive
%%  right to issue \DBMI-commands which modify the abstract state of the
%%  \dt{database}.\\
%%  \INTERFACE{\DBMI}
%%\end{definition*}
%%%
%%\begin{definition*}{Revision-Lock}
%%  The \dt{revision-lock} gives the \dt{process} which owns it the exclusive
%%  right to issue \DBMI-commands which modify the abstract state of the
%%  \dt{revision}.\\
%%  \INTERFACE{\DBMI}
%%\end{definition*}
%%%
%%\dt{Processes} can still access and alter their local configuration, but every
%%non-local change is controlled by a single \dt{process} (which holds the
%%corresponding lock).
%%%
%%%%The local operations which do not require a \DBMI-Lock are part of the
%%%%\dt{local database management interface} (\LDBMI)\footnote{See definition
%%%%  \vref{def:local-database-management-interface}.}\\
%%Please note, that even a \dt{process} which is not part in the \dt{supporting
%%  group} of a \dt{database} or a \dt{revision} is allowed to gain a
%%\DBMI-lock. The latter feature will be used to allow a \dt{participating
%%  process} to join a \dt{supporting group}.
%%
%%
%%Definition \vref{def:abstract-state-revision} specifies the contents of the
%%abstract state of a revision.

%%\subsection{Consistency Group States}
%%
%%\newcommand{\cgsstateNIL}{{\normalfont\textsc{nil}}\xspace}
%%\newcommand{\cgstateOUT}{{\normalfont\textsc{out}}\xspace}
%%\newcommand{\cgstateIN}{{\normalfont\textsc{in}}\xspace}
%%




\subsection{Database States}

\newcommand{\dbstateNIL}{{\normalfont\textsc{db\_nil}}\xspace}
\newcommand{\dbstateUNLOADED}{{\normalfont\textsc{db\_unloaded}}\xspace}
\newcommand{\dbstateLOADED}{{\normalfont\textsc{db\_loaded}}\xspace}
\newcommand{\dbstateACTIVATED}{{\normalfont\textsc{db\_activated}}\xspace}


A \dt{database} cannot exist outside a \dt{peer process
group}. Thus whenever a \dt{process} creates or loads a \dt{database},
this has to happen in the context of \dt{peer group}. This is the
reason for the existence and special position of the \dt{private peer
process group} -- if a \dt{process} wants to access a \dt{database}
locally, i.e., in isolation, the \dt{database} has to be loaded into
the \dt{private peer process group}.\\
%
We have to be more precise with respect to the meaning of ``loading a
\dt{database}''. We distinguish three \dt{database}-states, namely
\dbstateNIL, \dbstateUNLOADED, \dbstateLOADED and
\dbstateACTIVATED. These states are defined with respect to a \dt{process}
and a \dt{database}, i.e., a \dt{database} might be in different states with
respect to different \dt{processes}.

The state \dbstateNIL is used for specification
reasons and means that the \dt{process} knows nothing about the
\dt{database}, i.e., it does not exist or the \dt{process} has not yet
learned about the \dt{database} (thus, another process might have
knowledge about it, or it might exist in a stable storage directory,
which has not been loaded so far).
%
\begin{definition*}{Database State Nil: \dbstateNIL}
  A \dt{database} is in the state nil (\dbstateNIL) with respect to a
  \dt{process}, if the \dt{process} has not learned anything about the
  \dt{database}, not even its existence. 
\end{definition*}
%
The next step is to learn that a \dt{database} exists. This can happen
when a stable storage directory is read or when the database table of
a peer group is read. 
%
\begin{definition*}{Database State Unloaded: \dbstateUNLOADED}
  A \dt{database} is in the state unloaded (\dbstateUNLOADED) with
  respect to a \dt{process} and a \dt{peer group}, if the \dt{process} has not learned
  anything about the \dt{database}, except its existence.
\end{definition*}
%
Note, that no \dt{database} exists outside of a \dt{peer group} --
even in the state \dbstateUNLOADED, the \dt{database} is
in the context of a \dt{peer group}.

A \dt{process} can learn more about a \dt{database} in three different
ways, by creating it (bringing the \dt{database} from state
\dbstateNIL directly to \dbstateLOADED), by loading it from stable
storage, or by receiving information about it from other
\dt{processes}. When this happens, the \dt{database} enters the state
\dbstateLOADED with respect to this \dt{process} and with respect to
the specified \dt{peer group}.
%
\begin{definition*}{Database State Loaded: \dbstateLOADED}
  A \dt{database} is in the state loaded (\dbstateLOADED) with respect
  to a \dt{process} and a \dt{peer group}, if the \dt{process} has
  learned about the existence of the \dt{database} and has access to
  the meta-information which is associated with the \dt{database}.
\end{definition*}
%
In the above definition, we explicated what it means for a
\dt{process} to learn about a \dt{database} -- the \dt{process} has to
have access to all meta-information which is associated with this
\dt{database}. In the course of this section, we will become more explicit
about the contents of this meta-information. Basically, this
meta-information allows a \dt{process} to decide in which way it has
to access the \dt{database} such that consistency is
ensured. When a \dt{database} is in the state \dbstateLOADED with
respect to a \dt{process}, the \dt{process} must be registered within
the meta-information of the \dt{database}.
%
Therefore, a \dt{process} which loads a \dt{database} has to alter the
\dt{database's} meta-information.\\
%
The way a \dt{peer group} loads a \dt{process} collectively might
not be obvious at this point. The basic outline is the following: Each
\dt{process} loads its locally present part of the \dt{database} into
its \dt{private peer process group}. This will happen after opening a
stable storage directory. Thus, in this stage, all \dt{processes} have
registered themselves in the meta-information of their locally visible
parts of the \dt{database}. Then, the first \dt{process} will migrate
its part of the \dt{database} to the \dt{peer group}. At this moment,
the \dt{database} becomes globally visible, i.e., all \dt{processes}
in the \dt{peer group} can see the \dt{database}. Now, each
\dt{process} migrates its local part into the \dt{peer group} until
the complete \dt{database} is established again. We will talk about
the migration in the requirement section which will follow this
section.\\
%
After this procedure, the \dt{database} is loaded within the context
of the \dt{peer group} with respect to all \dt{processes}. 
%
The activation is a further step, which allows a \dt{process} to
communicate its willingness to work on the \dt{database}
collectively. 
%
\begin{definition*}{Database State Activated: \dbstateACTIVATED}
  A \dt{database} is in the state activated (\dbstateACTIVATED) with
  respect to a \dt{process} and a \dt{peer group} if the \dt{process}
  has gained the right to access the \dt{database} and is ready to accept
  requests which are related to this \dt{database} from other
  \dt{processes} in the \dt{peer group} which form the loading context
  for the \dt{database}.
\end{definition*}

During the state \dbstateLOADED and \dbstateACTIVATED, the different
\dt{processes} communicate to each other the state of their locally
stored parts of the \dt{database} in concern. Thus, in this phase,
these parts are evaluated in terms of their accuracy and
consistency. It can happen that a \dt{process} assumes at the
beginning that its view on a particular \dt{revision} of the
\dt{database} is accurate and consistent, but learns, when another
\dt{process} publishes its knowledge on the \dt{database}, that the
retained data on the \dt{revision} is already outdated. In conclusion,
this phase is a phase of continuous evaluation and re-evaluation of
the information which is retained by a \dt{process}.
%


%% OLD / OLD / OLD / OLD / OLD
%%
%%A \dt{process} cannot access any data without loading the
%%corresponding \dt{database}. After start-up, a \dt{database} is in the
%%state \dbstateNIL, which means that the \dt{process} knows nothing
%%about the \dt{database} -- thus this state is only used for conceptual
%%purposes. 
%%%
%%\begin{definition*}{Database State Nil: \dbstateNIL}
%%  A \dt{database} is in the database state \dbstateNIL with respect to
%%  a \dt{process}, if the \dt{process} knows nothing about the
%%  \dt{database} in concern.
%%\end{definition*}
%%%
%%When a \dt{process} becomes aware of the existence of a \dt{database},
%%the \dt{database} is switched into the state \dbstateUNLOADED. This
%%transition occurs, for example, when a \dt{process} reads its local
%%stable storage directory or notices that some other \dt{process} is
%%working on the \dt{database}. 
%%%
%%\begin{definition*}{Database State Unloaded: \dbstateUNLOADED}
%%  A \dt{database} is in the database state \dbstateUNLOADED with
%%  respect to a \dt{process}, if the \dt{process} recognizes a
%%  \dt{supporting group} of the \dt{database} in concern. This
%%  \dt{supporting group} is possibly empty. 
%%\end{definition*}
%%%
%%After noticing the \dt{existence} of a \dt{database}, the \dt{process}
%%has to load the \dt{database}. The loading issues the initialization of
%%the basic meta-information which is necessary to ensure consistent
%%\dt{database}-access.
%%%
%%\begin{definition*}{Database State Loaded: \dbstateLOADED}
%%  A \dt{database} is in the database state \dbstateLOADED with respect
%%  to a \dt{process}, if the process declared to all reachable
%%  \dt{processes}\footnote{If a \dt{process} will never access the
%%  \dt{database} in concern, it does not need to be informed about the
%%  \dt{database}.} that this \dt{database} exists and is going to be
%%  accessed.
%%  % 
%%  In particular, the \dt{process} has to declare, whether
%%  the \dt{database} is identical to another \dt{database} which is
%%  already loaded by some other \dt{process}.
%%\end{definition*}
%%%
%%Thus the loading has to establish the basic meta-information
%%which will allow the \dt{process} subsequently to ensure that its view
%%on the \dt{database} is consistent with all other \dt{processes} which
%%are accessing or going to access this \dt{database}.
%%%
%%In other words, loading a \dt{database} corresponds to creating or
%%joining the \dt{supporting group} of the \dt{database} in concern. 
%%


%%has to acquire the corresponding \dt{database-lock} and
%%has to update the \dt{database directory} with the meta-information
%%about those parts of the \dt{database} which are stored locally. 
%%
%%Thus opening a \dt{database} consists not only of reading of reading
%%the local meta-information but also of comparing this local
%%meta-information with the information maintained by the 

\subsection{Revision State Subdivision}

\newcommand{\revprepstateNIL}{{\normalfont\textsc{rev\_prep\_nil}}\xspace}
\newcommand{\revprepstateUNLOADED}{{\normalfont\textsc{rev\_prep\_unloaded}}\xspace}
\newcommand{\revprepstateLOADED}{{\normalfont\textsc{rev\_prep\_loaded}}\xspace}
\newcommand{\revprepstateACTIVATED}{{\normalfont\textsc{rev\_prep\_activated}}\xspace}

\newcommand{\revdiststateEMPTY}{{\normalfont\textsc{rev\_dist\_empty}}\xspace}
\newcommand{\revdiststatePARTIAL}{{\normalfont\textsc{rev\_dist\_partial}}\xspace}
\newcommand{\revdiststateCOMPLETE}{{\normalfont\textsc{rev\_dist\_complete}}\xspace}

\newcommand{\revrelconstateACCURATE}{{\normalfont\textsc{rev\_rel\_accurate}}\xspace}
\newcommand{\revrelconstateOUTDATED}{{\normalfont\textsc{rev\_rel\_outdated}}\xspace}
\newcommand{\revrelconstateBRANCHED}{{\normalfont\textsc{rev\_rel\_branched}}\xspace}
\newcommand{\revrelconstateUNDEFINED}{{\normalfont\textsc{rev\_rel\_undefined}}\xspace}

\newcommand{\revabsconstateCONSISTENT}{{\normalfont\textsc{rev\_abs\_consistent}}\xspace}
\newcommand{\revabsconstateINCONSISTENT}{{\normalfont\textsc{rev\_abs\_inconsistent}}\xspace}
\newcommand{\revabsconstateUNDEFINED}{{\normalfont\textsc{rev\_abs\_undefined}}\xspace}


\newcommand{\revstablestorageSTABLE}{{\normalfont\textsc{rev\_stab\_stable}}\xspace}
\newcommand{\revstablestorageUNSTABLE}{{\normalfont\textsc{rev\_stab\_unstable}}\xspace}

\newcommand{\revaccessstateUNACCESSIBLE}{{\normalfont\textsc{rev\_acc\_unaccessible}}\xspace}
\newcommand{\revaccessstateCLOSED}{{\normalfont\textsc{rev\_acc\_closed}}\xspace}
\newcommand{\revaccessstateREADABLE}{{\normalfont\textsc{rev\_acc\_readable}}\xspace}
\newcommand{\revaccessstateWRITABLE}{{\normalfont\textsc{rev\_acc\_writable}}\xspace}


The state of a \dt{revision} is subdivided into five sub-states which
are defined with respect to a \dt{process} and a \dt{peer
group}. Finally, there is one more sub-state (access) which is defined
with respect to the total \dt{peer group} (this sub-state is the same
with respect to all \dt{processes} of the \dt{peer group}):
\begin{itemize}
\item \textbf{Preparation.} This sub-state describes the degree of
preparation of the data of a \dt{process} on a particular
\dt{revision}. It mimics the \dt{database}-state-chain, i.e.,
it contains the states \revprepstateNIL, \revprepstateUNLOADED,
\revprepstateLOADED, and \revprepstateACTIVATED.
\item \textbf{Distribution.} The distribution sub-state describes the
amount of a information which is retained by a \dt{process}. There are
three possible states, namely \revdiststateEMPTY,
\revdiststatePARTIAL, and \revdiststateCOMPLETE.
\item \textbf{Relative Consistency.} The relative consistency
sub-state of a \dt{revision} describes the consistency of the
\dt{revision} with respect to a \dt{process}, in comparison with the
knowledge which is available in the overall \dt{peer group}. Thus it
describes whether the local view on a \dt{revision} is accurate or
outdated, more precisely, there are the states
\revrelconstateACCURATE, \revrelconstateOUTDATED,
\revrelconstateBRANCHED and \revrelconstateUNDEFINED. We chose the
name relative consistency since this notion of consistency is
dependent on the other \dt{processes'} view on a \dt{revision}.
\item \textbf{Local Consistency.} The local consistency sub-state
indicates, in contrast to the relative consistency sub-state, whether
the internally retained data of the corresponding \dt{process} is in a
consistent view or not. There are three possibilities,
\revabsconstateCONSISTENT, and \revabsconstateINCONSISTENT as well as
\revabsconstateUNDEFINED.
\item \textbf{Stability.} This sub-state describes whether the data on
a \dt{revision} which is retained by a particular \dt{process} is
written on stable storage or not, and correspondingly, there are the
two sub-states, \revstablestorageSTABLE and \revstablestorageUNSTABLE.
\item \textbf{Access.} Finally, the access sub-state describes how a
\dt{revision} can be accessed by the \dt{processes} of a \dt{peer
group}. Thus, it is the only sub-state that is defined in terms of a
\dt{revision} and a \dt{peer group}. The four possible modes are
\revaccessstateUNACCESSIBLE, \revaccessstateCLOSED,
\revaccessstateREADABLE and \revaccessstateWRITABLE.
\end{itemize}


\subsection{Revision Preparation Sub-State}


The preparation sub-state of a \dt{revision} describes the loading
stage of a \dt{revision} with respect to a \dt{process}.  Just as in
the case of \dt{databases}, a \dt{revision} is in the state
\revprepstateNIL, if the \dt{process} knows nothing about the
\dt{revision}, not even that it exists.
%
\begin{definition*}{Revision Preparation State Nil: \revprepstateNIL}
  A \dt{revision} is in the preparation state nil (\revprepstateNIL)
  with respect to a \dt{process},
  if the \dt{process} knows nothing about the \dt{revision}, not even
  that it exists. 
\end{definition*}
%
Once the \dt{process} learns about the existence of the
\dt{revision}, the \dt{revision} enters the state
\revprepstateUNLOADED.
%
\begin{definition*}{Revision Preparation State Unloaded: \revprepstateUNLOADED}
  A \dt{revision} is in the preparation state unloaded
  (\revprepstateUNLOADED) with respect to a \dt{process}, if the
  \dt{process} knows that the \dt{revision} exists, but nothing else. 
\end{definition*}
%
The next step is to load the \dt{revision}. Loading a \dt{revision}
causes the \SYNEIGHT to initialize all data-structures which are
necessary to access the \dt{revision}. In particular, the necessary
cache structures will be set-up. 
%
\begin{definition*}{Revision Preparation State Loaded: \revprepstateLOADED}
  A \dt{revision} is in the preparation state loaded
  (\revprepstateLOADED) with respect to a \dt{process}, if the
  \dt{process} has initialized all data-structures which are necessary to
  access the \dt{revision}. The \dt{process} guarantees to be able
  to access its share of this \dt{revision}.
\end{definition*}
%
Please note, that this initialization should not involve the loading
of the contents of the \dt{revision}, it is a mere infrastructure
initialization. The loading alone does not give to any \dt{process}
(neither the \dt{process} which loaded the \dt{revision} itself nor
any \dt{process} in the \dt{peer group}) the right to access the
\dt{revision} in concern. Also, as long as the \dt{revision} is 
in the state \revprepstateLOADED, its relative consistency state might
change.
%
The activation closes this phase, i.e., the most accurate versions of
the \dt{revision} are chosen to form the \dt{revision}. From that
moment in time, this version of the \dt{revision} is defined to be
accurate (i.e., in the relative consistency state
\revrelconstateACCURATE) and every other version is in the relative
consistency sub-state \revrelconstateOUTDATED, \revrelconstateBRANCHED
or \revrelconstateUNDEFINED.
%
If another, newer version of the database is loaded
afterwards, it will be ignored after activation (more precisely, it
will be assigned the relative consistency state
\revrelconstateBRANCHED). In other words, once a particular version of
a \dt{revision} is activated (independently of the distribution state
of this version of the \dt{revision}), the data of this version of the
\dt{database} is definite, in the sense that it defines relative
consistency\footnote{Naturally, the application can deactivate a
\dt{database} and rerun the activation.}.
%
\begin{definition*}{Revision Preparation State Activated: \revprepstateACTIVATED}
  A \dt{revision} is in the preparation state activated
  (\revprepstateACTIVATED) with respect to a \dt{process}, if the
  \dt{process} has initialized all data-structures which are necessary to
  access the \dt{revision} and is ready for access.
\end{definition*}
%
In the above definition, ``ready for access'' means, that it will be
possible to open the \dt{revision} -- i.e., to change the access
sub-state of the \dt{revision}. 
%
Please note that it is not necessarily possible to switch a
\dt{revision} with respect to a \dt{process} into the state
\revprepstateACTIVATED. For example, an outdated version of the
\dt{revision} cannot be switched into this state\footnote{There are
ways to do so -- basically by renaming the revision. But this should
be considered as a recovery action which is executed based on human
intervention.}.\\
%
Also, it is important to know, that only one group of mutually
consistent \dt{revision}/\dt{process} pairs can be switched into the
preparation state \revprepstateACTIVATED. Once, such a group is
established, it is possible to change its access sub-state. It is
precisely this group, what we called the \dt{revision's supporting
group}. All other \dt{processes} are just retaining data on the \dt{revision}.\\
%
We already announced an explication of definition
\vref{def:retaining-supporting-process-1} -- this explication is given
by the following definition.
%
\begin{definition*}{Processes which Retain/Support an Entity (refined)}
  \label{def:retaining-supporting-process-2}
  Each \dt{process} which has its own \dt{entity instance} of a given
  \dt{entity} is retaining this \dt{entity}.\\
  If a \dt{process} retains an \dt{entity} and if the corresponding
  \dt{revision} is in the preparation state \revprepstateACTIVATED
  with respect to this \dt{process}, then we say that the \dt{process}
  is supporting the \dt{entity} in concern as well as the underlying \dt{revision}.
\end{definition*}




\subsection{Revision Distribution Sub-State}
\label{sec:revision-states-distribution}

We continue with the distribution states of a \dt{revision}. The \SYNEIGHT
distributes the contents of each \dt{revision} over a possibly large number
of \dt{participating processes}. Each of these \dt{processes} contains its own
limited view of the \dt{revision}. The view is limited in the sense that a
\dt{process's} might not retain all \dt{entities} of a
\dt{revision}. The reasons for such a situation (which will be the
ordinary situation) are twofold -- first, it might be impossible for
a \dt{process} to retain all \dt{entities} because of the associated
memory consumption, and second, it might not be desirable for a
\dt{process} to communicate all \dt{entities} which it retains to its
peers. 

The first possible distribution state of a \dt{revision} with respect to a
\dt{process} is empty. This state is assumed, if the corresponding
\dt{process} does not retain any \dt{entity instances} for the \dt{revision}
in concern.
%
This state is entered if a \dt{process} wants to join an already existing
\dt{revision's supporting group}. Also, it is used for reinitialization
after a critical failure which does not allow recovery.
%
\begin{definition*}{Distribution State Empty: \revdiststateEMPTY}
  A \dt{revision} is in the distribution state empty (\revdiststateEMPTY) with
  respect to a \dt{process}, if it does not retain any \dt{entity} of the
  \dt{revision} in concern. 
\end{definition*}
%
The next distribution state is entered by a \dt{process}, if the
\dt{revision} in concern is partially retained by this \dt{process}.
%
\begin{definition*}{Distribution State Partial: \revdiststatePARTIAL}
  A \dt{revision} is in the distribution state partial (\revdiststatePARTIAL) with
  respect to a \dt{process}, if the \dt{process} retains a subset of the
  \dt{entities} of this \dt{revision}.
\end{definition*}
%
Now we introduce the distribution state \revdiststateCOMPLETE which is entered
by a \dt{revision} with respect to a \dt{process} if this process retains the entire
\dt{revision}, i.e., the whole \dt{revision} is retained in the main-memory
and stable storage of the \dt{process} in concern.
%
\begin{definition*}{Distribution State Complete: \revdiststateCOMPLETE}
  A \dt{revision} is in the distribution state complete
  (\revdiststateCOMPLETE) with respect to a \dt{process}, if this \dt{process}
  retains all \dt{entities} of this \dt{revision}.
\end{definition*}
%



\subsection{Revision Relative Consistency Sub-State}


The consistency state of a revision describes whether the
\dt{revision} in concern is upto-date with respect to all other
\dt{processes} within the \dt{peer process group}. If that is
the case, then the \dt{revision} is in the relative consistency state
\revrelconstateACCURATE.
%
\begin{definition*}{Relative Consistency State Accurate: \revrelconstateACCURATE} 
  A \dt{revision} is in the relative consistency state \dt{accurate}
  with respect to a \dt{process}, if the locally retained data on the
  \dt{revision} does not contain outdated \dt{entities} with respect
  to any other
  \dt{database}\footnote{\label{fn:database-contains-metadata} When a
  \dt{database} is loaded, all associated meta-information on this
  \dt{database} and thus on all its \dt{revisions} has been made
  available to all \dt{processes} in the \dt{peer group}.} which has
  been loaded by a \dt{process} of the same \dt{peer group}.
\end{definition*}
%
If a \dt{process} learns that its view on a \dt{revision} is
outdated\footnote{This can happen when a \dt{processes} loads the
corresponding \dt{database} into a \dt{peer group} or when another
\dt{process} publishes its meta-information on the \dt{database}
(i.e., loads the \dt{database} into the \dt{peer group}).}, the
relative consistency state of this \dt{revision} with respect to this
\dt{process} is switched to \revrelconstateOUTDATED.
%
\begin{definition*}{Relative Consistency State Outdated: \revrelconstateOUTDATED} % was dirty
  A \dt{revision} is in the relative consistency state \dt{outdated}
  (\revrelconstateOUTDATED) with respect to a \dt{process}, if the
  \dt{process' share} of the \dt{revision} contains outdated
  \dt{entity states} and if the \dt{process} is
  informed\footnote{Since the data of a \dt{process} becomes outdated
  when another \dt{process} updates this data without informing the
  first \dt{process}, a \dt{process} might not know that its data is
  outdated.} about this situation.
\end{definition*}
%
The above definitions indicate that the relative consistency state of
a \dt{revision} is dependent on the other members of the \dt{peer
process group} and on the \dt{databases} they have been loading into
the \dt{peer group}\footnote{See
footnote \vref{fn:database-contains-metadata}.}. Thus, before a \dt{peer
group} initiates its work on a \dt{revision} it checks which
\dt{processes} retain this \dt{revision} in the state
\revrelconstateACCURATE. These \dt{processes} are selected to setup
the \dt{revision's supporting group}.\footnote{Every other, more
elaborate action will require human intervention. So, for example, it
is definitely out of the scope of this project, to actualize the
outdated data of \dt{process} which is retained by a \dt{process}. It
would be possible to do so, by replaying ``some'' journaling
information -- and we are considering the possibility to maintain
\dt{entities} which are journaling their own history. However, such an
updating process would have to be based on transaction journals (or a
temporary freeze of the overall cluster).}\\
%
Therefore, it can happen that a \dt{process} which joins an \dt{peer
process group} is faced with the following situation: One of the
\dt{revisions} which is retained by this \dt{process} has been altered
by this \dt{process} (maybe collectively with other \dt{processes} or
alone) but the current members of the \dt{revision's supporting group}
did not learn about these modifications. Thus their view on this
\dt{revision} was in fact \revrelconstateOUTDATED, but they were
unable to recognize this fact since the currently joining \dt{process}
was not present in the group (or the corresponding \dt{database} has
not been loaded) when they re-initiated their work on the
\dt{revision}. Thus joining the \dt{process's} view on the
\dt{revision} is in the state \revrelconstateBRANCHED.
%
\begin{definition*}{Relative Consistency State Branched: \revrelconstateBRANCHED} % was inconsistent
  \label{def:revrelconstateBRANCHED} A \dt{revision} is in the
  relative consistency state branched (\revrelconstateBRANCHED) with
  respect to a \dt{process}, if the \dt{process' share} has been
  modified such that the current \dt{revision's supporting group} did
  not learn about these changes. This state is only entered, when the
  \dt{process} learns about this situation.
\end{definition*}
%
It is also possible, that all available versions of a \dt{revision}
are in the state \revrelconstateBRANCHED. This situation arises, when
two independent groups of \dt{processes} modified the same
\dt{revision} without incorporating the changes which are implied by
the other group. In this situation, the \dt{client} has to decide,
which versions is to be chosen as the accurate one.\\
%
The above definition implies that the version of the \dt{revision} which has
been activated first wins, i.e., all other branches which might be retained by
the other \dt{processes} will be treated as \revrelconstateBRANCHED.\\

At last, it is possible, that a \dt{process} must make the most conservative
assumption on the relative consistency of its local view on a \dt{revision}: That its
locally retained data is in an undefined state. 
%
This state will typically be assumed after an uncontrolled reboot or another
catastrophic event. 
%
\begin{definition*}{Relative Consistency State Undefined: \revrelconstateUNDEFINED} % was inconsistent
  A \dt{revision} is in the relative consistency state undefined
  (\revrelconstateUNDEFINED) with respect to a \dt{process} if the
  \dt{process} is unable to guarantees that its local view on this
  \dt{revision} is in one of the above states. 
\end{definition*}
%
If \revrelconstateUNDEFINED is reached, then the \dt{process} can delete its
possibly mal-formed information on the \dt{revision}. For every other, more
elaborate recovery action, human intervention would be necessary.

\subsection{Revision Local Consistency Sub-State}

Besides the relative consistency state of a \dt{revision}, which
describes the consistency of the \dt{revision} with respect to other
\dt{processes}, the \SYNEIGHT is also maintaining consistency
information which is only concerned with \dt{process}-internal
representation of the \dt{revision}. We call the associated sub-state
the local consistency state.\\
%
If the data which is retained by a \dt{process} on a particular
\dt{revision} is consistent, then we say that the \dt{revision} is in
the local consistency state \revabsconstateCONSISTENT with respect to
this \dt{process}. If the \dt{process} learns, that the \dt{revision}
is in an inconsistent state, then the \dt{revision} is in the local
consistency state \revabsconstateINCONSISTENT.
%
\begin{definition*}{Local Consistency State Consistent: \revabsconstateCONSISTENT}
  If the data on a \dt{revision} which is retained by a \dt{process}
  is in a consistent state, then the local consistency state of
  this \dt{revision} with respect to the \dt{process} in concern is
  \revabsconstateCONSISTENT. 
\end{definition*}
%
\begin{definition*}{Local Consistency State Inconsistent: \revabsconstateINCONSISTENT}
  If the data on a \dt{revision} which is retained by a \dt{process}
  is in an inconsistent state and if the \dt{process} can specify the
  reason for the inconsistency, then the absolute consistency state of
  this \dt{revision} with respect to the \dt{process} in concern is
  \revabsconstateINCONSISTENT.
\end{definition*}
%
We require a \dt{process} to specify the reason for the inconsistency
to assume the state \revabsconstateINCONSISTENT. It is quite possible,
that we will introduce a number of more telling local consistency
states, which will replace \revabsconstateINCONSISTENT in the course
of this project.
%
The inconsistency states will depend at least partly on the  concrete
implementation -- thus it is possible that we choose a generic
inconsistency framework.\\
%
If a \dt{process} is unable to determine whether its
data on a \dt{revision} is consistent or not, then the \dt{revision}
is in the local consistency state \revabsconstateUNDEFINED. This
case will make re-initialization necessary. 
%
\begin{definition*}{Local Consistency State Undefined: \revabsconstateUNDEFINED}
  If the data on a \dt{revision} which is retained by a \dt{process}
  is in a state such that the \dt{process} is unable to determine
  whether the data is consistent or not, then the \dt{revision} is in
  the local consistency state \revabsconstateUNDEFINED.
\end{definition*}


\subsection{Revision Stability Sub-State}

There are two possible states of a \dt{revision} with respect to stable
storage and with respect to a \dt{process} (to be more precise, of the part
of the \dt{revision} which is visible to the \dt{process}). If there are no
outdated \dt{entities} in the \dt{process's} stable storage, then the revision
is stable with respect to this process. 

\begin{definition*}{Stability State Stable: \revstablestorageSTABLE}
  A \dt{revision} is called \dt{stable} with respect to a \dt{process}
  if the stable storage contains
  \begin{itemize}
  \item no outdated \dt{entities} (with respect to the main-memory of the
    \dt{process})
  \item and if the stable storage contains all \dt{entities} which are
    retained by this \dt{process} and which need to be stored
    stably\footnote{We will define the set of \dt{entities} which need to be
      saved in stable storage in chapter \vref{sec:durability}.}.
  \end{itemize}
  Basically, the above two items state that the main-memory of a \dt{process}
  and its stable storage must be in sync.\\
\end{definition*}

\begin{definition*}{Stability State Unstable: \revstablestorageUNSTABLE}
  A \dt{revision} is in the stability state unstable
  (\revstablestorageUNSTABLE) with respect to a \dt{process}, if the conditions of the last
  definitions are not met, i.e., if there are entities whose accurate
  state is only retained in volatile memory (whether there is an
  outdated stored state or not).
\end{definition*}


\subsection{Revision Access Sub-State}

Finally, there is the access sub-state which describes the way a
\dt{process} is allowed to access a \dt{revision}. The access
sub-state can only be changed for the overall \dt{revision's
supporting group}, i.e., for the group of the \dt{processes} which are
in the preparation state \revprepstateACTIVATED.\\
%
When a \dt{revision's supporting group} has been established, the
\dt{revision} enters the access state \revaccessstateCLOSED. In this
access state, the \dt{revision} cannot be read nor it is possible to
write into it. 
%
\begin{definition*}{Revision Access State Closed: \revaccessstateCLOSED}
  A \dt{revision} is in the access state closed
  (\revaccessstateCLOSED), if no \dt{process} is allowed to read from
  or write to the \dt{revision}.
\end{definition*}
%
When a \dt{revision} is in the state \revaccessstateCLOSED, this does
not mean, that absolutely no data is changing -- it only means that
the application's data will not be altered. In fact, meta-information
can change (and establishing the \dt{supporting group} does change the
meta-information).\\
%
If the application wants to read its own data, it has to switch the
\dt{revision's supporting group} into the access state
\revaccessstateREADABLE. 
%
\begin{definition*}{Revision Access State Readable: \revaccessstateREADABLE}
  If a \dt{revision} is in the access state readable
  (\revaccessstateREADABLE), the \dt{processes} which are a member of
  the \dt{revision's supporting group} are allowed to access the
  \dt{entities} of the \dt{revision} in a read-only manner. 
\end{definition*}
%
Finally, to modify the \dt{entities} of a \dt{revision}, the
\dt{revision} has to be switched into the access state \revaccessstateWRITABLE.
%
\begin{definition*}{Revision Access State Writable: \revaccessstateWRITABLE}
  A \dt{revision} which is in the access state writable
  (\revaccessstateWRITABLE), can be read and modified without any
  restriction by all members of the \dt{revision's supporting group}.
\end{definition*}


Please note, that the access state is defined in terms of the overall
revision, i.e., it is not possible that one \dt{process} is keeping
the \dt{revision} in state \revaccessstateREADABLE and another one
accesses via the state \revaccessstateWRITABLE.


\section{Requirements}

\subsection{Database State Transitions}
\subsection{Database Migration}
\subsection{Revision Preparation Sub-State Transitions}
\subsection{Revision Distribution Sub-State Transitions}
\subsection{Revision Relative Consistency Sub-State Transitions}
\subsection{Revision Absolute Consistency Sub-State Transitions}
\subsection{Revision Stability Sub-State Transitions}
\subsection{Revision Access Sub-State Transitions}




\chapter{Reliability}
\label{sec:reliability} 

\section{Definitions}

\section{Requirements}



\chapter{Balancing}

\section{Definitions}

\label{def:balancing-account} 

\section{Requirements}


\chapter{Swapping}

\section{Definitions}

\section{Requirements}

 
\chapter{Durability}
\label{sec:durability}

\section{Definitions}

\section{Requirements}
 
 
\chapter{Backup Generation}
 

\section{Definitions}

\section{Requirements}
 

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 



%%
%%
%%The access to a \dt{revision} must be synchronized within the overall
%%\dt{supporting group} of the corresponding \dt{database}. After
%%loading the \dt{database}, i.e., after establishing the \dt{database's
%%supporting group}, the \dt{process} can potentially access all
%%\dt{revisions} of the \dt{database} which are at least in the access
%%state \accessstateSUBMITTED. If a \dt{process} submits a
%%\dt{revision}, then the \dt{process} commits to provide the
%%\dt{revision}\footnote{To be more precise, the \dt{process} commits to
%%provide all the information which it owns. This information can be
%%partial or total -- and for initialization purposes, it can be
%%empty, too. See subsection \vref{sec:revision-states-distribution}.}
%%to all the processes within the \dt{database's supporting group}. More
%%precisely, the \dt{process} which submits a \dt{revision} has no more
%%rights on the \dt{revision} than any other \dt{process} in the
%%\dt{supporting group}.
%%%
%%The access state \accessstateNIL and \accessstateUNLOADED are the
%%predecessors of the \accessstateSUBMITTED. In the first state,
%%\accessstateNIL, the \dt{process} has no knowledge on the
%%\dt{revision}, quite similar to the corresponding \dt{database} state.
%%%
%%\begin{definition*}{Revision Access State Nil: \accessstateNIL}
%%  A \dt{revision} is in the access state Nil (\accessstateNIL) with
%%  respect to a \dt{process}, if the \dt{process} has no information on
%%  the \dt{revision} and does not even know that the \dt{revision}
%%  exists.
%%\end{definition*}
%%%
%%Once the \dt{process} learns that the \dt{revision} exists, the
%%\dt{revision} is in the access state \accessstateUNLOADED. In symmetry
%%to the \dt{database} state \dbstateLOADED (it was unloadeD), the \dt{process} can
%%learn about a \dt{revision} by reading the stable storage and by being
%%informed over the network. 
%%%
%%\begin{definition*}{Revision Access State Unloaded: \accessstateUNLOADED}
%%  A \dt{revision} is in the access state Unloaded
%%  (\accessstateUNLOADED) with respect to a \dt{process}, if the
%%  \dt{process} knows only that the \dt{revision} exists, but has no
%%  acquired any other information about the \dt{revision}. 
%%\end{definition*}
%%
%%
%%
%%
%% When a \dt{process} joins an \dt{application process group} it has to
%%update its \dt{application directory} such that it shares the common
%%perspective on the \dt{databases} and their \dt{revisions}. Moreover,
%%by updating the \dt{application directory}, the \dt{process} learns
%%which \dt{revisions} are accessible at the moment.\\
%%%
%%Afterwards, the \dt{process} has to declare what it wants to share or
%%access. To do so, it has to select the corresponding access state for the
%%\dt{revision} in concern. 
%%
%%The first access state of a \dt{revision} with respect to a \dt{process} is
%%unloaded. A \dt{revision} is in this state directly after opening the
%%\dt{application's directory}. 
%%

%%
%%\subsection{Revision States: Local Consistency}
%%
%%\newcommand{\constateEMPTY}{{\normalfont\textsc{empty}}\xspace}
%%\newcommand{\constatePARTIAL}{{\normalfont\textsc{partial}}\xspace}
%%\newcommand{\constateTOTAL}{{\normalfont\textsc{total}}\xspace}
%%
%%
%%
%%We go on with the local consistency states of a \dt{revision}. The
%%\SYNEIGHT distributes the contents of each \dt{revisions} over a
%%possibly large number of \dt{participating processes}. Each of these
%%\dt{processes} contains its own limited view of the \dt{revision}. The view is
%%limited in the sense that a \dt{process's} resources might not be sufficient
%%to keep the contents of the overall \dt{revision} within its main-memory and 
%%stable-storage systems.\\
%%%
%%Thus, the question of consistency of this local view with the global view
%%arises. The basic assumption we will use is that the group of processes which
%%supports the \dt{revision} defines the correct contents of the
%%\dt{revision}. 
%%%
%%Thus a \dt{process} which contains an \dt{entity} but does not support it, has
%%to measure the state of this \dt{entity} against the version of the
%%\dt{entity} which is maintained by the supporting group of the corresponding
%%revision.\\
%%%
%%This might sound like a circular definition, however, the \SYNEIGHT will
%%issue extensive checks during the \emph{initial} establishment of the
%%\dt{revision's supporting group} to set up a globally consistent view on the
%%\dt{revision}. Once this globally consistency is reached, the \SYNEIGHT
%%will allow the \dt{client} to access the \dt{revision} in a read-only mode,
%%and subsequently, to switch the \dt{revision} into full operational mode.\\
%%%
%%Therefore, after the establishment of the initial \dt{revision's supporting
%%  group}, this group defines what is consistent and what is not. As we will
%%see in chapter \vref{sec:reliability}, each \dt{process} will actively watch
%%itself and all other \dt{processes} in the supporting group to detect possible
%%deviations and to act properly.
%%
%%There are the following six consistency states along with a brief description
%%of their meaning. Each \dt{process} is in exactly one of these states with
%%respect to any \dt{revision}.
%%\begin{center}\begin{tabular}{|l|p{100mm}|} \hline
%%\constateEMPTY        & \dt{process} has no local information on the \dt{revision}  \\ \hline
%%\constatePARTIAL      & \dt{process} has partial information on the \dt{revision} which is locally consistent \\ \hline
%%\constateDISTRIBUTED  & \dt{process} is part of the \dt{revision's supporting group} \\ \hline
%%\constateCENTRALIZED  & \dt{process} has total information on the \dt{revision}  \\ \hline
%%\constateOUTDATED     & \dt{process} detected that its information on a
%%\dt{revision} is outdated but still internally consistent \\ \hline
%%\constateUNDEFINED    &  \dt{process} is unable to give any of the above
%%guarantees \\ \hline       
%%\end{tabular}\end{center}
%%
%%
%%
%%The first possible consistency state of a \dt{process} with respect to a
%%\dt{revision} is empty. A \dt{process} is in this state, if it does not
%%contain any \dt{entity instances} which support any \dt{entity} which is
%%part of the \dt{revision} in concern.
%%%
%%This state is entered if a \dt{process} wants to join an already existing
%%\dt{revision's supporting group}. Also, it is used for reinitialization
%%after a critical failure which does not allow recovery.
%%%
%%\begin{definition*}{Consistency State Empty: \constateEMPTY}
%%  A \dt{process} is in the consistency state empty (\constateEMPTY) with
%%  respect to a \dt{revision}, if it does not contain any \dt{entity} of the
%%  \dt{revision} in concern. 
%%\end{definition*}
%%%
%%The next consistency state is taken over by a \dt{process}, if the
%%\dt{revision} in concern is partially supported by this \dt{process} and if
%%the \dt{process} did no join the \dt{revision's supporting group}. 
%%%
%%\begin{definition*}{Consistency State Partial: \constatePARTIAL}
%%  A \dt{process} is in the consistency state partial (\constatePARTIAL) with
%%  respect to a \dt{revision}, if the \dt{process} contains a part of the
%%  \dt{entities} of a \dt{revision} if the \dt{process} is not in the
%%  \dt{revision's supporting group}.
%%\end{definition*}
%%%
%%The above definition implies that the \dt{entities} of the \dt{revision} in
%%concern are contained in the \dt{process} but are supported by the
%%\dt{process}.\\
%%%
%%\constatePARTIAL is typically reached during the start-up or shut-down of a
%%group of \dt{participating processes}. So, after working jointly on a
%%\dt{revision}, the \dt{revision} is switched over into a read-only mode, the
%%\dt{processes} leave the \dt{revision's supporting group} and reach
%%\constatePARTIAL. In this state, each \dt{process} might stabilize the
%%\dt{entities} it contains\footnote{The \dt{entities} were supported
%%  beforehand, but by leaving the \dt{supporting group}, they are no longer
%%  supported.}, i.e., switch from \stablestorageUNSTABLE to
%%\stablestorageSTABLE (the consistency state is still \constatePARTIAL). When such a system
%%reboots, every \dt{process} finds the \dt{revision} in concern in the state
%%\constatePARTIAL, and will switch over to \constateDISTRIBUTED through
%%an elaborate establishment protocol.\\
%%If a \dt{process} is in the consistency state \constateDISTRIBUTED with
%%respect to a \dt{revision}, then the \dt{process} is part of the
%%\dt{revision's supporting group}, i.e., it has access to all \dt{entities} of
%%this \dt{revision} either locally or by communicating with other
%%\dt{processes}. Moreover, the \dt{process} does not only  \dt{entities} but is
%%supporting them, i.e., the \dt{process} knows that its perspective on the
%%\dt{revision} is authoritative by definition.
%%%
%%\begin{definition*}{Consistency State Distributed: \constateDISTRIBUTED} % was Networked
%%  A \dt{process} is in the consistency state distributed
%%  (\constateDISTRIBUTED) with respect to a \dt{revision}, if the \dt{process}
%%  is part of the \dt{revision's supporting group}.
%%\end{definition*}
%%%
%%At this point the question arises what has to happen if there are two
%%\dt{supporting groups} for the same \dt{revision}. This might happen if the
%%nodes in a cluster are divided into two groups by the failure of some
%%network-hardware. This problem is addressed in chapter
%%\vref{sec:reliability}. Basically, when a sufficiently large number of
%%\dt{participating processes} fails, the \dt{supporting group} has to
%%shut-down and human intervention is required.
%%
%%Now we introduce the consistency state \constateCENTRALIZED which is entered
%%with respect to a \dt{revision} if a process contains the entire
%%\dt{revision}, i.e., the whole \dt{revision} is contained in the main-memory
%%and stable storage of the \dt{process} in concern.
%%%
%%\begin{definition*}{Consistency State Centralized: \constateCENTRALIZED}
%%  A \dt{process} is in the consistency state centralized
%%  (\constateCENTRALIZED) with respect to a \dt{revision}, if the \dt{process}
%%  contains all \dt{entities} of this \dt{revision}.
%%\end{definition*}
%%%
%%Please note, that these states are exclusive, i.e., each \dt{process} can only
%%be in one of the consistency states. Thus a \dt{process} which is in the state
%%\constateDISTRIBUTED can never assume that it knows all the current contents
%%of the \dt{revision}\footnote{There is one exception to this statement: If the
%%  \dt{revision's supporting group} contains only a single \dt{process}, then
%%  the \dt{process} knows the whole \dt{revision}. But still, if the
%%  \dt{revision} is actively accessed, the \dt{revision} has to be in the state
%%  \constateDISTRIBUTED.}.
%%%
%%The above definition comes with one subtle formulation: The whole
%%\dt{revision} must be \emph{contained} within the \dt{process}. Thus, it is
%%not necessarily supported. Indeed, it can only be supported in the consistency
%%state \constateDISTRIBUTED. 
%%%
%%Thus \constateCENTRALIZED is only used for generating a complete image of the
%%\dt{revision}.
%%
%% Finally, we introduce two consistency states for failure conditions. The first
%% one, \constateOUTDATED is assumed when the \dt{process} learns that the data
%% it stores is already outdated. This can happen, when a \dt{process} wants to
%% join or co-establish a \dt{revision's supporting group} and learns that it
%% missed some modifying operations on the \dt{revision} in concern. 
%% %
%% \begin{definition*}{Consistency State Outdated: \constateOUTDATED} % was dirty
%%   A \dt{process} which has outdated, but still internally consistent,
%%   information on a \dt{revision} and which is informed on this fact, is in the
%%   consistency state \constateOUTDATED with respect to this \dt{revision}.
%% \end{definition*}
%% %
%% At last, it is possible, that a \dt{process} must make the most conservative
%% assumption on the consistency of its local view on a \dt{revision}: That its
%% locally maintained data is in an undefined state. 
%% %
%% This state will be assumed typically after an uncontrolled reboot or another
%% catastrophic event. 
%% %
%% \begin{definition*}{Consistency State Undefined: \constateUNDEFINED} % was inconsistent
%%   A \dt{process} which is unable to guarantee that its local view on a
%%   \dt{revision} is in one of the above states, is in the consistency state
%%   undefined (\constateUNDEFINED) with respect to this \dt{revision}.
%% \end{definition*}
%% %
%% If \constateUNDEFINED is reached, then the \dt{process} can only switch over
%% to \constateEMPTY. For every other, more elaborate recovery action, human
%% intervention would be necessary. 


%%\subsection{Revision States: Access}
%%
%%\newcommand{\accessstateUNLOADED}{{\normalfont\textsc{unloaded}}\xspace}
%%\newcommand{\accessstateREADONLY}{{\normalfont\textsc{read\_only}}\xspace}
%%\newcommand{\accessstateREADWRITE}{{\normalfont\textsc{read\_write}}\xspace}
%%
%%There is a third category of \dt{process}-states with respect to a \dt{revision}
%%-- the way it is allowed to access the available contents\footnote{With the
%%  exception of the consistency state \constateDISTRIBUTED, only the locally
%%  maintained information is available to a \dt{process}.} of a \dt{revision}.
%%%
%%The three possible access states are \accessstateUNLOADED,
%%\accessstateREADONLY and \accessstateREADWRITE. 
%%
%%
%%A \dt{process} is in the first access state, \accessstateUNLOADED, if the
%%\dt{revision} is not loaded into main-memory. This state will be assumed
%%typically on system start-up.
%%%
%%\begin{definition*}{Access State Unloaded: \accessstateUNLOADED}
%%  A \dt{process} is in the access state unloaded (\accessstateUNLOADED) with respect to a
%%  \dt{revision} if the \dt{revision} is not present in the main-memory but
%%  only maintained in the stable storage. 
%%\end{definition*}
%%%
%%After loading a \dt{revision} into main-memory, the access state becomes
%%\accessstateREADONLY. Please note that loading into main-memory does not mean
%%to load the entire \dt{revision} (or the part of it which is presently
%%supported by the \dt{process} in concern) but to load management information
%%to be ready for read accesses. The amount of information which will be
%%necessary to reach this state is not of concern within this document. 
%%%
%%\begin{definition*}{Access State Read-Only: \accessstateREADONLY}
%%  A \dt{process} is in the access state read-only (\accessstateREADONLY) with
%%  respect to a \dt{revision} if the \dt{revision} is (partially) loaded into
%%  the main-memory and the \dt{process} is ready to handle read requests of the
%%  \dt{client}.
%%\end{definition*}
%%%
%%Finally, to be able to modify a \dt{revision}, the \dt{client} has to switch
%%the \dt{revision} into the access state \accessstateREADWRITE. 
%%%
%%\begin{definition*}{Access State Read Write: \accessstateREADWRITE}
%%  A \dt{process} is in the access state read-write (\accessstateREADWRITE)
%%  with respect to a \dt{revision} if the \SYNEIGHT is able handle read
%%  and write requests of the \dt{client} which are aimed at the \dt{revision} in
%%  concern.
%%\end{definition*}
%%
%%
%%
%%
%%\begin{definition*}{Abstract State of a Revision}
%%  \label{def:abstract-state-revision}  
%%  The abstract state of a \dt{revision} is defined by its stable storage state
%%  (either \stablestorageSTABLE or \stablestorageUNSTABLE), its
%%  consistency state (either \constateEMPTY, \constatePARTIAL,
%%  \constateDISTRIBUTED, \constateCENTRALIZED, \constateOUTDATED or
%%  \constateUNDEFINED) and its access state (\accessstateUNLOADED,
%%  \accessstateREADONLY, or \accessstateREADWRITE).
%%\end{definition*}
%%


%%
%%
%%
%%\subsection{Database Management Interface Locks}
%%
%%We open our requirement list with the issues around the \DBMI-locks. These
%%\DBMI-locks are give a \dt{process} the right to issue most of the commands
%%which will be discusses in the following subsections. 
%%
%%\begin{requirement*}{Availability of the \DBMI-Locks}
%%  Any \dt{participating process} can gain on any \dt{database} (\dt{revision})
%%  or the corresponding \dt{database-lock} (\dt{revision-lock}), which allows
%%  the \dt{process} to issue commands which modify the abstract state of the
%%  \dt{database} (\dt{revision}).\\
%%  \INTERFACE{\DBMI}
%%\end{requirement*}
%%%
%%Once a \dt{process} holds such a lock, no other \dt{process} can do modify the
%%abstract state of the corresponding \dt{database} or \dt{revision}. Thus if a
%%lock-holding \dt{process} fails, the \dt{lock} must be recovered
%%effectively. In particular 
%%
%%\begin{requirement*}{Recovering a \DBMI-Lock}
%%  If a \DBMI-lock is held by a \dt{process} which failed, the lock must be
%%  recovered and released.\\
%%  \INTERFACE{\DBMI}
%%\end{requirement*}
%%



% vim:ts=4:sw=4
