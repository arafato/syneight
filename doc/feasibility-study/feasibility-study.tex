%------------------------------------------------------------------------------
% Syneight - A soft-realtime transaction monitor.
% Copyright (C) 2003-2004 The Syneight Group.
%
% TODO: License.
%------------------------------------------------------------------------------

\documentclass[a4paper, 10pt]{book}

\setcounter{secnumdepth}{3}

\newcommand{\hv}{\fbox{\large\bf ?}}

\usepackage{times}
\usepackage{fullpage}
\usepackage{varioref}
\usepackage{epic}
\usepackage{ecltree}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{hhline}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{graphicx}

\parskip0.2cm

\renewcommand{\baselinestretch}{1.3}

\sloppy

\input{syneight/env.tex}
\input{syneight/definedterms.tex}
\input{syneight/abbreviations.tex}

\renewcommand{\dt}[1]{#1}

\begin{document}

% begin additional data ...
\begin{titlepage}


    \hrule\smallskip

    \textbf{Organization}

    \begin{itemize}
        \item \textbf{Introduction (Motivation and Goal)}
        \item \textbf{Overview of known Systems}
        \item \textbf{Detailed System Goal/Architecture} Derived from
            the Requirement Analysis
        \item \textbf{Implementation Strategies} Different Implementation,
            Iteration Plan, Associated Man-Power
        \item \textbf{Conclusion} To be determined ;-)
    \end{itemize}

    \hrule\smallskip

    \textbf{Concepts}

    \begin{itemize}
        \item weak isolation levels
        \item soft realtime
        \item peer-to-peer
        \item co-location optimization
        \item object-oriented
    \end{itemize}

    \hrule\smallskip

    \textbf{TODO}

    \begin{itemize}
        \item \textbf{Adding Change to Expandability.} Not only expanding
            stuff, also changing it, e.g., changing the path-finding algorithm
            or changing the AI. 
    \end{itemize}

    \hrule

\end{titlepage}
% end additional data ...

\title{\SYNEIGHTLOGO\\\vspace{1cm}Feasibility-Study}
\author{Georg Gottlob\\ Christian Schallhart\\ Helmut Veith}
\catcode`\$=12
\date{\texttt{$Id: feasibility-study.tex 294 2004-02-26 18:36:37Z
esdentem $}}
\catcode`\$=3
\maketitle

\newcommand{\ULTIMA}{\textsc{Ultima Online}\xspace}
\newcommand{\EVERQUEST}{\textsc{Everquest}\xspace}
\newcommand{\ASHERON}{\textsc{Asheron's Call}\xspace}
\newcommand{\ANARCHY}{\textsc{Anarchy Online}\xspace}
\newcommand{\DARKAGE}{\textsc{Dark Age of Camelot}\xspace}
\newcommand{\EARTH}{\textsc{Earth and Beyond}\xspace}


\newpage

\vspace*{4cm}

\section*{SUMMARY}

\bigskip

\hrule

\bigskip

%
% Mission Statement 
%

The goal of the \SYNEIGHT-project is to develop a server middleware for
large-scale realtime simulations, in particular for state-of-the-art Massively
Multi-player Online Role-Games (\MMORGS). \SYNEIGHT is currently developed by a
team at Technische Universitaet Muenchen (TUM). One possible application
running on top \SYNEIGHT is a so-called \MMORG. A \MMORG is an online game
played over the Internet providing a versatile and physically realistic virtual
reality (the ``virtual game world'') in which paying subscribers/players act
and interact with each other according to changing story backgrounds.

The primary technical challenge in \MMORG development is 
to accommodate a possibly large number of subscribers simultaneously 
in the virtual game world without compromising the inherent logic of
the game world, i.e., the quality of the game illusion. Both aspects
are crucial to the business model of \MMORGS.

The next-generation \MMORG is to accommodate up to 10.000 players 
simultaneously in a realistic virtual game world. This requirement  renders the
\MMORG application a {\em large-scale distributed client-server real time
application} with a {\em server cluster} on the server side, and potentially
hostile (``hacker'') client applications. 

The specific criteria of \MMORG applications cannot be satisfied by 
commercial off-the-shelf products, and motivate the development
of a next-generation server middleware for the game server cluster.
The purpose of this document is to evaluate the feasibility of the
\SYNEIGHT-middleware which is intended as the next-generation
\MMORG-middleware.


This document will answer two questions. The first question is
\textbf{``Which fundamental design goals have to be met by a
middleware which is projected as the next-generation middleware
basis for \MMORGS?''} This question will be addressed in Chapter 1 
of this document.
\begin{itemize}
    \item  We characterize the r\^{o}les of the user groups and customers 
        involved in a \MMORG-project, and present the common characteristics of
        \MMORGS as found in the most prominent available \MMORGS.

        Moving to a more technical level, we identify the major design decisions of a
        \MMORG with respect to its underlying middleware, and determine in which 
        ways a new middleware aimed at \MMORGS has the potential to improve on
        current solutions. Based on this analysis, we conclude the chapter by 
        stating the design goals of \SYNEIGHT.
\end{itemize}
%
The second question to be answered in this document is \textbf{``What
is the effort to develop such a middleware?''} We answer this
question by introducing \SYNEIGHT and by estimating its development
effort. 
\begin{itemize}
    \item In Chapter 2, we elaborate the technical structure of a
        middleware for \MMORGS based on a standard reference model for middleware
        systems. This allows us to relate the \MMORG middleware to state-of-the-art
        systems in other areas.
    \item Chapter 3 gives an architectural overview of
        \SYNEIGHT. The main goal of this chapter is to identify the
        different subsystems of \SYNEIGHT, focussing on their
        priority concerning the development time-line. 
        Based on this architectural analysis, we draw conservative
        conclusions about the development efforts.
\end{itemize}
%

\bigskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Conclusion}

In conclusion, the development of a next-generation \MMORG middleware  akin to
the \SYNEIGHT middleware is an inevitable technical step to achieve the system
performance and quality sought for by the gaming industry.

The \SYNEIGHT middleware provides all necessary features and facilitates a flexible
balance between technical and user requirements; most importantly, the \SYNEIGHT
middleware is an open and sustainable framework which allows to incorporate
technical innovations on both the hardware and the software side for years to
come.

\small

\tableofcontents

\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Design Goals for \MMORGS}


%
% What is a MMORG?
%

\section{The Virtual Game World}

\MMORGS enable a large number of players to explore a persistently stored
virtual game world using a fictionary character. Although the background
stories of these games include different genres such as the middle-ages,
fantasy, and science fiction, the principal appearance is always the same: 

A typically human-like character controlled by the player and observed
by the player on the computer screen is acting in a virtual game
world which may feature 3-dimensional geographical/architectural entities such as 
open landscapes, buildings and dungeons. The virtual game world is 
inhibited by a number of human controlled characters 
(so-called player characters or PCs) and
computer controlled characters (so-called non player characters or
NPCs). From the player's perspective, the main goal of his/her
interactions in the virtual game world is to develop (``improve'') 
the fictionary character by gaining experience, e.g., 
by exploring certain areas, by victories in fights with computer or human
controlled characters, by successfully completing certain tasks (``quests''), 
and by collecting new items to be used by the character or for
trading purposes. In addition, communication with other players is a
goal in its own right.
%

The fictionary characters are stored persistently in the virtual game world such
that the players can develop their characters over relatively long
periods of time. It is not uncommon that a character is maintained
over more than year.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{R\^{o}les and User Profiles in a \MMORG}

The technical development of a server middleware for \MMORGS is subject
to several different influences. In this section, we identify these 
different and contradicting influences and associate them with 
a class of r\^{o}les each having a specific user profile.
%
A more detailed analysis of these issues will be given in Section
\vref{sec:The-MMORG-Environment}.
%
\begin{description}
    \item[Players] are basically interested in a world which is as
        realistic as possible, i.e., the player wants a world which is a
        complex and closed but continuously changing and challenging system.
        Key features in this context are the following ones.
        \begin{itemize}
            \item The world is large, seamlessly constructed and freely
                explorable. Thus the ideal is to experience a world which has no
                artificial (un-)crossable borders.
            \item The world contains a lot of players -- humans provide
                complexity, continuous change and constant challenges.
            \item The game runs in realtime. 
                the realtime character of the game is essential to achieve any
                degree of ``reality''. 
            \item The world should be presented to the player in a stable and
                available fashion. 
            \item The underlying technology is not causing any ``hazards'' in
                the game play, i.e., whatever happens is explainable in terms of
                the game-logic itself.
            \item The system has to scale well with respect to the connection
                quality between the client and the servers since the game is
                played over the Internet. Different players will come with
                different uplinks, and even the quality of an established and
                ongoing connection might change over time.
            \item The player can play one out of several different strategies
                which are equally balanced, i.e., which are equally powerful in
                the game. In an ideal \MMORG, the player is not bound to a career
                such as becoming a warrior or a wizard but can combine different
                traits into a truly individual character.
            \item Finally, the world has to provide new zones and object-types
                to be explored on a regular basis.
        \end{itemize}
    \item[Game-Designers] design the zones and objects of the game, thus
        providing the background story. To do
        so, they are integrating the products of the artists and the
        developers into the running \MMORG. To maintain a creative
        work-style, they need to be protected from the details of the
        artistic and technical work. Thus it is important to them,
        \begin{itemize}
            \item that the produced art can be easily browsed, accessed and
                integrated into the game,
            \item that the underlying technology is stable and easily
                accessible,
            \item that the same technology is not overly restrictive and gives
                them enough freedom to work in a creative way,
            \item that they can implement and test new ideas quickly,
            \item and that they can influence the parameters of the game easily
                and deeply to keep the game play balanced.
        \end{itemize}
    \item[Artists] design the audio-visual appearance of the game. 
        Having typically not much programming background, they want a well-defined system to produce their art without
        being involved in the game design or being confronted with
        technology details. The art of a \MMORG is built in stages, where
        each is potentially done by different artists, for example, one
        artist can model the mesh of a house, while another one is texturing
        it. This process is modeled in a so-called art-pipeline. Thus
        artists need
        \begin{itemize}
            \item a simple interface to deliver their art to the game designers,
            \item an art-pipeline which is possibly unaffected by technology
                changes
            \item tools and plug-ins to standard 3D-graphic tools which allow
                them to produce the art effectively for the game in concern. 
        \end{itemize}
        The art-pipeline has to be encapsulated and should be treated as
        transparently as possible by any server middleware for \MMORGS since
        the art-pipeline is heavily dependent on the quickly changing
        graphics capabilities of today's PCs. 
    \item[Administrators] require the server cluster to be easily
        configurable and maintainable. To achieve this goal, the following
        features are required. 
        \begin{itemize}
            \item The hardware must be setup in a uniform way. To make this
                possible,
            \item the software must be self-organizing to a certain degree.
                Ideally, a server needs only to be registered in the clustering
                system -- the middleware chooses an appropriate task for the new
                node and assigns it.
        \end{itemize}

\end{description}
In the case of commercialization the following additional requirements would
have to be satisfied.
\begin{description}
    \item[] The companies have to keep the overall process focused and have
        aim at cost-effective solutions. They need to ensure that their
        prospective clients will be satisfied by the game, and at the same
        time, they need to enforce solutions of sufficen quality for this
        purpose. In addition to the above, they introduce the following
        special requirements for the development of a \MMORG
        server-middleware. 
        \begin{itemize}
            \item The middleware needs to scale in a very cost-effective manner,
                i.e., not only should it be possible to support large systems, but it
                must be possible to support systems at several scales in a
                cost-effective way. Moreover, the up-scaling of a \MMORG server
                system should not require the replacement of hardware but should
                mainly require the addition of new hardware. 
            \item The communication between the clients and the server systems
                is the biggest expense of a \MMORG which reaches a certain
                size. Therefore the overall middleware cannot waste place in
                messages which are exchanged between the clients and the server
                system.
            \item Finally, if a complete middleware is developed, business
                constraints will require the delivery of sensible intermediate
                results. Therefore a sensible iteration plan has to established
                and executed.
        \end{itemize}
\end{description}
%
The \MMORG development has to find solutions for all of these principal
interests. The development has to treat players, game-designers,
artists and administrators as customers -- these different ``customer
r\^{o}les'' in a \MMORG-setting are a primary challenge.
%

We see from the above that the customer groups typically express 
technically contradicting wishes, even within a group:
For example, while the player wants a game to be up and running without
interruption, the player also wants a game which is constantly
changing. The artists wish to deliver their art without caring for
details, the game designers want to access the ready-to-use art and
integrate into their new areas, which should be freely scriptable. At
the same time the game designers do not want to be held responsible
for server crashes, therefore the scripting must be free but not
critical for the server stability.

%
% Which MMORGS are out there?
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\MMORG Characteristics}
\label{sec:The-MMORG-Environment}

Current \MMORGS include \ULTIMA, \EVERQUEST, \ASHERON, \ANARCHY,
\DARKAGE and \EARTH. \ULTIMA was the first commercially successful
\MMORG. It has been developed based upon the successful stand-alone
Ultima games.  \EVERQUEST and \ASHERON followed \ULTIMA into this
market.  While these first generation \MMORGS displayed a weak
graphical representation in comparison with common stand-alone or
LAN-enabled games, the new generation \MMORGS reach the graphical
quality of classical games. Proponents of the new generation of
\MMORGS are \DARKAGE and \EARTH as well as the new versions of
\EVERQUEST and \ASHERON.

In this section, we describe the characteristics shared by most
\MMORGS. We will focus on the requirements for the server-systems,
abstracting from the audio-visual representation of the world at the player's
client application. For the purpose of completeness, we will also
include some remarks on the world-description on the client-side,
i.e., the client-side abstracted description of the part of the
\MMORG's world which is accessible to the client. 

\subsection{Active Objects} 
\label{sec:active-objects}

All entities in the virtual game world are internally represented
as {\em active objects} \cite{schmidt00}, i.e., objects which
are able to alter their state regularly without any initiating 
external event. Consequently, each \MMORG is populated by a large
collection of active objects.

Each entity in the virtual game world can be described as an object with an
associated control loop which runs concurrently in its
own thread continuously during the entire life-time of the object. In
this control loop, the object updates its own state based on its
internal state and the externally visible state of the objects which
populate the surrounding world.

Some objects may be unmodifiable by design, e.g. the walls of a building could
always look and behave in the same way. Such an object can be modeled by an
empty control loop. However, most objects in a \MMORG can be modified/destroyed
in some way, and thus they have to interact with their environment: for
example, walls which can be damaged are more attractive to the
player-community. Therefore we describe all objects of the simulated world as
active objects, i.e., the world of a \MMORG is database of active objects.

Active objects can be coarsely classified into the following categories,
in approximate order of complexity:

\begin{itemize}
    \item Physical obstacles including walls, furniture, etc.
    \item Movable items to be collected/possessed.
    \item AI-driven characters.
    \item Player-controlled characters.
\end{itemize}

The compound internal state of all active objects is called the {\em game
state}.

\subsection{Player-Controlled Objects} 

Some of the objects in the virtual game world are controlled by players.
%
The client of a subscriber needs internal state information about the
character which is controlled by this client as well as externally
visible state information of the surrounding objects. 
%
The distinction between the internal state information and the
externally available state information is important. For example, the
player is not allowed to know which items another character is
carrying.

Player controlled characters are modeled as active objects which
receive commands from the client and process them in their control
loop. In the control loop, they are also collecting information on
their surrounding world and prepare this information to be sent back
to the client.\\
%%
%%The inputs of a particular player are sent to the corresponding
%%objects in the world as further input for the next iteration of the
%%control loop. 
%%%
%%Besides the publicly known information, a player will
%%also need information on the internal state of his or her character.
%%Therefore, a human-controlled object requires a channel to send
%%information back to the player.
%
%

The connection management between the server system and the
client most adapt to variations in connection quality.
If the connection is slow, the server system should
assemble the updates which are sent to the client such that the
subscriber is still able to play the game. On the other hand, a good
connection should be exploited such that the virtual game world develops 
smoothly.


\subsection{Number of Objects} 

Today's \MMORGS contain up to 3000 player-controlled characters
simultaneously. To achieve a high quality
game experience, the number of non-player characters must be approximately ten
times as large. Summed up, it can be assumed that the world of a
competitive \MMORG contains {\bf at least 30.000 characters}
simultaneously.
%
In addition to the characters, there are a lot of less complex objects
including items which can be picked up and used by characters.
%
The number of these objects is hard to estimate since the number of
these objects depends heavily on the game contents. For example, if a
\MMORG allows its players to obtain their own virtual houses, the number of
items per character can go into the hundreds. However, it can be
typically assumed that there are at least 20 auxiliary objects per
character. Consequently, we need to expect to find at least 600.000
auxiliary objects in a competitive \MMORG.

In addition to these objects, there are objects which represent the
world itself. These objects are characterized by the fact that they 
cannot be moved. Although they cannot move and cannot be moved in the world,
some of them have a modifiable state. For example a door cannot be
moved, but has a state. 

%% Finally, the objects are rather abstract, i.e., each of these objects
%% will be implemented by a number of collaborating objects.


\subsection{Geographical Organization of the Virtual Game World} 
\label{sec:geographical-organization}

The virtual game world simulated in a \MMORG is organized as a set of
\emph{zones}. Within each zone, the objects can move freely and smoothly
in accordance with 
the underlying physical model. (Most games display a simplified
concept of gravity, but do not allow objects to move through each other, 
etc.) Depending on the quality of the game, changing the zone can be
very time-consuming and ``unnatural'' or quite transparent and logical
within the realm of the virtual game world.  As we will see, the attained
quality of zone transitions (called the level of ``seamlessness'') 
is a major design decision.

Technically speaking, zones are required to subdivide and distribute
the processing of the virtual game world over a number of nodes in the server
cluster. Each such zone handles 50 to 100 human controlled characters
along with the corresponding number of non-player characters, i.e., roughly 500
to 1000 AI-driven characters.

%% Because of the size of a \MMORG and the economic constraints imposed
%% on such a project, it is not an option to use one centralized server
%% to process the entire game-state. Besides that, such a solution would
%% not satisfy the requirements for scalability and availability.
%% %
%% Since different zones are potentially hosted by different nodes, the
%% synchronization between neighboring zones is a central technical issue
%% which allows a number of different trade-offs. The most conservative
%% solution is strict segregation, i.e., there is no direct interaction
%% between objects which reside in different zones. If an object moves
%% from one zone to another, the object is removed from the first zone,
%% and after some delay, placed in the second zone. The most ambitious
%% solution is a seamless world, i.e., the borders between zones are
%% totally transparent. In such a world, it is possible to observe all
%% events in a neighboring zone, to throw an item into another zone, or
%% even to place a large object such that it crosses the
%% border between zones.\\
%% %
%% The game design can be used to render high work-load scenarios at
%% zone-borders unlikely, for example, a zone border might be on a wide
%% plane, without anything which could attract players.

\subsection{Persistence of the Virtual Game World} 
\label{sec:persistence}

A key element of the success of \MMORGS is the persistence of the
virtual game worlds and the player characters populating these worlds. A
subscriber can ``improve'' his or her character(s) in the course of months
and even years.

At the same time, a lot of objects in a \MMORG -- actually the majority of
the objects -- do not require persistence. More specifically, it is not necessary
to keep the majority of the NPCs in a persistent storage since these characters
are mostly generated on a regular basis on-the-fly depending on the current 
population by the game system.

\subsection{Expandability and Changeability of the Virtual Game World}
\label{sec:expandability-changeability}

To keep the subscribers attracted to the game, the game designers and artists
expand and change the world of a \MMORG on a continuous basis.
Expansions and changes in a \MMORG include
\begin{itemize}
    \item the addition of new zones to the world,
    \item the addition of new items and NPCs to the world,
    \item the change of the AI-algorithms of NPCs,
    \item the change of game parameters which control the balance
        of the game, e.g., the strength of a particular weapon,
    \item the addition of new skills to the game system, e.g., car
        driving.
\end{itemize}
%
The expansion and change of the world is facilitated by the
game-designers. In the ideal situation, they can employ an integrated
editing environment to develop updates, test them and deploy them to
the running game. 
%
The middleware of a \MMORG must satisfy two requirements with respect
to level-design, namely
\begin{description} 
    \item[Changeability:] It must be possible to update the
        running game of a \MMORG at ease. The different types of changes
        listed above lead to updates of a very different technical
        nature. From the technical point of view, these updates can be
        subdivided into updates 
        \begin{itemize}
            \item which target only single objects, e.g. changing a global
                numerical parameter,
            \item and massive changes, such as updating the player-character
                class to provide a new skill.
        \end{itemize}
        The former can be facilitated by ordinary accesses to the
        game-state, however, the latter require dedicated updating
        mechanics. 
    \item[Composability:] The editing environment for the game-designers
        will evolve over time in any large scale \MMORG, i.e., the editing
        environment must be expected to be composed of a number of diverse
        but cooperating applications. Moreover, these editing applications
        will have different access patterns than those applications which
        run the game itself. Therefore, the middleware of a \MMORG must be
        designed for composability, i.e., it has to allow to design,
        implement and integrate a large number of diverse applications. 
\end{description}
%% 
%% %
%% First of all, an art-pipeline has to be established and integrated
%% into a middleware solution which serves a \MMORG. The art-team which
%% provides the audio-visual representation of the objects within the
%% game cannot be exposed to the details of the underlying technical
%% solution -- there must be a relatively easy way to place the
%% audio-visual representation for new objects into a repository for
%% further processing and integration. Game-designers who exercise only
%% scripting abilities are required to assemble these audio-visual
%% representations together with scripts and parameterization into new
%% objects for the world. It is also the job of game-designers to
%% build new zones out of already available more fundamental objects.\\
%% %
%% The middleware for a \MMORG has to define a trade-off between the
%% expressiveness and the safety of the interface which allows to
%% integrate new content into the world. In the ideal situation, there
%% are interfaces at different levels, for example there should be a
%% fairly simple scripting interface and a more expressive but also 
%% opener low-level interface which allows to integrate new primitives
%% into the scripting environment.
%% 
%% Besides expansion, a \MMORG will also be subject to change. For
%% example, a new skill (e.g.~car driving) might have to be made
%% available to the characters. To do so, the representation of all
%% characters must be changed. Possible example are the change of
%% the AI-algorithms of NPCs or the change of the audio-visual
%% representation of an object.\\
%% %
%% Again, it is critical to define a clear-cut set of layered interfaces
%% to facilitate these changes. Also, it is necessary to decide which 
%% changes can be executed dynamically. If there are changes which are to
%% be executed during full operation, the associated synchronization
%% issues have to be resolved.
%% 
%% Summarized, a \MMORG must be expanded in qualitative (by adding new
%% objects) and quantitative (by using the existing basic objects to
%% create new zones) terms and must be changed on various levels.\\
%% %
%% These tasks are executed through the interface of the art-pipeline
%% which allows its users (mainly artists and game-designers) to access
%% and modify the game's objects and their classes in a unified way to
%% generate a stream of updates.  Because of the different
%% representations to be used on the client- and on the server-side,
%% these updates must be processed further to
%% generate an update-stream for the clients and for the server-system.\\
%% %
%% Once a server-update and a corresponding client-update is generated,
%% it has to be tested on an internal test system. As a next step, the
%% client-updates must be deployed to download-servers to allow the
%% clients to download the update before it is required to enter the
%% game. The last step is the application of the update to the
%% server-system which makes the update effective.
%% %
%% The technical and organizational design of this process is the central
%% issue for maintenance of a \MMORG and is therefore the economically most
%% prominent factor for the success of the game:
%% \begin{itemize}
%% \item Fast paced and smooth expansion and change attract and keep the
%%   subscribers attracted to the game.
%% \item This process involves the vast majority of contributors to a
%%   successful \MMORG. Because of a \MMORG's size, the number of artists
%%   and game-designers outweighs the number of developers by far.
%%   Hazards in their work would cause the waste of large financial
%%   resources.
%% \end{itemize}
%% 

\subsection{The \MMORG as a Realtime System}
\label{sec:soft-realtime}

A \MMORG is a realtime application, since the player expects immediate,
i.e., time-bounded, responses from the server-system. 
The quality loss incurred by
occasional deadline misses however is tolerable for the players. Thus a
\MMORG can be considered a soft realtime application \cite{kopetz97}.

The realtime character of a \MMORG has consequences
on all levels of the \MMORG-system: 
\begin{itemize}
    \item The server-system which processes
        the game-state is expected to respond within a given period of time.
    \item The communication between the client and the server-system should
        adhere time-bounds.
    \item The client itself must be able to represent
        the world based on the server-provided information within a fixed
        time-bound. If the client did not receive all expected information in
        time, then the client is required to predict the answers of the
        server-system.
\end{itemize}

%
%
Therefore the middleware must be designed to meet the following two
requirements.
\begin{description}
    \item[Soft-Realtime Communication:] A central responsibility of the
        middleware is the realtime communication between the different nodes
        which constitute the cluster that processes the game state. Since
        special realtime networking hardware cannot be used in a
        \MMORG-server system, the middleware has to be designed in such a way that
        the communication overhead can be estimated. %XXX
    \item[Independent State Information:] The applications of a
        \MMORG-system which collaboratively form the current game state
        should run under soft-realtime constraints. The temporal behavior of
        these applications must be as independent from each other as
        possible, i.e., if one of the running applications misses a deadline it
        should not affect the timing of the other applications. In other words,
        the middleware must be designed such that its applications are
        composable with respect to their timing behavior.\\
        %
        Thus each application needs to maintain enough state information to
        work independently. This state information has to be updated on a
        regular basis by the underlying middleware.
\end{description}

%
%% Since a middleware for a \MMORG must be able to process the
%% game-state in a distributed fashion, the middleware must be able to
%% communicate different aspects of the game-state under soft realtime
%% constraints to achieve an overall realtime characteristic.\\
%

%% 
%% should not be affected too much
%% by the temporal behavior of other concurrently operating applications,
%% i.e., they should work on outdated information as long as possible.
%% %
%% To achieve such an independence, a middleware for \MMORGS should be
%% state message oriented and not event message oriented. 
%% % CITE KOPETZ

\subsection{System Dependability}

Most current \MMORGS are not very dependable -- a fact which
is frustrating to subscribers. Subscribers are mainly complaining
about three forms of dependability incidents:
\begin{description}
    \item[Unexpected Down-times:] To wait for a server system to come up
        again is one of the most annoying situations for subscribers.
        Today's \MMORGS go down several times per month and usually require
        the subscribers to wait for a period up to half an hour.
    \item[Data Loss:] If a server crashes, usually the players which were
        served by this particular server lose some of their game-play, i.e.,
        the effects of the last minutes or even hours are potentially undone
        in such situations. 
    \item[Large Scale Rollbacks:] Moreover, today's \MMORGS are forced to
        issue large rollbacks regularly -- in each of the current \MMORGS
        rollbacks which cover a period of days appear at least once a year.
\end{description}
Such events are considered highly disappointing and frustrating for
a subscriber who had been ``working'' on a certain quest for a week
and finally finished it successfully and loses all the improvements
gained during this victorious quest.
%

%
%
Since hardware and software faults are unavoidable, the middleware of
a \MMORG must be able to handle node-failures. The loss of some
seconds of game-play is perfectly acceptable, as well as high latency
during the re-establishment of a new stable state. Thus, a middleware
for \MMORG is not required to be strictly fault-tolerant. However, a
middleware for \MMORGS must be designed to enable the following
features:
\begin{description}
    \item[Replication of Critical Data:] A \MMORG must replicate its most
        important data, i.e., the objects which constitute the player
        character and the items which are owned by the characters. The
        replication of the critical data is required to keep the loss of
        game-time low when a server fails due to software or hardware
        faults. 
    \item[Regular Snapshots:] Snapshots of the database of \MMORG (or at
        least of its most important objects) must be stored on a backup
        medium in regular intervals. Snapshots are required in addition to
        replication to counteract software faults which may cause permanent
        errors in the database. 
    \item[Node Restart:] If a cluster node fails, the node itself should be
        restarted or even better, the tasks of the node should be assigned
        to an alternative node. It is important that a single failing node
        does not cause a down-time of the entire \MMORG. There are several
        different ways to handle this issue, and we will discuss them in
        Subsection \vref{sec:fault-toler-model}.
\end{description}
%


%% %
%% Therefore a middleware for \MMORGS must be able to deal with server
%% failures which might be caused by hardware or software faults. 
%% %
%% On the other hand, it is not necessary for the system to react to
%% failures without any client-visible effect. 
%% %%
%% %%it is not necessary for the system to react to failures
%% %%which have 
%% %%
%% %%to cope with failures without any
%% %%client-visible consequences. If a server fails which was responsible
%% %%for serving a particular client directly or indirectly, the client is
%% %%allowed to observe fluctuations. 
%% %%
%% The loss of some seconds of game-play
%% is perfectly acceptable, as well as a high latency during the
%% re-establishment of a new stable state.\\
%% %
%% % Definition of fault
%% %
%% More important is the avoidance of error propagation, i.e., a fault on
%% a particular server should not cause other servers to enter a fault
%% condition.\\
%% %
%% This implies that a least a portion of the game state has to be
%% replicated and constantly updated on more than one server, that the
%% failure must be detected by the server system, and that the middleware
%% restarts the tasks which failed on alternative hosts.
%% %
%% The availability and the scalability (discussed in the next
%% subsection) make it necessary to employ a highly-parallelized
%% approach which allows the dynamic rescheduling of the involved tasks.


\subsection{System Scalability}
\label{sec:scalability}

A successful \MMORG can reach subscriber numbers in the
millions\footnote{Lineage \textbf{MISSING}}. However, in the case of
such huge subscriber numbers, a number of independent instances of the
same \MMORG are maintained simultaneously -- currently not more than
several thousand players are kept within one world-instance.
%
Naturally, the population of an upcoming \MMORG is a lot smaller and
can be assumed to range at approximately 10.000
subscribers.\footnote{Subscribers are expected to spend 10\% of their
time within their \MMORG, thus the number of clients ranges between
1000 and 10.000.}
%
To reach a subscriber-base of this order, the MMORG-system needs to
scale well -- it is not enough to handle large world sizes, but it is
also necessary to handle the intermediate stages in a cost-effective
manner. Based on these numbers a \MMORG server-system must scale at
least in the order of one magnitude in a continuous fashion.

To initiate such growth, it is necessary to expand the world
constantly, see Subsection\vref{sec:expandability-changeability}, in order
to both
keep old players content and to have space for more subscribers.
Besides these efforts to expand the world, the underlying platform
needs to grow as well.
%
For economic reasons, it is necessary to start with a correspondingly
small system, which is being scaled up over time. 
%
%%Thus a trade-off between the necessary over-sizing of the hardware
%%platform and the level of distribution has to be settled. The more
%%fine grained the distribution, and the smaller the associated
%%supporting hardware unit, the less over-sizing of the hardware is
%%necessary. 

\subsection{Chatting Facilities}

Subscribers of \MMORGS make heavy use of chatting facilities to
communicate with each other. The
work-load generated by chatting is significant, and mostly
independent from the rest of the \MMORG's world. Besides the standard
set of features for common chat-systems, a \MMORG's chat-system needs
to include a geographically oriented channel, i.e., a channel where an
object can read all messages which were sent to the system from other
nearly located objects.
%
Note that not only human-controlled characters may send and receive
messages but also NPCs.


\subsection{Hostile Clients} 
\label{sec:players-are-potential-adversaries}

It is important to note that the subscribers have to be treated as potential
adversaries which emply modified client software. A substantial  fraction of
computer game players tend to cheat whenever possible. Such attacks do not only
disturb other subscribers who are playing honestly but are also endangering the
server-system.

As an illustrating example we describe an incident which occurred
in 2001 in \ASHERON. The attackers'
goal was to duplicate a set of given items. To do so, they moved these
items from one server to another. But with a fine-tuned timing, the
attackers were able to crash the first server just after leaving it.
Therefore, the item was still stored in the backup of this server and
at the same time in the hands of the player's character, thus it has
been duplicated. Once the reboot of the crashed machine had finished,
they attackers returned to obtain the duplicate. This procedure had
been repeated often enough to catch the attention 
of the administration team of \ASHERON.

To deal with such attacks, each message sent to the server system must
be checked for syntactic and semantic correctness. The system must also
check whether the player has the access permissions which are required
for each of the requests in the message.

For the same reason, the complete game-logic has to reside on the
server system, the subscribers' PCs have to be treated as dumb
IO-terminals\footnote{The subscriber-controlled client software
usually contains parts of the game-logic to allow client-side
prediction of the server-system and to graphically enhance the world-description
which is provided by the server-system.
%
But none of the client-side decisions are allowed to affect
the game-state of the server-system without checking their
consistency with the game-state of the server system.
%
For example, the client can predict that the player is allowed to
walk freely inside of a room. But the client is not allowed make
this decision, it has to ask the server whether the positioning of
the player character was correct.}  and it has to be assumed that
the client application is modified and hostile.
%


\section{Major Design Decisions}

In this section, we exhibit the most critical design issues of a
\MMORG with respect to its middleware. The major design questions to be
settled in a \MMORG-project are the following.
\begin{enumerate}
    \item How seamless is the virtual game world? 
        %% This is the most
        %%   important design decision to settled in any \MMORG-project -- all
        %%   other decisions are least influenced by the degree of seamlessness
        %%   of the \MMORG. 
        \item Which change procedures are supported?
            %% The change procedures
            %%  which are supported by a \MMORG-platform have a strong impact on the
            %%  underlying middleware since global updates require the middleware to
            %%  search its database to identify those entities which are subject to
            %%  change. In addition, the updating must be synchronized with the
            %%  ordinary operation of the \MMORG server system.
            \item Which fault-tolerance model is supported?
                %% There are different
                %%  ways to achieve fault-tolerance in a \MMORG. The fault-tolerance
                %%  model is closely interrelated with the seamlessness of the world
                %%  since the fault-tolerance is built upon the 
                \item Which strategy is employed to achieve scalability?
            \end{enumerate}

            %% 
            %% 
            %% , i.e., we will establish
            %% a connection between subscriber-visible features and correspondingly
            %% internally employed technology. Again, we will focus on the gaming
            %% domain. We start with the main trade-off to be settled in any
            %% \MMORG-project: \textbf{How seamless is the world?} All other
            %% decisions are at least influenced by the \MMORG's degree of
            %% seamlessness.

            \subsection{Seamlessness}
            \label{sec:seamlessness}

            In subsection \vref{sec:geographical-organization}, we described the
            geographical organization of the world of a \MMORG into zones. The
            reason for introducing zones was twofold, 
            \begin{itemize}
                \item first, it is a unit of organization for the game-design,
                \item and second, it is used as a unit for server processing -- the
                    complete world is by far too large to be processed by a single
                    machine. Instead a single node processes just one or several zones. 
            \end{itemize}
            %
            Players do not want to experience these
            borders, since (1) they appear unnatural within the realms of the game, 
            and (2) they hinder a quick and fluent game play. 
            %
            Therefore, in an ideal \MMORG, the zone-borders are not noticeable to
            the player -- usually such a world is referred to as seamless world. 
            %
            We will now classify the seamlessness of a \MMORG into
            five different levels which impose different characteristics to the
            underlying middleware solution. 
            %
            \begin{description}
                \item[Continuous World:] In a continuous world, zone borders are
                    unobservable for the player. Thus, large objects can be partly
                    placed in one zone and a neighboring zone, objects can move between
                    zones without any noticeable delay and naturally the dynamic and
                    static scenery of a zone can be observed from any neighboring zone.
                \item[Seamless World:] In a seamless world, it is possible to observe
                    the static as well as the dynamic scenery of any neighboring zone.
                    It is also possible to enter a neighboring zone within a time period
                    which is in the range of one processing cycle of a zone\footnote{In
                    the processing cycle of a zone, the control loops of all active
                    objects of that zone are executed once. The processing cycle of a
                    zone should not take more than 100 milliseconds.}. The
                    representation of a neighboring zone might be slightly out of
                    synchronization but is not allowed to stay behind for more than one
                    processing cycle.
                    %
                    Summarized, in such a world, the zone borders are well observable
                    but do not hinder the player in gaining the experience of a
                    seamlessly connected world.
                    %
                    Furthermore we distinguish between the following two forms of a
                    seamless world:
                    \begin{description}
                        \item[Strongly Seamless:] In this scenario, it is possible to
                            interact with an object which is located at the other side of a
                            zone border. For example, it is possible to pick up an item which
                            is located in a neighboring zone. 
                        \item[Weakly Seamless:] A weakly seamless world does display the
                            active population of neighboring zones, but does not allow to
                            interact with the objects across the border. Thus, a player can
                            see an item which is on the ground of a neighboring zone, but the
                            player is unable to pick up this item.
                    \end{description}
                \item[Segmented World:] We call a world segmented, if it is not
                    possible to observe the dynamic scenery of any neighboring zone and
                    if the change from one zone to another is handled quickly, i.e.,
                    within five seconds.
                    %
                    An example for such a world is \DARKAGE, where slightly blue but
                    transparent walls segment the world. If the player looks through the
                    wall, he or she can see the landscape or room but not the
                    objects which are currently populating this zone.
                    %
                    Such a world is not allowing the player to experience a seamless
                    word, but the game-play is still relatively fluent. 
                \item[Segregated World:] A world is called segregated if it is
                    impossible to observe the dynamic scenery of neighboring zones and
                    if entering another zone takes more than five seconds.
                    %
                    Example for such games are \ASHERON and \ANARCHY, which
                    display zone switching times of more than 20 seconds. Besides the
                    lower immersion of such a game, the sheer time which is necessary to
                    move through the world is considered an inconvenience. 
            \end{description}
            %
            %%
            %%
            %%This goal is not reached by any of the currently available
            %%\MMORGS because of the implied complexity in terms of synchronization,
            %%replication and change management.\footnote{These consequences were
            %%  outlined in subsections \ref{sec:replication},
            %%  \vref{sec:synchronization} and
            %%  \vref{sec:change-management}.}.\\
            %%%
            %%In general, the more seamless the world is, the more fine-grained
            %%configuration options and the more differentiated primitives have to
            %%be provided by the middleware.
            %%%
            %%The aimed level of seamlessness is the most important trade-off to be
            %%settled. The following scenarios could be identified:
            %
            %
            We outline now the impact of this design decision on the underlying
            middleware. The seamlessness of the world determines the replication
            and synchronization primitives of the underlying middleware. 
            \begin{itemize}
                \item {\bf Seamless} \MMORGS need to be built upon a
                    middleware which enables the nodes processing a certain zone to access
                    the state of the neighboring zones regardless of their distribution
                    over the cluster, concurrently without being blocked and without
                    blocking the node which processes the zone.

                    The distinction between a strongly and a weakly seamless world
                    translates into a middleware which allows to access the state of
                    neighboring zones in a read/write and in read-only manner,
                    respectively.
                    %
                    The read-only replication of the state zones can be handled in a
                    very coarse-grained fashion -- a whole zone can be treated as a unit
                    with respect to replication and synchronization.\\
                    %
                    However, to manage the read-write access to states of neighboring
                    zones, a more fine-grained approach is necessary since the
                    transactions which involve objects of more than one zone need to be
                    synchronized such that all zones can be processed in time -- it is
                    not an option to lock a neighboring zone entirely. Thus replication
                    and synchronization must be handled on a per-object basis.
                \item The main difference between a \textbf{continuous} and a strongly
                    seamless world is not in the realm of the middleware but at the
                    level of game-logic itself.  The prototypical problem at the level
                    of the game-logic are objects which are simultaneously located in
                    two zones.
                    %
                    Aside from the game-logic, the difference between a continuous and
                    strongly seamless world is only a question of efficiency -- if the
                    complete server system is efficient enough to keep all nodes
                    mutually in synchronization, then the \MMORG is continuous.
                \item In contrast, \textbf{segmented} and \textbf{segregated} worlds
                    can be built on a simpler basis because of the strict borders of the
                    zones. A zone is only handled by one node -- possible replication
                    mechanics are only motivated by error-handling requirements. The
                    only interaction between zones is the movement of objects from one
                    zone to another, and since such zone switches are allowed to take
                    several seconds, a simple transaction system is good enough.

                    A segregated world is not considered to be state-of-the-art and must
                    be avoided. To reach at least the level of a segmented world, it is
                    necessary to avoid renewed connection establishment over the
                    Internet when the player changes the zone, i.e., to employ
                    connection servers.
            \end{itemize}
            %
            Currently no game on the market is able to support a continuous or
            even a weakly seamless world. The reason for this situation is simple
            -- a seamless world would require a middleware solution which supports
            sophisticated synchronization, replication and persistence
            primitives.

            \subsection{Change Management} 

            The changes management procedures supported by the middleware must be 
            planned from the very beginning as they have a strong impact on the required
            structure of the employed middleware.

            In this subsection we are focusing on systematic updates which consist of a
            large set of individual updates. For example, we are not interested in
            changing the strength of a single NPC (say, a spider) but in changing the strength
            of all spiders in the game. That is to say, we are focusing on
            \emph{global updates.}
            %
            We speak about a global update if the \emph{set of individual updates}
            is not explicitly enumerated but specified in an implicit way. In the
            example above, the individual objects are specified implicitly by
            their type.

            As a major design decision, it has to be decided which change
            mechanisms have to be supported by the middleware. 
            In this subsection we describe five different criteria to classify
            different updating capabilities of a \MMORG. A single change
            mechanism can be identified by answering each of the following five
            questions. 

            %
            %


            \subsubsection{How does the update interfere with the game-play?}
            \label{sec:how-does-update}

            Different possibilities include
            \begin{itemize}
                \item no observable interruption, 
                \item short interruptions and non game-inherent behavior in a period
                    of some seconds,
                \item a complete freeze of the game over a short period of time,
                \item or the complete shut-down of the gaming domain's services for
                    a certain period of time.
            \end{itemize}
            %
            We speak about an \emph{online update}, if it is effective within
            several seconds.

            In analyzing the impact of the chosen change management mechanisms,
            we focus on the online changes, i.e., changes which are effective
            within several seconds. We disregard \emph{offline changes} since
            \begin{itemize}
                \item they can access the complete database exclusively,
                \item and they can employ classical indexing and querying techniques to
                    search the database. 
            \end{itemize}

            In the case of \emph{online changes}, these updates have to be
            executed in a \emph{deferred} manner, i.e., the complete update
            cannot be executed at once but has to be distributed in time. But if
            the update is deferred, the problem arises that \emph{the set of
            objects which are subject to change changes over time}, e.g., if
            all spiders should become an increased strength, the set of
            individual updates contains one individual update for each spider.
            However, during the deferred execution of the update, new spiders
            are generated and other
            die.\\
            %
            Therefore an online update the most suitable way to implement online
            changes it the \emph{installation of a filter} -- whenever an object is
            accessed which is subject to the update, it is updated on the fly.

            \subsubsection{Which objects are subject to the update?}

            The most important way to specify the set of individual updates to be
            executed is certainly by listing the types of the objects which
            are subject to an update.

            In the case of online changes, the middleware is required to determine
            quickly whether an object is subject to a pending update or not --
            complex queries cannot be implemented in such a scheme. 
            %
            The type of object can be determined quickly and will be required in
            most cases. At the same time, the implementation of the update itself
            can apply further predicates to determine whether the update is
            applicable or not -- and in the latter case do nothing.
            %
            Therefore, we consider a list of object-types as sufficient
            to specify the set of individual updates for online changes.

            \subsubsection{How many objects are changed by one individual update?} 

            Each individual update can involve a single object or a whole group of
            somehow interrelated objects.

            For example, a player might be represented not by a single object but
            by a group of objects. Possibly it is necessary to update
            each such group of objects which constitute a player in the game
            within an individual update for the sake of consistency. The objects
            of a player might be closely coupled and it could be impossible to
            update each object of this group without destroying
            the integrity of the database.

            If more than one object can be changed by one individual update on the
            fly,
            \begin{itemize}
                \item then the synchronization of the update becomes more complicated,
                \item and the querying for those object-groups which are subject to an
                    individual update offers new options, e.g., it could be queried
                    for all pairs of objects $a$ and $b$ where  $a$ is of type $A$, $b$
                    is of type $B$ and $a$ references $b$. However, it is
                    questionable whether it is possible to implement any querying scheme
                    beyond simple type-matching. 
            \end{itemize}

            \subsubsection{Does the update involve a change of the state or the type?}
            \label{sec:does-update-involve}

            Next we can distinguish between updates which are only changing the
            state of the objects during the update versus updates which are also
            changing the underlying type of the updated objects.

            The latter will become necessary during the evolution of the game, for
            example when new abilities are added to the game objects (such as new
            skills), or when the decision making procedures of the NPCs are
            changed.

            If the middleware has to support type-changes in online updates,
            \begin{itemize}
                \item then the middleware must allow the application to issue a type
                    change of an existing object \emph{without} losing its identity to
                    ensure referential integrity.
                \item If, moreover, the world is seamless, then instances of the same
                    objects of the old and of the new type might coexist because several
                    instances of the same object will be replicated over a number of
                    nodes.
                    %
                    Therefore the middleware must synchronize between instances of the
                    same objects of the old and of the new type. 
            \end{itemize}

            \subsubsection{How isolated is the update?}

            If the server system of a \MMORG is stopped during the update, the
            whole update can be executed in complete isolation, i.e., all
            transactions before the interruption use the original game-state and
            all transactions after the update use the updated game-state.\\
            %
            But if the game is going on during the update, the question of
            isolation arises, i.e., whether ordinary transactions can see any
            intermediate state caused by the update. There are three
            main-variants:
            \begin{description}
                \item[The update is not isolated at all,] i.e., the ordinary processing
                    of the game-state can see intermediate states.

                    This is certainly the simplest and most efficient way to synchronize
                    an update, however it is not sufficient for most cases. 

                \item[Each individual update is isolated.] The periodic processing of
                    the game-state can simultaneously access previously updated objects and objects
                    which will be updated in the future -- but all objects which are updated by one
                    individual update are changed in an isolated manner.

                    This scheme will be required if more than one object is affected by
                    an individual update to provide the ongoing processing of the
                    game-state with a sound view on the database. 

                \item[The complete update is atomic,] i.e., all operations before a
                    certain moment in time see the old version, and all operations
                    after this moment see the new version.

                    Such a model is required if an update has a very strong impact on
                    the game-state and the co-existence of updated and original entities
                    is intolerable.

                    This requires at least a brief suspension of all ordinary
                    operations, to synchronize the moment when the update becomes
                    effective between all involved nodes -- and an additional
                    synchronization primitive in the middleware. 
            \end{description}


            \subsubsection{Summary}

            It is important to build the change management on a selection of
            general change mechanisms, i.e., to avoid a change management which
            is based upon special strategies such as player-character updating, zone
            adding and NPC-AI-changing. While it is appealing to follow such an
            approach, it will certainly find its limitations in the course of the
            life-time of a \MMORG. 

            A general change management which includes almost all of the
            possibilities which are sketched above can be based upon two
            fundamental features, namely
            \begin{itemize}
                \item a filter mechanism as sketched in \vref{sec:how-does-update}
                    which executes individual updates on all objects which are of a
                    certain type in a deferred manner. The implementation of the
                    individual update can be provided by the application, for example in
                    the form of 
                    a dynamically linked shared library.
                \item a special operation to change the type of an object, as
                    described in \vref{sec:does-update-involve}.
            \end{itemize}
            % 
            %
            The remaining issue is the synchronization of the updating, where we
            have to distinguish between
            \begin{itemize}
                \item a \textbf{seamless} or \textbf{continuous} world, which requires
                    already a sophisticated transaction processing framework to
                    synchronize the concurrent processing of the different nodes.

                    In this case, the synchronization of the change management can be
                    based on the common transaction framework. 
                \item and a \textbf{segmented} or \textbf{segregated} world which
                    comes with a simple synchronization framework.\\
                    %
                    In this case, the best strategy is to issue the deferred updates on
                    each node separately and to synchronize this operation with simple
                    synchronization methods. To avoid hazards caused by
                    the simultaneous processing of objects which have a different
                    updating status, the zone borders could be closed until all nodes
                    started the deferred update. 
            \end{itemize}

            %%
            %%%
            %%
            %%%
            %%%% 
            %%%% The complexity the synchronize of the change management is greatly
            %%%% influenced by the seamlessness of the world. If the world is seamless,
            %%%% then even ordinary operations require complex synchronization
            %%%% primitives, as described in subsection \vref{sec:synchronization}.  If
            %%%% the world is not seamless, it is possible to execute updates on a
            %%%% node-per-node basis -- which makes the synchronization in general and
            %%%% the synchronization of the change management easier.
            %%%% 
            %%
            %%
            %%%
            %%The mechanisms for on the fly change management can be implemented by
            %%providing a way to place a filter into the database which contains the
            %%update-logic. On access to an arbitrary entity, such a filter
            %%determines whether the entity is applicable to the update or not, and
            %%if yes, would execute the update as a transaction which is committed
            %%before the entity is handed over to the application.
            %%
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %%Besides these two basic operations, we have to consider the change of
            %%already existing entities. To classify the different supported change
            %%procedures, we use the following five characteristics:
            %%
            %%
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            %%%
            %%The major problem besides synchronization is that the middleware must be
            %%able to determine quickly whether an entity is subject to an update or
            %%not. If the updates are complex, i.e., they take a substantial amount of
            %%processing time, then the updates have to be executed in a
            %%\emph{deferred way,} that is, each individual update is executed just
            %%before a corresponding entity is handed over to the application.
            %%%
            %%The simpler approach is to execute all individual updates at once
            %%would require either short update evaluations or would lead to
            %%client-visible fluctuations. 
            %%
            %%All current \MMORGS are going offline intentionally at least once a
            %%month for at least two hours. In addition, today's \MMORGS can be
            %%expected to crash at least twice a month leading to brief down-times
            %%(5-30 minutes). These intentional and unintentional down-times can be
            %%used for more extensive offline updating. 
            %%
            %%The trade-off to be defined here is to choose the change management
            %%models to be supported by the underlying middleware solution according
            %%to the classification in subsection \vref{sec:change-management}.
            %%%
            %%Since all current \MMORGS use down-times for facilitating their
            %%updates, it is acceptable to follow this strategy. In such a situation
            %%a lot of updates will be bunched together, thus it is important to
            %%execute the updates quickly and therefore especially the querying of
            %%the entities to be updated has to planned. The duration of the
            %%individual updates are inherent to themselves, i.e., not general
            %%provisions can be made to speed them up.\\
            %%%
            %%If such a strategy is not implementable, we have to distinguish
            %%between segmented and seamless worlds. In the case of segmented (or
            %%even easier, segregated) worlds, we can execute some updates on a
            %%zone-per-zone basis, i.e., one zone after the other is shut down,
            %%updated, and switched online again. Players can be teleported away if
            %%necessary. Still, there remain other updates where such a procedure is
            %%not sufficient, for example the updating of the player-characters. But
            %%it might be most cost-effective to employ maintenance shut downs for
            %%these cases.\\
            %%%
            %%In the case of seamless worlds, the situation is more complex. Still,
            %%one could switch of zones, but the effect would be much more
            %%annoying. Additionally, complex synchronization mechanisms must be
            %%provided by the middleware in any case\footnote{See the last
            %%  subsection.}. Therefore, in a seamless world, it appears to be
            %%appropriate to use an online updating scheme -- the only added
            %%complexity is the requirement to integrate a filter mechanism, i.e.,
            %%whenever an entity is accessed, it is checked whether this entity is
            %%subject to an update. 
            %%


            \subsection{Fault-Tolerance Model}
            \label{sec:fault-toler-model}

            Every \MMORG must replicate and backup its most important data and
            must be able to restart a failed node. A fault-tolerance model for a
            \MMORG can be elaborated by answering two questions:
            \begin{description}
                \item[Which data is replicated?] A \MMORG must at least replicate and
                    backup the objects which represent the player characters and its
                    property, e.g., its weapons, shields, or houses.

                    If only these essential objects are replicated, then a node failure
                    requires all zones which were hosted by the corresponding node to be
                    reinitialized, i.e., an initial set of NPCs and items will be
                    generated and distributed in these zones. 

                    Naturally, a \MMORG can follow various strategies with respect to
                    the amount of data it is replicating, for example a \MMORG could
                    replicate all characters (not just player characters but also NPCs),
                    or could replicate the entire game-state of each zone.
                \item[How long does it take to restart a zone?] Based on the
                    replicated data, a \MMORG has to restart all zones of a failed
                    node. To do so, it can 
                    \begin{itemize}
                        \item simply try to \textbf{restart the crashed node} and
                            reinitialize the affected zones on the same node.  This approach
                            might be time consuming and moreover, if the node crashed because
                            of a hardware fault, the attempt to restart the node will fail and
                            the zones remain consequently unavailable.
                        \item Second, it can \textbf{reassign the affected zones to other
                            nodes.} Depending on the nature of the replication mechanisms,
                            this approach can make the affected zones quickly available
                            again.
                    \end{itemize}
            \end{description}
            %
            The fault-tolerance model is heavily dependent on the underlying
            redundancy mechanisms, i.e., the employed replication model. Because
            of the massive impact of the question of seamlessness on the
            implemented replication model, the fault-tolerance model can only be
            determined with respect to the level seamlessness.

            \subsubsection{Segmented and Segregated Worlds}

            In the case of a segmented or segregated world, the only purpose of
            replication is fault-tolerance -- the critical data of a single node
            is replicated for case of a node failure.
            %% If the cluster contains only machines which fulfill a given set
            %% performance criteria\footnote{It is unrealistic to assume that these
            %%   machines will be identical, it is just a matter of time until a
            %%   slightly heterogeneous machine landscape establishes itself.},
            %% %
            %% then 
            We can identify two main strategies:
            \begin{description}

                \item[Distributed Replicas:] Each node which is actively maintaining a
                    zone could be associated with a perfect replica (a node
                    which is \emph{replica deterministic}), i.e., a machine which is
                    continuously kept in exactly the same state as the active machine.
                    %
                    There are two different strategies to maintain such replicas.
                    \begin{description}
                        \item[Parallel and Indepedent Computation:] The replica receives the
                            same inputs as the active machine, and maintains an exact copy of
                            the original state by parallel and independent computation.\\
                            %
                            This might sound easily achievable, however, it is highly
                            non-trivial to arrive at this goal and it must be rooted in the
                            overall architecture of the underlying middleware solution.
                            %
                            Examples for the problems in this setting are 
                            \begin{itemize}
                                \item the synchronization of the random-number generators, 
                                \item the need for synchronous software-updates,
                                \item different forms of timing problems (deviation between CPU and
                                    realtime clocks, different oscillators causing the replicas to
                                    drift astray)
                                \item the guarantee that node-internally running threads produce no
                                    race-condition (in the sense that differing scheduling produces
                                    different results).
                            \end{itemize}
                            Basically, the input must completely determine the
                            internal state
                            %%h-state\footnote{This h-state is the history state, i.e., the
                            %%  internal state, caused by the series of inputs and by the internal
                            %%  processing.}
                            %%
                            of the node, such that the same inputs and produce
                            the exactly the same output as a function of the input and the
                            internal-state.\\
                            %
                            Since slightly different timing behaviors are unavoidable, it is
                            necessary to keep the replicated nodes in synchronization by
                            exchanging a heart-beat and using a common logical time.\\
                            %
                            For an overview over the problems and solutions with respect to
                            replica determinism, see \cite{kopetz97}, section 5.6.
                        \item[Leader-Follower Protocol:] 
                            There is another way to achieve
                            fault-tolerance in the context of a segmented world which does not
                            rely on the symmetric computation of two mainly independent nodes,
                            but which is based upon the decisions of the active machine. 

                            These decisions have to communicated to the passive one(s). This
                            strategy is referred to as \emph{leader-follower
                            protocol}\footnote{Not to be confused with the leader-follower
                            design pattern of \cite{schmidt00}.} and is also mentioned in
                            \cite{kopetz97} and described in detail in \cite{pow91}. 
                            %
                            The design and implementation of this approach poses two major
                            problems: 
                            \begin{itemize}
                                \item First, the updates have to generated, bulked, distributed, and
                                    applied to the replicated data. 
                                \item Second, the additional bandwidth which is required to
                                    transport these updates is significant -- therefore, intelligent
                                    update-generation mechanisms have to be implemented.
                            \end{itemize}
                            %
                            The update processing which is necessary to implement a
                            leader-follower protocol forms already the basis for the more
                            sophisticated synchronization primitives which are required in the
                            seamless world.\\
                            %
                            The gap to a synchronization framework with weak-isolation levels
                            consists of the management of different versions of the same object,
                            i.e., while updates arrive, old versions are retained for read
                            access by the following node. Such a system would already allow to
                            implement a weakly seamless world.
                    \end{description}
                    A perfect replica allows to switch to the \MMORG to continue its
                    service quickly, even in the case of a node failure. But as should
                    be clear after the above discussion, the required effort is
                    relatively high and the problems which arise in the design of such a
                    solution are subtle. 
                \item[Central Storage:] In this case, the \MMORG could \emph{backup
                    its most vital information in a standard database,} which brings
                    already a high degree of reliability and fault-tolerance.\\
                    %
                    Such a solution cannot replace the replication which is required to
                    setup a seamless world, but in the case of segmented world, it can
                    be used to store a subscriber-relevant information. If a node
                    crashes, the subscribers which were located in the node are
                    identified and respawned in another zone (hosted by another node),
                    while the zone is loaded on another node in the background.\\
                    %
                    Form the point of view of the player, this solution is not so
                    elegant since in the case of a node-fault, he or she is teleported
                    away without any game-inherent motivation.

                    Such a solution is relatively easy to implement, and is implemented
                    by most of today's \MMORGS. The main problem is the integration of
                    the database -- a manual implementation of the routines which
                    marshal the objects into the database representation is error
                    prone. 
            \end{description}


            \subsubsection{Seamless and Continuous Worlds}

            If the world is seamlessness or continuous, 
            %it is pointless
            %to set up any fault-tolerance model which is solely based upon nodes
            %since 
            any object is potentially distributed over a number of nodes not
            for fault-tolerance but for efficiency.\\

            Therefore the fault-tolerance mechanisms must be placed atop of a more
            general replication system -- replicas are created and deleted by the
            nodes on a per need basis, basically forming a geographical circle
            around the object which moves through the world.\\
            %
            The fault-tolerance system is only required to guarantee that certain
            objects are replicated at least at a correspondingly configured number
            of nodes simultaneously.


            %% TODO Write something more detailed about purging of objects when they
            %% get lost due to a sys crash or something similar
            If a node-failure is detected, the middleware has to assign the zone
            to another node. In the case of such a reassignment, the zone must be
            cleaned, i.e., all objects which were not replicated and were lost
            have to be purged. Then the node starts the processing loop of the
            zone. Since the each zone will be partly replicated over several other
            nodes, the restart time will be generally low. 
            %
            The other parameter, i.e., the amount of data to be replicated for
            fault-tolerance, can be evaluated in various settings without too much
            effort -- since the replication mechanism is available for all objects
            and the replication for fault-tolerance can be simply switched on and
            off.


            \subsubsection{Summary}

            To conclude this subsection, we can state that
            \begin{description}
                \item[in segmented and segregated worlds] a backup into a centralized
                    standard database product is sufficient.
                \item[seamless and continuous worlds] are already equipped with 
                    very powerful mechanisms to implement an elaborated fault-tolerant
                    model. Thus it is advisable to design and implement any seamless or
                    continuous world with a fault-tolerance model which enables the
                    quick restart of zones.
            \end{description}



            \subsection{Scalability}
            \label{sec:scalability-1}

            %% Besides the administrators and game-developers,
            %% the subscribers also can observe the size of the world and the number of
            %% subscribers who are concurrently in the game. Indeed, the subscribers are
            %% affected by the scalability characteristics of the \MMORG and
            %% ultimately of the underlying middleware.

            Scalability in itself is by definition a major goal in every
            \MMORG-project. Strong scalability quickly leads to uniformity of the
            underlying platform -- however, we want to emphasize the need for
            uniformity since administrators and game-designers will require also
            require uniformity:
            %%
            %%The structure of the cluster must be uniform, to be easily
            %%maintainable. 
            \begin{itemize}
                \item Fault tolerance requires that each machine can be replaced by
                    another one in the cluster. 
                \item The cluster should be easily expandable. If the cluster is
                    structured in a uniform manner, it can be expanded by just adding
                    another machine.
                \item The cluster should display a predictable behavior, even to
                    game-designers. A non-uniform structure of the cluster would require
                    a deep understanding of the lower layers of the overall system,
                    while a uniformly structured cluster will behave uniformly and thus
                    more understandably. 
            \end{itemize}

            It is a declared goal of the industry to set up a virtual game world of 10.000
            simultaneously logged in subscribers. To achieve a virtual game world of such
            massive dimensions, two basic resources have to be balanced:
            \begin{description}
                \item[Processing Power:] Under the assumption that one high-end Intel-compatible
                    CPU\footnote{The usage of Intel-compatible CPUs is a
                    requirement because of cost-effectiveness.} is able to handle 100
                    player characters, we already need 100 CPUs in the cluster
                    to be able to maintain the game-state, but we also have to integrate
                    the connection and chat servers.
                \item[Communication Bandwidth:] On the other hand, these CPUs need to
                    communicate with each other, and the communication bandwidth which
                    is required to connect these CPUs is massive, too.
            \end{description}
            %
            There are two basic strategies to keep these resources in balance. 
            \begin{description}
                \item[Exploiting the Geographical Organization] is one way to handle
                    the situation.\\
                    %
                    Segmented and segregated worlds are based on this
                    principle, i.e., they divide the world in small zones and reduce the
                    communication between the zones to a minimum. Thus, the
                    communication bandwidth is not a bottleneck.

                    The same idea can be brought to seamless and continuous worlds on a
                    larger scale, i.e., instead of representing by a set 
                    seamlessly connected zones, the world can be represented by a set of
                    ``continents'', where each continent consists of a set of seamlessly
                    connected zones -- and is maintained by a corresponding cluster. 
                \item[SMP Machines] come with up to 8 CPUs in one node. The more
                    efficient communication inside an SMP node can greatly help to
                    reduce the required communication bandwidth.  

                    Thus, adding an allowance for additional overhead in the SMP
                    machine, we can handle 500 players with one node which leads us to
                    20 nodes for the game-state. This is still not a very small number,
                    but it is certainly much more tractable than setting up a cluster
                    of 100 nodes.

                    The load balancing of such a system will be a crucial factor to
                    success -- different population densities give different zones
                    varying weights on the CPUs. Also the communication between the
                    zones needs to be considered, since SMP machines make only sense if
                    neighboring zones with a highly populated border are assigned to the
                    same node.
            \end{description}
            %
            Therefore, high scalability requirements and seamlessness lead to the
            requirement of an SMP-optimized middleware architecture. We can
            conclude that
            \begin{description}
                \item[in segmented and segregated worlds] the scalability is a
                    secondary issue, because of the low communication overhead between
                    the individual CPUs.
                \item[in seamless and continuous worlds] the scalability is determined
                    by the communication bandwidth required between the
                    nodes. A key strategy to building such worlds in a scalable fashion is
                    the efficient employment of SMP machines.
            \end{description}
            %



            \section{The \SYNEIGHT Design Challenge}

            In this chapter we have presented the \MMORG-domain, and determined 
            the most prominent design decisions to be considered in the
            development of \MMORG server middleware. 

            The \SYNEIGHT project is intended to serve as a basis for next-generation
            \MMORGS.  In terms of the terminology layed out in this chapter, the
            challenge of \SYNEIGHT is to achieve the following design goals:
            \begin{description}
                \item[Strongly Seamless World:] One of the first identified design
                    goals of \SYNEIGHT was the support of a \textbf{strongly seamless}
                    world. During the analysis of the corresponding requirements, this
                    design goal proved to be central -- as outlined above, this decision
                    must be reflected at all levels of the employed middleware.
                \item[Online Change Management:] We decided that the change management
                    of \SYNEIGHT has to support \textbf{type changes} and has to support
                    \textbf{deferred global updating}.
                \item[Dependability:] Since any strongly seamless world needs to be
                    built upon replication, we decided to exploit this fact and design
                    \SYNEIGHT as a \textbf{fault-tolerant} middleware, i.e.,
                    \textbf{critical tasks} such as the processing of zones have to be
                    \textbf{restarted} by the middleware itself in the case of a failure
                    such that the service is continued quickly.
                \item[Highly Scalable:] It is the goal of \SYNEIGHT to support up to
                    \textbf{10.000 simultaneous clients}. Therefore \SYNEIGHT is required to
                    \textbf{exploit SMP-architectures well} and to be able to employ
                    \textbf{multiple parallel networks}. 
            \end{description}

            In the remaining chapters, we will present an approach to meet
            the challenges of the \SYNEIGHT project.

            %%
            %%Two main features were named at the very beginning of the
            %%\SYNEIGHT-project, namely it should provide the basis for a
            %%\begin{itemize}
            %%\item seamless world -- by the terminology of subsection
            %%  \vref{sec:seamlessness} -- a \textbf{strongly seamless world},
            %%\item and \textbf{highly scalable world}, i.e., it should allow to
            %%  serve up to 10.000 players. 
            %%\end{itemize}
            %%%
            %%Because of the strong impact of seamlessness to a middleware for
            %%\MMORGS in terms of replication and synchronization, a strong 
            %%
            %%
            %%
            %%The first question to be answered by this document is \textbf{``Which
            %%  fundamental design goals have to be met by a middleware which is
            %%  projected as the next-generation middleware basis for \MMORGS?''}
            %%%
            %%We will answer the question in this section. 
            %%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

            \chapter{A Next-Generation Middleware for \MMORGS}


            \section{A Reference Model for Middleware}

            It is well-known that
            networking protocol stacks can be decomposed into multiple layers,
            including the physical, data-link, network, transport, session,
            presentation and application layers defined in the OSI reference
            model \cite{black91}. Likewise, it is possible to decompose an
            object-oriented middleware into multiple layers \cite{ss01, sh02a}:
            \begin{description}
                \item[Host infrastructure middleware] encapsulates the
                    operating system primitives to enable the platform independent
                    access to concurrency and interprocess communication
                    mechanisms. 
                    %
                    Most of today's operating systems (OS) provide a procedural API
                    while most of today's higher level software is based upon the object
                    oriented paradigm.
                    %
                    In addition, while many native OS-APIs are quite similar in their
                    general structure, they differ in many subtle details. Therefore the
                    development of large, distributed and platform independent
                    applications based on native OS APIs is a tedious and error-prone
                    process.
                    %
                    The host infrastructure middleware resolves these issues by wrapping
                    the native OS-API into an object oriented framework.
                    %
                    Examples for host infrastructure middleware systems are the
                    Adaptive Communication Environment \cite{sh02a,sh02b} and the Java
                    Packages \cite{agh00}.
                \item[Distribution middleware] provides application programmers
                    with an interface which allows them to develop distributed
                    applications much like stand-alone applications, i.e., by sending
                    messages to target objects transparently disregarding their
                    location, their implementation language, and their underlying
                    platform (OS and hardware). 
                    %
                    To achieve this goal, a distribution middleware has to provide means
                    for common network programming issues, including connection and memory
                    management, marshaling and demarshaling, demultiplexing,
                    synchronization on various levels, and multithreading. 
                    %
                    These services are based upon a corresponding host infrastructure
                    middleware and are centered around an object request broker (ORB),
                    such as COM+ \cite{box97}, Java RMI \cite{sun98}, or CORBA
                    \cite{omg01}. 
                \item[Common middleware services] constitute higher-level
                    domain-independent services, such as transaction processing,
                    replication, persistence, auditing, access control, and event
                    notification.  Common middleware services are focused on the
                    management (allocation, scheduling, coordination) of resources
                    throughout the entire distributed system. Thus, the distributed
                    middleware emphasizes the management of end-system resources, i.e.,
                    the resources which are local to one node such as the main-memory of
                    a single node. In contrast, common middleware services provide
                    end-to-end capabilities, i.e., they provide a uniform view on the
                    overall system. 
                \item[Domain-specific middleware services] are aimed at the
                    specific needs of applications in a certain domain, such as \MMORGS,
                    health-care or avionics while all other layers including the common
                    middleware services are usable in broader scenarios.
                    %
                    %Therefore the domain-specific middleware services mark the border
                    %between horizontal and vertical markets.
                    %
                    While there are commercially available standard products for all the
                    horizontal layers, there are almost no domain-specific middleware
                    service packages. This situations is natural since there have to be
                    established domain-independent middleware solutions to base
                    a domain-specific middleware solution upon.
            \end{description}
            %
            We will use the term \emph{domain-independent middleware} to denote
            the middleware stack consisting of the host infrastructure middleware,
            the distribution middleware and the common middleware services.

            \section{Domain-Specific Middleware Services for \MMORGS}


            In this section we describe the domain-specific middleware services of
            a \MMORG. We divide them into three sub-domains, namely the
            \emph{gaming domain}, \emph{maintenance domain} and the
            \emph{content-production domain}.
            %
            The gaming domain contains all services which are needed by the
            clients to play the game while the maintenance domain consists of
            those services which are needed for the management of the produced
            content, subscription management and other administrative tasks.
            Finally, the content-production domain embodies all services which are
            necessary to produce the content itself. In this document, we will 
            consider the content-production domain only in so far as we need to describe
            the gaming and maintenance domain.
            %
            %%We start with a description of the different services of the realtime
            %%and the maintenance domain to continue with the associated databases
            %%and interfaces. 

            \subsection{Gaming Services}

            In the following list, we describe the four services of the gaming
            domain. They represent the running game to the clients by collectively
            maintaining the game-state and thus they are required to operate under
            soft-realtime constraints and must be highly reliable and scalable. 



            \begin{description}
                \item[Game-State Server:] A \MMORG's game-state is held and
                    continuously processed by a cluster of game-state servers.
                    %
                    A specific game-state server handles a set of zones\footnote{See
                    subsection \vref{sec:geographical-organization}.}. These zones are
                    assigned to the specific game-state server dynamically to balance
                    the load within the cluster of game-state servers. When we say that
                    a server handles a zone, we mean that this server executes the
                    control loop of all active objects\footnote{See subsection
                    \vref{sec:active-objects}.} which are located in this zone.\\
                    %
                    Therefore, a single game-state server must \emph{access} the set of
                    \emph{distributed, persistent, and active objects} which constitute
                    each of its zones and process their control loop. 
                \item[Connection Server:] Each connection server for a \MMORG is
                    responsible for managing the connections for a number of clients,
                    i.e., to mediate the messages between its clients and the game-state
                    servers which are currently holding the characters of these clients.
                    %
                    To achieve the overall soft realtime constraints of the \MMORG, the
                    connection server has to select the data to be sent to the client
                    and to prioritize and bulk this data-flow. This task must
                    incorporate information on the quality of the connection to the
                    particular client and the current knowledge of the client.
                    %
                    Finally, since clients have to be treated as hostile\footnote{See
                    subsection \vref{sec:players-are-potential-adversaries}.}, the
                    connection server has to check the syntactical correctness
                    and semantical consistency of each client-sent message before it
                    forwards it to the corresponding game-state server.\\
                    %
                    Summarized, the connection server has to \emph{select, prioritize
                    and bulk} the data which is sent to the client. This data is
                    provided by the game-state and chat servers. On the other hand, the
                    connection server has to \emph{validate} each (potentially hostile) 
                    datum sent from the
                    client to the server at the application level. In the case of a
                    positive validation it has to \emph{forward} each datum to the
                    correspondingly responsible server.
                    %
                    These characteristics place the connection server as a \emph{mediator
                    \cite{ghjv95} between the gaming domain and the client}. 
                \item[Chat Server:] Because of the large number of chat messages which
                    typically occur in \MMORGS, dedicated chat servers are required. A
                    chat server should mimic \emph{features of a commonly accepted chat
                    system}, such as the Internet Relay Chat (IRC) architecture
                    \cite{RFC1459,RFC2810,RFC2811,RFC2812,RFC2813}.
                    %
                    In addition to these standard features, there must be a special chat
                    channel which is \emph{geographically segmented}, i.e., which allows
                    geographically near objects to exchange messages.
                    %
                    To achieve this goal, the chat servers need to communicate with the
                    game-state servers. The chat servers also need to communicate with
                    the connection servers which constitute the interface to the client.
                \item[Game-Control Server:] The game-control server of a \MMORG
                    governs all services of the gaming domain of the \MMORG. It controls
                    their start-up, shut-down, patching, and balancing. It also provides
                    the statistical information required for maintaining the \MMORG
                    such as login numbers, and failure counts.
                    %
                    In general, the game-control server is the \emph{facade
                    \cite{ghjv95} of the gaming domain with respect to the
                    maintenance domain}.  
                    %
                    Because of the relatively low number of requests which stem from the
                    maintenance domain, the game-control server needs to be replicated
                    for reliability only and not for scalability.
            \end{description}
            %
            %
            The gaming services are tightly bound to each other, since they all access
            the game state. The game-state server is maintaining the
            objects which constitute the game-state, i.e., it keeps them active by
            executing their control loops. 
            %
            The connection server needs to map changes in the game-state to
            messages to be sent to the client and has to send the client-requests
            to these objects. 
            %
            The chat server has to know the geographic position of the characters, and
            finally, the game-control server has to execute global transactions on
            the game-state, such as expanding it.\\
            %
            %
            All these operations are required to be synchronized and thus all
            these services should be based on the same common middleware services
            and distribution middleware.


            \subsection{Maintenance Services}

            The maintenance services do not share the extensive scalability and
            realtime constraints of the gaming domain. In contrast, they provide
            standard services and might be based on commercial-off-the-shelf
            (COTS) products. To achieve the required availability, simple
            duplication of the corresponding services suffices. 

            \begin{description}
                \item[Login Server:] The login process into a \MMORG can be divided
                    into two steps. First, the subscriber's \emph{identity and
                    permissions} have to be \emph{checked}. If this validation is
                    successful, then in the second step the \emph{connection} has to be
                    \emph{established}. The first step is entirely handled by the login
                    server while the second step is mainly delegated to the game-control
                    server which activates the subscriber's character and initiates the
                    connection (by issuing the necessary operations on the game-state
                    and connection servers). The login server receives the IP-address of
                    the selected connection server and forwards it to the client.
                    %
                    If there are several different games or game-instances, the login
                    server will also allow the subscriber to login into his or her game
                    of choice (naturally respecting the subscriber's access
                    permissions).\\
                    %
                    The \emph{payment} is also handled by the login server, i.e., the
                    subscriber can buy gaming-time by sending a corresponding request
                    along with his oder her credit card data. The login server will
                    employ the \emph{billing gateway} to charge the credit card and on
                    success, update the subscription database.
                    %
                    The login service must be reliable to allow subscribers to log
                    in. However, it is tolerable if down-times in the magnitude of
                    minutes occur. Because of the non-realtime character and
                    relatively low load of the login process, a standard database product
                    might be employed.
                    %
                    \item[Download Server:] The download servers of a \MMORG must provide
                        all \emph{software and data} which is \emph{needed by the clients}
                        to enter the game. Because of the continuous development of a
                        \MMORG, the download server must also provide \emph{incremental
                        patches} such that a client can update itself by downloading only a
                        minimal amount of data. 
                        %
                        Typically, the download server is only feeding a larger data
                        distribution network, i.e., the contents of the download server are
                        mirrored by a large number of geographically distributed servers. 
                    \item[Update Server:] The update server is responsible
                        for providing the patches which arise from the changes and
                        expansions of the \MMORG's world\footnote{See subsection
                        \vref{sec:expandability-changeability}.}.
                        %
                        In other words, the update server is the \emph{interface to the
                        content-production domain}. The finally produced content needs to
                        be submitted to the update server in terms of a corresponding client
                        and server patch. The client patches have to be deployed to the
                        download servers and after an appropriate period of time the
                        associated server patch has to be executed by the game-control
                        server. Once the game-control server applies a server patch, the
                        connection servers will be informed to require each connecting
                        client to be patched with the associated client update.
                        %
                        Thus the update server \emph{provides the patches} but
                        it does not control their application.
                    \item[Configuration Server.]  The configuration server is responsible
                        for maintaining the complete configuration of all the services which
                        constitute the running \MMORG, i.e., it will \emph{associate a gaming
                        domain cluster with a set of login, download and update servers.} It
                        will also know the current configuration of the \MMORG with respect
                        to patching and issue the complete patching procedure, that is, it
                        will upload a client patch onto the download server to make it
                        publicly available, and later, it will command the game-control
                        server to apply the corresponding server patch to game-state.
                        %
                        The configuration server is necessary for the start up of the
                        system. Thus it needs to be replicated for reliability.\\
                        %
                        By using a configuration server to establish association between
                        the different services, it is also possible to use the same services
                        for several \MMORG-instances. For example, it will be necessary to
                        maintain several test games which use the same update server as the
                        publicly running game.\\
                        This server is also associated with an administrative client, which
                        allows to change the current settings. 
                \end{description}
                %
                The services of the maintenance domain are relatively loosely coupled.
                The login server maintains its subscription database completely
                isolated from the other services,
                %\footnote{Besides the usual
                %  administrative access, business applications will need to access
                %  this database. But the business applications will only read this
                %  database to generate various statistics.} 
                it only interacts with the game-control server to initiate the
                connection establishment. The download server is the data-source for
                the data distribution network, the only occurring interaction with the
                other services is the upload of new patches from the update server.
                %
                The update server is the interface between the content production
                domain and the maintenance domain and provides 
                distinct interfaces to both domains. From the perspective of the 
                maintenance domain,
                the update server provides a simple data-repository which is used by
                the game-control and download server. This interface might be a
                standard protocol such as FTP.\footnote{The interface of the update
                server for the content-production domain will be much more complex
                -- this interface must control the packaging of the updates.}  The
                configuration server will employ a standard database product to manage
                its configuration data.
                %% As a possible interface to the other services, it might answer
                %% to a UDP-broadcast and reply the configuration data to a specific host
                %% based on the host's IP-address. 
                Again, the configuration server can be designed as a classical
                stand-alone database application.
                %
                %% In general, the maintenance domain is positioned between the
                %% content-production and the gaming domain. Its r\^ole is to provide a
                %% simple interface for the content-production (the update server) and to
                %% keep the relatively complex gaming domain as concise as possible.


                \subsection{Content-Production Services}
                \label{sec:cont-prod-serv}

                The content-production domain can be further subdivided into the
                art-pipeline and the game-design.
                \begin{description}
                    \item The \textbf{art-pipeline} is based on standard graphics-tools
                        for 3D-modeling.  Typically, these tools are expanded by custom
                        scripts and plug-ins, to form a pipeline. Because of the massive
                        amount of work to be done by the art-team, the organization of this
                        work is critical. Therefore, the content-production domain is
                        characterized by the integration and modification of existing tools
                        to form an effective production environment. In addition to the
                        graphics-tools, there need to be extensive version control
                        facilities for binary as well as for textual data. Finally, the
                        raw-models produced by the art-pipeline must be transformed into the
                        client's data-format and for each model a description of the
                        corresponding object which is sufficient for the game-state servers
                        must be generated.
                    \item The \textbf{game-design} uses these models to build, modify and
                        expand existing areas. The main challenge is again the integration
                        of different tools. In the ideal case, a game-designer can employ an
                        environment which allows her or him to place different objects
                        visually in an area and to program these objects both visually and
                        in terms of a scripting language.
                        %
                        Naturally, the game-designer must be able to test new areas. The
                        integration of testing facilities can be done in a number of
                        different forms, ranging from a special client which comes with a
                        completely integrated game-logic to the utilization of the common
                        client connecting to a test gaming environment.
                \end{description}
                %
                Once the game-designer is satisfied with a new level, all associated
                data, i.e., the models and the scripts of the objects need to be compiled
                into patches for the server and the client. 

                As already noted, we will abstract from the structure of this domain
                in so far as we just assume that the patches are placed on the
                update-server. Still, the content-production domain must be considered
                in the design of the gaming domain. While the services of the gaming
                domain are keeping the world of a \MMORG alive, the services of
                content-production domain have to construct this world. Therefore, the
                middleware which forms the basis for the gaming domain will also be
                used by the content-production domain, especially by the applications
                of the game-designers. The game-designer uses a tool set to
                manipulate a given zone and to test this zone. It has to be assumed that
                this tool set is subject to constant development during the overall
                existence of the \MMORG. In the context of middleware development, we
                have to assume that
                \begin{itemize}
                    \item varying applications for game-designers are developed which
                        access and manipulate the gaming-state directly,
                    \item that these applications display different access patterns than
                        the gaming domain's services,
                    \item and that these applications have to be integrated on the fly.
                \end{itemize}
                %
                We conclude that the content-production domain (and especially its
                game-design sub-domain) incurs strong requirements in terms of
                composability on the gaming domain's underlying middleware, i.e., it
                must be easy to integrate new and diverse applications into the
                overall system.


                %% \section{A Reference Model for Middleware}
                %% 
                %% Networking protocol stacks can be decomposed into multiple layers,
                %% including the physical, data-link, network, transport, session,
                %% presentation and application layers defined in the OSI reference
                %% model \cite{black91}. Likewise, it is possible to decompose an
                %% object-oriented middleware into multiple layers \cite{ss01, sh02a}:
                %% \begin{description}
                %% \item[Host infrastructure middleware] encapsulates the
                %%   operating system primitives to enable the platform independent
                %%   access to concurrency and interprocess communication
                %%   mechanisms. 
                %%   %
                %%   Most of today's operating systems (OS) provide a procedural API
                %%   while most of today's higher level software is based upon the object
                %%   oriented paradigm.
                %%   %
                %%   In addition, while many native OS-APIs are quite similar in their
                %%   general structure, they differ in many subtle details. Therefore the
                %%   development of large, distributed and platform independent
                %%   applications based on native OS APIs is a tedious and error-prone
                %%   process.
                %%   %
                %%   The host infrastructure middleware resolves these issues by wrapping
                %%   the native OS-API into an object oriented framework.
                %%   %
                %%   Examples for host infrastructure middleware systems are the
                %%   Adaptive Communication Environment \cite{sh02a,sh02b} and the Java
                %%   Packages \cite{agh00}.
                %% \item[Distribution middleware] provide application programmers
                %%   with an interface which allows them to develop distributed
                %%   applications much like stand-alone applications, i.e., by sending
                %%   messages to target objects transparently disregarding their
                %%   location, their implementation language, and their underlying
                %%   platform (OS and hardware). 
                %%   %
                %%   To achieve this goal, a distribution middleware has to provide means
                %%   for common network programming issues, such as connection and memory
                %%   management, marshaling and demarshaling, demultiplexing,
                %%   synchronization on various levels, and multithreading. 
                %%   %
                %%   These services are based upon a corresponding host infrastructure
                %%   middleware and are centered around an object request broker (ORB),
                %%   such as COM+ \cite{box97}, Java RMI \cite{sun98}, or CORBA
                %%   \cite{omg01}. 
                %% \item[Common middleware services] constitute higher-level
                %%   domain-independent services, such as transaction processing,
                %%   replication, persistence, auditing, access control, and event
                %%   notification.  Common middleware services are focused on the
                %%   management (allocation, scheduling, coordination) of resources
                %%   throughout the entire distributed system. Thus, the distributed
                %%   middleware emphasizes the management of end-system resources, i.e.,
                %%   the resources which are local to one node such as the main-memory of
                %%   a single node. In contrast, common middleware services provide
                %%   end-to-end capabilities, i.e., they provide a uniform view on the
                %%   overall system. 
                %% \item[Domain-specific middleware services] are aimed at the
                %%   specific needs of applications in a certain domain, such as \MMORGS,
                %%   health-care or avionics while all other layers including the common
                %%   middleware services are usable in broader scenarios.
                %%   %
                %%   %Therefore the domain-specific middleware services mark the border
                %%   %between horizontal and vertical markets.
                %%   %
                %%   While there are commercially available standard products for all the
                %%   horizontal layers, there are almost no domain-specific middleware
                %%   service packages. This situations is natural since there have to be
                %%   established domain-independent middleware solution to base
                %%   domain-specific middleware solution upon.
                %% \end{description}
                %% %
                %% We will use the term \emph{domain-independent middleware} to denote
                %% the middleware stack consisting of the host infrastructure middleware,
                %% the distribution middleware and the common middleware services.
                %% 
                %% \section{Domain-Specific Middleware Services for \MMORGS}
                %% 
                %% 
                %% In this section we describe the domain-specific middleware services of
                %% a \MMORG. We divide them into three sub-domains, namely the
                %% \emph{gaming domain}, \emph{maintenance domain} and the
                %% \emph{content-production domain}.
                %% %
                %% The gaming domain contains all services which are needed by the
                %% clients to play the game while the maintenance domain consists of
                %% those services which are needed for the management of the produced
                %% content, subscription management and other administrative tasks.
                %% Finally, the content-production domain embodies all services which are
                %% necessary to produce the content itself. In this document, we will 
                %% consider the content-production domain only in so far as we need to describe
                %% the gaming and maintenance domain.
                %% %
                %% %%We start with a description of the different services of the realtime
                %% %%and the maintenance domain to continue with the associated databases
                %% %%and interfaces. 
                %% 
                %% \subsection{Gaming Services}
                %% 
                %% In the following list, we describe the four services of the gaming
                %% domain. They represent the running game to the clients by collectively
                %% maintaining the game-state and thus they are required to operate under
                %% soft-realtime constraints and must be highly reliable and scalable. 
                %% 
                %% 
                %% 
                %% \begin{description}
                %% \item[Game-State Server:] A \MMORG's game-state is held and
                %%   continuously processed by a cluster of game-state servers.
                %%   %
                %%   A specific game-state server handles a set of zones\footnote{See
                %%     subsection \vref{sec:geographical-organization}.}. These zones are
                %%   assigned to the specific game-state server dynamically to balance
                %%   the load within the cluster of game-state servers. When we say that
                %%   a server handles a zone, we mean that this server executes the
                %%   control loop of all active objects\footnote{See subsection
                %%     \vref{sec:active-objects}.} which are located in this zone.\\
                %%   %
                %%   Therefore, a single game-state server must \emph{access} the set of
                %%   \emph{distributed, persistent, and active objects} which constitute
                %%   each of its zones and process their control loop. 
                %% \item[Connection Server:] Each connection server for a \MMORG is
                %%   responsible for managing the connections for a number of clients,
                %%   i.e., to mediate the messages between its clients and the game-state
                %%   servers which are currently holding the characters of these clients.
                %%   %
                %%   To achieve the overall soft realtime constraints of the \MMORG, the
                %%   connection server has to select the data to be sent to the client
                %%   and to prioritize and bulk this data-flow. This task must
                %%   incorporate information on the quality of the connection to the
                %%   particular client and the current knowledge of the client.
                %%   %
                %%   Finally, since clients have to treated as hostile\footnote{See
                %%     subsection \vref{sec:players-are-potential-adversaries}.}, the
                %%   connection server has to check the syntactical correctness
                %%   and semantical consistency of each client-sent message before it
                %%   forwards it to the corresponding game-state server.\\
                %%   %
                %%   Summarized, the connection server has to \emph{select, prioritize
                %%     and bulk} the data which is sent to the client. This data is
                %%   provided by the game-state and chat servers. On the other hand, the
                %%   connection server has to \emph{validate} each datum sent from the
                %%   client to the server at the application level. In the case of a
                %%   positive validation it has to \emph{forward} each datum to the
                %%   correspondingly responsible server.
                %%   %
                %%   These characteristics place the connection server as a \emph{mediator
                %%   \cite{ghjv95} between the gaming domain and the client}. 
                %% \item[Chat Server:] Because of the large number of chat messages which
                %%   typically occur in \MMORGS, dedicated chat servers are required. A
                %%   chat server should mimic \emph{features of a commonly accepted chat
                %%     system}, such as the Internet Relay Chat (IRC) architecture
                %%   \cite{RFC1459,RFC2810,RFC2811,RFC2812,RFC2813}.
                %%   %
                %%   In addition to these standard features, there must be a special chat
                %%   channel which is \emph{geographically segmented}, i.e., which allows
                %%   geographically near objects to exchange messages.
                %%   %
                %%   To achieve this goal, the chat servers need to communicate with the
                %%   game-state servers. The chat servers also need to communicate with
                %%   the connection servers which constitute the interface to client.
                %% \item[Game-Control Server:] The game-control server of a \MMORG
                %%   governs all services of the gaming domain of the \MMORG. It controls
                %%   their start-up, shut-down, patching, and balancing. It also provides
                %%   the statistical information required for maintaining the \MMORG
                %%   such as login numbers, and failure counts.
                %%   %
                %%   In general, the game-control server is the \emph{facade
                %%     \cite{ghjv95} of the gaming domain with respect to the
                %%     maintenance domain}.  
                %%   %
                %%   Because of the relatively low number of requests which stem from the
                %%   maintenance domain, the game-control server needs to be replicated
                %%   for reliability only and not for scalability.
                %% \end{description}
                %% %
                %% %
                %% The gaming services are tightly bound to each other, since they all access
                %% the game state. The game-state server is maintaining the
                %% objects which constitute the game-state, i.e., it keeps them active by
                %% executing their control loops. 
                %% %
                %% The connection server needs to map changes in the game-state to
                %% messages to be sent to the client and has to send the client-requests
                %% to these objects. 
                %% %
                %% The chat server has to know the geographic position of the characters, and
                %% finally, the game-control server has to execute global transactions on
                %% the game-state, such as expanding it.\\
                %% %
                %% %
                %% All these operations are required to be synchronized and thus all
                %% these services should be based on the same common middleware services
                %% and distribution middleware.
                %% 
                %% 
                %% \subsection{Maintenance Services}
                %% 
                %% The maintenance services do not share the extensive scalability and
                %% realtime constraints of the gaming domain. In contrast, they provide
                %% standard services and might be based on commercial off the shelf
                %% (COTS) products. To achieve the required availability, simple
                %% duplication of the corresponding services suffices. 
                %% 
                %% \begin{description}
                %% \item[Login Server:] The login process into a \MMORG can be divided
                %%   into two steps. First, the subscriber's \emph{identity and
                %%     permissions} have to be \emph{checked}. If this validation is
                %%   successful, then in the second step the \emph{connection} has to be
                %%   \emph{established}. The first step is entirely handled by the login
                %%   server while the second step is mainly delegated to the game-control
                %%   server which activates the subscriber's character and initiates the
                %%   connection (by issuing the necessary operations on the game-state
                %%   and connection servers). The login server receives the IP-address of
                %%   the selected connection server and forwards it to the client.
                %%   %
                %%   If there are several different games or game-instances, the login
                %%   server will also allow the subscriber to login into his or her game
                %%   of choice (naturally respecting the subscriber's access
                %%   permissions).\\
                %%   %
                %%   The \emph{payment} is also handled by the login server, i.e., the
                %%   subscriber can buy gaming-time by sending a corresponding request
                %%   along with his oder her credit card data. The login server will
                %%   employ the \emph{billing gateway} to charge the credit card and on
                %%   success, update the subscription database.
                %%   %
                %%   The login service must be reliable to allow subscribers to log
                %%   in. However, it is tolerable if down-times in the magnitude of
                %%   minutes occur. Because of the non-realtime character and
                %%   relative low load of the login process, a standard database product
                %%   might be employed.
                %%   %
                %% \item[Download Server:] The download servers of a \MMORG must provide
                %%   all \emph{software and data} which is \emph{needed by the clients}
                %%   to enter the game. Because of the continuous development of a
                %%   \MMORG, the download server must also provide \emph{incremental
                %%   patches} such that a client can update itself by downloading only a
                %%   minimal amount of data. 
                %%   %
                %%   Typically, the download server is only feeding a larger data
                %%   distribution network, i.e., the contents of the download server are
                %%   mirrored by a large number of geographically distributed servers. 
                %% \item[Update Server:] The update server is responsible
                %%   for providing the patches which arise from the changes and
                %%   expansions of the \MMORG's world\footnote{See subsection
                %%     \vref{sec:expandability-changeability}.}.
                %%   %
                %%   In other words, the update server is the \emph{interface to the
                %%     content-production domain}. The finally produced content needs to
                %%   be submitted to the update server in terms of a corresponding client
                %%   and server patch. The client patches have to be deployed to the
                %%   download servers and after an appropriate period of time the
                %%   associated server patch has to be executed by the game-control
                %%   server. Once the game-control server applies a server patch, the
                %%   connection servers will be informed to require each connecting
                %%   client to be patched with the associated client update.
                %%   %
                %%   Thus the update server \emph{provides the patches} but
                %%   it does not control their application.
                %% \item[Configuration Server.]  The configuration server is responsible
                %%   for maintaining the complete configuration of all the services which
                %%   constitute the running \MMORG, i.e., it will \emph{associate a gaming
                %%   domain cluster with a set of login, download and update servers.} It
                %%   will also know the current configuration of the \MMORG with respect
                %%   to patching and issue the complete patching procedure, that is, it
                %%   will upload a client patch onto the download server to make it
                %%   publicly available, and later, it will command the game-control
                %%   server to apply the corresponding server patch to game-state.
                %%   %
                %%   The configuration server is necessary for the start up of the
                %%   system. Thus it needs to replicated for reliability.\\
                %%   %
                %%   By using a configuration server to establish association between
                %%   the different services, it also possible to use the same services
                %%   for several \MMORG-instances. For example, it will be necessary to
                %%   maintain several test games which use the same update server as the
                %%   publicly running game.\\
                %%   This server is also associated with an administrative client, which
                %%   allows to change the current settings. 
                %% \end{description}
                %% %
                %% The services of the maintenance domain are relatively loosely coupled.
                %% The login server maintains its subscription database completely
                %% isolated from the other services,
                %% %\footnote{Besides the usual
                %% %  administrative access, business applications will need to access
                %% %  this database. But the business applications will only read this
                %% %  database to generate various statistics.} 
                %% it only interacts with the game-control server to initiate the
                %% connection establishment. The download server is the data-source for
                %% the data distribution network, the only occurring interaction with the
                %% other services is the upload of new patches from the update server.
                %% %
                %% The update server is the interface between the content production
                %% domain and the maintenance domain and provides to both domains a
                %% distinct interface. Form the perspective of the maintenance domain,
                %% the update server provides is simple data-repository which is used by
                %% the game-control and download server.This interface might be a
                %% standard protocol such as FTP\footnote{The interface of the update
                %%   server for the content-production domain will be much more complex
                %%   -- this interface must control the packaging of the updates.}  The
                %% configuration server will employ a standard database product to manage
                %% its configuration data.
                %% %% As a possible interface to the other services, it might answer
                %% %% to a UDP-broadcast and reply the configuration data to a specific host
                %% %% based on the host's IP-address. 
                %% Again, the configuration server can be designed as a classical
                %% stand-alone database application.
                %% %
                %% %% In general, the maintenance domain is positioned between the
                %% %% content-production and the gaming domain. Its r\^ole is to provide a
                %% %% simple interface for the content-production (the update server) and to
                %% %% keep the relatively complex gaming domain as concise as possible.
                %% 
                %% 
                %% \subsection{Content-Production Services}
                %% \label{sec:cont-prod-serv}
                %% 
                %% The content-production domain can be further subdivided into the
                %% art-pipeline and the game-design.
                %% \begin{description}
                %% \item The \textbf{art-pipeline} is based on standard graphics-tools
                %%   for 3D-modeling.  Typically, these tools are expanded by custom
                %%   scripts and plug-ins, to form a pipeline. Because of the massive
                %%   amount of work to be done by the art-team, the organization of this
                %%   work is critical. Therefore, the content-production domain is
                %%   characterized by the integration and modification of existing tools
                %%   to form an effective production environment. In addition to the
                %%   graphics-tools, there need to be extensive version control
                %%   facilities for binary as well as for textual data. Finally, the
                %%   raw-models produced by the art-pipeline must be transformed into the
                %%   client's data-format and for each model a description of the
                %%   corresponding object which is sufficient for the game-state servers
                %%   must be generated.
                %% \item The \textbf{game-design} uses these models to build, modify and
                %%   expand existing areas. The main challenge is again the integration
                %%   of different tools. In the ideal case, a game-designer can employ an
                %%   environment which allows her or him to place different objects
                %%   visually in an area and to program these objects partly visually as
                %%   well as in terms of a scripting language.
                %%   %
                %%   Naturally, the game-designer must be able to test new area. The
                %%   integration of testing facilities can be done in a number of
                %%   different forms, ranging from a special client which comes with a
                %%   completely integrated game-logic to the utilization of the common
                %%   client connecting to a test gaming environment.
                %% \end{description}
                %% %
                %% Once the game-designer is satisfied with a new level, all associated
                %% data, i.e., the models and the objects' scripts need to be compiled
                %% into patches for the server and the client. 
                %% 
                %% As already noted, we will abstract from the structure of this domain
                %% in so far as we just assume that the patches are placed on the
                %% update-server. Still, the content-production domain must be considered
                %% in the design of the gaming domain. While the services of the gaming
                %% domain are keeping the world of a \MMORG alive, the services of
                %% content-production domain have to construct this world. Therefore, the
                %% middleware which forms the basis for the gaming domain will also be
                %% used by the content-production domain, especially by the applications
                %% of the game-designers. The game-designer uses a tool set to
                %% manipulate a given zone and to test this zone. It has to be assumed that
                %% this tool set is subject to constant development during the overall
                %% existence of the \MMORG. In the context of middleware development, we
                %% have to assume that
                %% \begin{itemize}
                %% \item varying applications for game-designers are developed which
                %%   access and manipulate the gaming-state directly,
                %% \item that these applications display different access patterns than
                %%   the gaming domain's services,
                %% \item and that these applications have to be integrated on the fly.
                %% \end{itemize}
                %% %
                %% We conclude that the content-production domain (and especially its
                %% game-design sub-domain) incurs strong requirements in terms of
                %% composability on the gaming domain's underlying middleware, i.e., it
                %% must be easy to integrate new and diverse applications into the
                %% overall system.
                %% 
                %% 

                \section{Domain-Independent Middleware in a \MMORG Context}

                Now we turn our attention to the common middleware services and
                distribution middleware which have to underly the domain-specific
                middleware services described above.\\
                %
                We will focus on the gaming domain since the tight coupling of
                the gaming domain services requires a highly integrated distribution
                middleware along with a corresponding set of common middleware
                services. 
                \begin{description}
                    \item The common characteristic of the \textbf{gaming domain's services}
                        is that they access a shared database in a highly concurrent manner
                        requiring replication, persistence and synchronization primitives
                        under the pressure of soft-realtime constraints.\\
                        %
                        Not building the gaming domain on a shared general middleware will
                        lead to the \emph{stovepipe system anti-pattern} \cite{bmmm98}. This
                        anti-pattern arises when all interfaces between pairs of
                        communicating subsystems are distinct and mutually incompatible.
                        %
                        In such a situation usually multiple infrastructure mechanisms are
                        used to integrate these subsystems. This leads to difficulties in
                        modifying or even describing the architecture. The consequences of
                        such a development approach are large semantic gaps between
                        architecture documentation and implemented software. The software
                        might even comply to the paper requirements but it does not meet the
                        user expectations, system maintenance becomes surprisingly costly,
                        the project takes more resources than expected for no obvious
                        reason, the system complexity increases heavily on even
                        slight expansions.\\
                        %
                        There are two situations which justify to follow this anti-pattern
                        consciously -- the exploration of a yet unknown domain and the quick
                        development of a partly functional prototype.
                        %
                        But in such a situation, it is usually necessary to restart the
                        project from scratch afterwards.
                        %
                        For more details on this anti-pattern, see the corresponding chapter
                        in \cite{bmmm98}.
                    \item In contrast, the \textbf{maintenance domain's services} are
                        loosely coupled and might be assembled in a heterogeneous manner by
                        utilizing standard packages for the corresponding tasks. For
                        example, the login-server might be developed based on the Apache
                        Web-Server and a commercially available billing package, and the
                        download server can be a simple FTP-server.
                        %
                        The interface between the maintenance domain and the gaming domain
                        is provided by the game-control server. Therefore, all interactions
                        between these services and the middleware are contained in the
                        game-control server. This server will provide an interface to the
                        maintenance domain which does not employ the middleware, therefore
                        the maintenance domain is completely independent from the
                        middleware.
                    \item The \textbf{content-production domain} will consist of a set of
                        diverse applications. Thus the shared middleware must be flexible in
                        terms of composability.
                        %%
                        %%  middleware has to 
                        %%
                        %%  We already stated at the end of subsection
                        %%  \vref{sec:cont-prod-serv} the pressure with respect to composability
                        %%  on the gaming domain's underlying middleware which is exercised by
                        %%  the \emph{content-production domain.} 
                        %%  
                        The middleware must provide the means to integrate
                        new applications which follow different access patterns at ease,
                        i.e., the middleware must allow to compose the complete system out
                        of simple components.  Consequently, there must be a single shared
                        horizontal interface such that compliance to this interface ensures
                        complete integration.  This situation is one more strong reason to
                        seek a strong horizontal layer and to avoid the consequences of a
                        stovepipe system.
                \end{description}

                The domain-independent middleware which will be used as a basis for the
                domain-specific middleware services is called \SYNEIGHT. In this section,
                we will briefly discuss the main components of \SYNEIGHT. 


                \section{The Structure of \SYNEIGHT}


                \SYNEIGHT is a domain-independent middleware, i.e., it contains the
                functionality of a distribution middleware and of domain-independent
                middleware services.\\
                %
                A central feature of \SYNEIGHT is that its distribution layer integrates
                functionality which is usually attributed to domain-independent
                middleware services, most prominently, the distribution layer is
                inherently transaction-oriented. Indeed, the transaction processing is
                at the core of \SYNEIGHT. Nevertheless, \SYNEIGHT can be subdivided into a
                distribution layer and a set of domain-independent services:
                %
                \begin{description}
                    \item[Distribution Layer:] The distribution layer of \SYNEIGHT is centered
                        around databases of so-called entities. These entities are
                        distributed, replicated, persistently stored, and can be accessed
                        with based on a very flexible transaction subsystem. The two major
                        interfaces of the distribution layer (the entity access facade and
                        the meta access facade) allow the application to manipulate these
                        entities and entire databases, respectively.
                    \item[Domain Independent Services:] The domain independent services of
                        \SYNEIGHT are designed as so-called tasks. A task is represented by an
                        entity. Thus , the distribution layer of \SYNEIGHT can be utilized to
                        distribute and replicate the task. The tasks are managed by a
                        special task, namely the task scheduler. This task is the only task
                        known to the distribution layer, which guarantees that this task is
                        maintained in a fault-tolerant manner. In turn, the task scheduler
                        is responsible for distributing all other tasks in balanced manner
                        and for enforcing fault-tolerance constraints at the task level.
                \end{description}
                %
                We introduce all components of \SYNEIGHT briefly below and describe more
                detailed in the following subsections. 
                \begin{description}
                    \item [Entity Type Implementation:] This interface allows the
                        applications atop of \SYNEIGHT to integrate their custom types, such as
                        player-characters, monsters or items, into the \SYNEIGHT-framework.
                        %
                        This interface is designed to offer a high degree of flexibility to
                        both the application and the middleware. Because of the resulting
                        complexity of this interface, it will not be used directly, but by a
                        compiler which translates ordinary class description into the format
                        required by the entity type implementation interface.
                    \item [Entity Access Facade:] The entity access facade provides the
                        interface which is used by the application to access objects in the
                        database.  Thus, this facade is centered around transactions and the
                        corresponding forms of locks. It contains many of the key features
                        of \SYNEIGHT.

                        Internally, it employs the transaction monitor and the metadata
                        monitor to execute the application requests.
                    \item [Meta Access Facade:] The meta access facade is used by
                        the application to issue database-wide commands, such as loading a
                        database, making a specific entity type implementation available to
                        the database, storing a backup of a database, or exchanging one
                        entity type implementation with another one.

                        Also, the meta access facade is responsible for managing the
                        \SYNEIGHT-library which is linked into the application, i.e., it has to
                        allow the application to handle stable storage directories and
                        logical networks, as well as loading code modules. 
                        %
                        These application requests are executed by the meta access facade by
                        using the methods of the metadata monitor.
                    \item [Transaction Monitor:] The transaction monitor is the core
                        of \SYNEIGHT. It handles all the lock requests, binds entities to
                        application-level interfaces, guarantees atomicity of the
                        transaction commitment, and creates and deletes replicas of
                        entities.
                    \item [Metadata Monitor:] The metadata monitor maintains the metadata
                        of databases, tasks, and the underlying hardware. By maintaining
                        this metadata, the metadata monitor is also responsible for
                        maintaining the integrity of the databases and the tasks which use
                        these databases.
                        %
                        %In particular, the metadata monitor has to guarantee that the
                        %configured redundancy policies are enforced.\\
                        %
                        Each database contains a set of \textbf{revisions}, which form a
                        tree of different versions. The management of these revision-trees
                        and all other revision-global or database-global operations is the
                        responsibility of this component. 
                    \item [Stable Storage Manager:] \SYNEIGHT can load several stable storage
                        managers. Each of these managers is responsible for maintaining a
                        particular type of stable storage such as ordinary files, relational
                        databases or disk-partitions.

                        Each stable storage manager allows to open several \textbf{stable
                        storage channels}, where each of these channels is used to access
                        a single revision.
                    \item [Logical Network Manager:] \SYNEIGHT is not built directly on a
                        particular protocol suit. Instead, a logical network is defined in
                        terms of a logical network manager. Such a logical network can 
                        consist of several redundant physical networks. The logical network
                        manager is responsible for scheduling the communication requests
                        onto on of the physical networks and for reacting properly when a
                        physical network is lost.\\
                        %
                        The interface of a logical network manager is specific to
                        transaction processing, so for example, it has to support a 2-phase
                        commit protocol.\\
                        %
                        The logical network manager allows the \SYNEIGHT-enabled applications to
                        open so-called \textbf{logical network channels}. Each such channel
                        can serve as a networking basis for several clusters. The nodes
                        of a cluster use the channel to communicate in a peer-to-peer
                        fashion with each other by employing uni-, multi- and broadcasts.
                    \item[Module Manager:] \SYNEIGHT is built out of a number of different
                        modules such as ETIs. These modules can be loaded dynamically into
                        \SYNEIGHT. The module manager is responsible to check whether it is
                        possible to load a given module (dependencies might not be matched),
                        to load them and to unload them if they are no longer in use. 
                    \item[Domain Independent Services:] At the moment only two domain
                        independent services are planned to be integrated into \SYNEIGHT:
                        \begin{description}
                            \item[Task Scheduler:] The task scheduler is the most important
                                domain independent service of \SYNEIGHT since it is responsible for
                                distributing and balancing the middleware and application tasks.
                            \item[Snapshot Generator:] This service is responsible for
                                generating snapshots of databases.
                        \end{description}
                        %
                        Other examples for possible domain independent services would be a
                        garbage collector (which could be integrated into the snapshot
                        generator), a event notification service, a logging service, or a
                        access control service. 
                \end{description}
                %

                \subsection{Entity Type Implementation}


                \subsubsection{Entities}
                \label{sec:entities}

                %
                In \cite{booch91} it was stated that an ``object has state, behavior
                and identity''. However, \SYNEIGHT knows only the identity of an object
                and can access the state of an object in terms of a byte-stream of
                opaque structure. 
                %
                Thus, we say that \SYNEIGHT maintains databases which contain so-called
                \emph{entities.}
                %
                %
                Each entity is potentially replicated over several nodes. Thus, an
                entity is represented by number of \emph{entity-instances}. This group
                of entity-instances is called the \emph{entity's collective}. Every
                entity-instance has the following properties:
                \begin{description}
                    \item[Identity] expressed as a numerical id. This id is the same in
                        all entity-instances. 
                    \item[State] which is further subdivided into
                        \begin{description}
                            \item[Encapsulated State] is application dependent. \SYNEIGHT can
                                access this state only in terms of a byte-stream of unknown
                                structure. The interpretation of this state is delegated to
                                the corresponding \textbf{entity type implementation}. The entity
                                type implementations are supplied by the application and contain
                                the necessary implementations of the methods of the encapsulated
                                state, i.e., they describe the application-visible behavior of the
                                entity. These methods operate on the encapsulated state.

                                An entity-instance can maintain more than encapsulated state to
                                implement concurrent and transactional access strategies to the
                                entities. 
                                %
                                For example, one application might read and write an entity, while
                                another reads an already outdated state of the same entity.

                                Also the encapsulated states of the entity-instances of an
                                entity's collective can contain different sets of encapsulated
                                states. In fact, the coordination of the mutual updating between
                                the encapsulated states of the instances within a single
                                collective is a central issue in the design of \SYNEIGHT.
                            \item[Configuration State] is used by the application to tell \SYNEIGHT
                                how to treat the corresponding entity. Examples for entries in the
                                configuration state are a reference to the responsible entity type
                                implementation or the minimum number of replica which must exist
                                at the same time.
                            \item[Coordination State] is only used by \SYNEIGHT itself. The
                                middleware uses the coordination state to describe the current
                                distribution, persistence and synchronization state of the
                                entity. The contents of the coordination state will be partly
                                read-only accessible to the application. 
                        \end{description}
                \end{description}
                %

                \subsubsection{Entity Type Implementations}
                \label{sec:entity-type-impl}
                %
                This basic setting allows the application to integrate arbitrary types
                into the middleware (also dynamically at runtime) by loading the
                corresponding entity type implementations. 
                %
                An entity type implementation is responsible for handling the
                application dependent state of an entity, i.e., the encapsulated
                state.
                %
                \SYNEIGHT requires each entity type implementation to provide a set of
                generic methods. These methods provide all functionality which is
                required by \SYNEIGHT to maintain the encapsulated states within an
                entity's collective. The most important generic methods are:
                \begin{description}
                    \item[Creational:] Creating, deleting and cloning encapsulated
                        states. 
                    \item[Marshaling:] To store an encapsulated state on disk or to send
                        to another node, it is necessary to marshal and demarshal the entire
                        encapsulated state.
                    \item[Updating:] When an application modifies an entity, it is in fact
                        only updating one of the encapsulated states within the entity's
                        collective. To distribute the modifications, the entity type
                        implementation must allow to extract these changes and to encode
                        them into a update-message. To update another encapsulated state,
                        all other encapsulated states must be able to read and process this
                        update-message.
                    \item[Binding:] The application is accessing an encapsulated state
                        over bindings. A binding can allow the application to communicate
                        with a locally or remotely maintained entity-instance. The interface
                        which is used in the binding can be chosen freely by the
                        application. However, the corresponding entity type implementation
                        must support this interface.

                        The application programmer has complete freedom over the number of
                        interfaces to be supported by the entity type implementations --
                        however, typical uses of this mechanism will allow to bind an
                        encapsulated state to a singe interfaces and to its ancestors in the
                        inheritance graph. 
                \end{description}



                %%
                %%Thus each entity type implementation must not only provide procedures
                %%to create, read, modify and delete an entity state, but must also
                %%implement more advanced features such as the extraction of the changes
                %%of entity states into an update-message and the application of such
                %%update-messages to other entity states.
                %%%
                %%
                %%Finally, each entity state 
                %%
                %%
                %% Each entity type implementation has to fulfill two sets of
                %% requirements.
                %% \begin{description}
                %% \item First, it has to conform to a \textbf{standard interface of \SYNEIGHT}
                %%   itself. This interface contains all methods which are required by
                %%   \SYNEIGHT to handle the state of entities, most prominently, this
                %%   interface allows the middleware to
                %%   \begin{itemize}
                %%   \item create, delete and clone encapsulated entity states,
                %%   \item marshal and demarshal the entire encapsulated state of
                %%     entities,
                %%   \item extract updates from these states after modifications
                %%   \item apply these updates to other states
                %%   \item bind an entity state of an application interface,
                %%   \item create a messaging stub and bind it to an application
                %%     interface.
                %%   \end{itemize}
                %% \item Second, it has to implement a set of \textbf{application
                %%     dependent interfaces}. These interfaces can be accessed by the
                %%   application by binding an entity state to an application interface.
                %%   \SYNEIGHT is designed in way that allows the application to use
                %%   arbitrary interfaces. 
                %% \end{description}
                %%Entity type implementations can be loaded into an \SYNEIGHT-based
                %%application dynamically. 
                %%
                The entity type implementation interface is the first central
                interface of \SYNEIGHT. It allows the application to define the types of
                the objects in a database in a very flexible way.
                %
                Using the entity type implementation directly allows an application
                programmer to design types for very specific requirements such as
                wrapping the load of a certain node into a cluster-wide accessible
                entity. However, it will be often used indirectly, i.e., a compiler
                will be used to generate entity type implementations from a more
                common type-description, such as a class implementation in a
                restricted C++ language.
                %
                Thus the main emphasis of this interface is flexibility, since the
                programmer is not expected to deal with this interface directly. 

                The design of \SYNEIGHT allows to handle the development of such a
                compiler completely separately. 
                %
                Therefore, it is possible to develop a simple prototype-compiler for \SYNEIGHT
                quickly by using one of the of the commonly employed meta-programming
                tools  \cite{amano98lead,
                berger98evaluation, chibaopencxx, chiba97efficient, jpr98simplify,
                sugita98specialization, raverdy98dart, chiba98pattern,
                haraszti99iguana,raverdy98dart}.


                \subsubsection{Development Stages}


                We introduced this interface, since it is fundamental to \SYNEIGHT. It must
                be specified entirely at the beginning of the implementation because
                of its central character. 

                \subsection{Entity Access Facade}
                \label{sec:entity-access-facade}

                \subsubsection{Accessing Entities}

                The entity access facade is used by the application developers to
                access the databases which are maintained by \SYNEIGHT.

                The access of entity-databases is explicitly transaction-oriented,
                i.e., the application-code has to explicitly open, commit and abort
                its transactions. 
                %
                Inside of a transaction-context, the application can access an
                arbitrary number of entities. There are three operations which are
                necessary to access a particular entity:
                %
                \begin{description}
                    \item First, the application has to \textbf{lock} a particular entity
                        by specifying the identity of the entity and the required lock-type
                        (We explain the different lock-types later in this subsection).
                        %
                        An entity can be locked several times within the same transaction,
                        however, such multiple locks might fail because of conflicting
                        lock-types.
                    \item Second, the application \textbf{binds} the entity to an
                        application interface. Again, the application might bind the same
                        entity several times to different interfaces, if the corresponding
                        entity type implementation supports multiple application interfaces.
                        %
                        Also there are two different types of bindings:
                        \begin{description}
                            \item[Local Access Binding:] Such a binding requires that the bound
                                entity state is maintained locally at the same node. 
                                %
                                Such a binding can be implemented very efficiently since it is
                                possible to call and execute the methods of the application
                                interface without any overhead.
                            \item[Remote Access Binding:] Such a binding does not require that
                                the bound entity state is maintained locally at the same
                                node. If no suitable entity state is located locally, then \SYNEIGHT
                                can either fetch the such an entity state and establish a local
                                binding or it can bind a stub to the application interface. In the
                                latter case, the arguments of each method invocation are
                                marshaled and sent to the remotely maintained state. Then the
                                arguments are demarshaled, the method is invoked, and the results
                                are marshaled, sent-back, demarshaled and presented to the
                                application. 
                                %
                                This feature is only applicable to an entity, if the underlying
                                entity type implementation supports the involved procedures. In
                                particular, it must be able to create a stub for the corresponding
                                interface (the interface which are supported for remote bindings
                                might differ from the interfaces which are supported for local
                                access bindings). The stub is responsible for marshaling and
                                demarshaling the messages.
                        \end{description}
                    \item After establishing a binding, the application \textbf{accesses}
                        the entity by calling methods of the application interface. Besides
                        the methods of the application interface, some other generic methods
                        are available, namely the destruction of the entity and the access
                        of the configuration state. The latter is also including the option
                        to change the entity type implementation of an entity\footnote{This
                        operation follows the model of \vref{sec:does-update-involve},
                        i.e., it allows to change the exchange the entity type
                        implementation of an entity without changing its identity.}.
                    \item Finally, the application has to \textbf{release} the locked and
                        bound entity-state. This can be done implicitly or explicitly. All
                        bindings and locks which are not released explicitly are released
                        when the transaction which served as their context is closed.
                \end{description}


                \subsubsection{Lock Types}


                %
                If an application successfully locks a particular entity, then the
                application has acquired a certain set of access permissions on the
                entity, depending on the specified access semantics. \SYNEIGHT provides
                two fundamentally different lock-types, namely six raw locks and
                a transactional lock. We start by describing the common properties of
                the raw locks and the characteristics of the transactional lock.
                %%
                %%First, we have to
                %%distinguish between seven different lock-types. The first six
                %%lock-types are so-called raw locks in contrast to the remaining
                %%lock-type, the transactional lock.
                \begin{description}
                    \item[raw locks.] A raw lock is only slightly controlled by the
                        transaction processing framework. The only interaction between
                        transactions and raw locks is that locks in general (and thus raw
                        locks in particular) can only exist in the context of a transaction.
                        Once the transaction used as context for acquiring a particular raw
                        lock is closed, the lock is also released.
                        %
                        However, all operations which are based on a raw lock
                        are immediately durable, i.e., if a transaction fails, the
                        operations which were done by employing a raw lock are not
                        undone.\\
                        %
                        The reason for providing raw locks is that they can be executed with
                        low overhead and form a useful basis for the more elaborate
                        transactional locks. 
                    \item The \textbf{transactional lock} allows the application to group
                        their modification of the database into transactions which are
                        committed to the database atomically, i.e., all operations which
                        were executed within one transaction and which were based on
                        transactional locks are either made durable at once (the transaction
                        can be committed successfully) or not at all (the commitment fails).
                        %
                        Whether a transaction can be committed successfully or not depends
                        on the further parameters of the involved transactional locks. 
                        %
                        \end{description}
                        %
                        We start now with a description of the six raw locks. They are ordered
                        according to the level of exclusiveness they are providing for the
                        lock-owner. 
                        \begin{description}
                            \item[Unlocked:] \SYNEIGHT allows an application to execute certain
                                operations without having a lock on the targeted entity. For such
                                operations, an application can acquire a lock of type unlocked.
                                Operations which are permitted under this lock-type are not
                                guaranteed to succeed, indeed it is not even guaranteed that the
                                targeted entity exists. 
                                %
                                It is only possible to use a remote access binding in the context of
                                such a lock, even if the entity is maintained locally, since \SYNEIGHT
                                will marshal all arguments of an invocation and will wait for a
                                situation when the entity is in an coordination state such that the
                                method can be invoked without conflicts. 
                                %
                                \item[Concurrent Read:] A concurrent read lock allows the application
                                    to invoke read-only operations on a potentially continuously
                                    changing entity state -- however, \SYNEIGHT does not guarantee the
                                    version which is presented to the application is completely
                                    up-to-date. Thus invoking the same read-only operation twice might
                                    result in two different results.\\
                                    %
                                    Nevertheless, all accesses are still protected by a short-term lock,
                                    i.e., before a reading method is invoked, a short-term lock is
                                    acquired which is released immediately when the method terminates.
                                \item[Concurrent Write:] If an entity is locked with a concurrent
                                    write lock, then other applications might write on the same entity
                                    at the same time (also by using a concurrent write lock). However,
                                    every single method invocation which is altering the locked entity
                                    is guaranteed to have exclusive access to the entity for the
                                    duration of the method invocation, i.e., the accesses are protected
                                    by short-term locks. 
                                    %
                                    Also, the concurrent write lock guarantees that no other transaction
                                    can gain a long-term lock (such as a protected read/write or
                                    exclusive lock) on the locked entity.
                                \item[Protected Read:] A protected read lock gives the application the
                                    guarantee that the locked entity is not altered as long as this lock
                                    is held by the application. Naturally, the application is also able
                                    to access the current entity state. 
                                \item[Protected Write:] If an entity is locked with a protected write
                                    lock, then the application has acquired the right to modify the entity
                                    exclusively. However, during a protected write, another transaction
                                    might hold a concurrent read lock. 
                                \item[Exclusive Lock:] Once a transaction holds an exclusive lock, no
                                    other transaction can acquire any lock on the entity. 
                            \end{description}
                            %
                            Now we turn to the properties of transactional locks. A transactional
                            lock can be read-only or read-write. In general, transactional locks
                            guarantee the application to get access to a stable state of an
                            entity, i.e., this state is only modified by the lock-owner (or is
                            completely read-only). Also, it is guaranteed that this state is not
                            an intermediate state, i.e., it is a state which has been committed
                            into the database. Thus, the internal consistency of the presented
                            state is guaranteed under any transactional lock.

                            In addition, each entity state which is accessed under a transactional
                            lock has an associated isolation-level. The isolation-level of a locked
                            entity state describes the guarantees which are associated with this
                            entity state with respect to all other entity states which are locked
                            within the same transaction.\\
                            %
                            For example, the states of two different entities which are locked
                            within a single transaction might be required to be mutually
                            consistent.


                            The isolation levels of \SYNEIGHT form a hierarchy, i.e., every
                            isolation-level includes the guarantees of the preceding ones. We
                            list them below, starting at the weakest (committed) and finishing
                            with the strongest (exclusive).
                            \begin{description}
                                \item[Committed:] The entity state versions which are accessible under
                                    this isolation level are only guaranteed to be committed. Therefore,
                                    if two entities are locked under this isolation level, it is
                                    perfectly possible that the first entity is accurately presented
                                    while the second one has been updated in the meantime.\\
                                    %
                                    If a transaction writes on an entity under this isolation level,
                                    then lost updates might occur, i.e., the entity might have been
                                    changed independently in the meantime.
                                \item[Monotone:] All entities which are locked under this isolation
                                    level (or a higher one) within the same transaction behave monotone
                                    with respect to the database development over time. More precisely,
                                    once an entity state is made accessible to the application which
                                    incorporates modifications of a transaction $T$, then every entity
                                    state which is locked afterwards must incorporate the changes of
                                    $T$.
                                    %
                                    The behavior in case of a modifying access is the same as for the
                                    committed isolation level. 
                                \item[Consistent:] This isolation level allows to lock a set of
                                    entities within a so-called consistency group, i.e., if one these
                                    entities reflects the effects of a transaction $T$, then all
                                    entities in this group must reflect the changes of $T$.
                                    %
                                    If an entity which is locked under the consistent isolation level is
                                    modified, then \SYNEIGHT enforces that no lost update occurs. 
                                \item[Accurate:] If an entity is locked under this isolation level,
                                    then the presented version must be up-to-date and no other
                                    transaction is allowed to change the entity in the meantime.
                                    This scheme corresponds to classic ACID-transactions.
                                \item[Pessimistic:] The isolation level accurate and pessimistic are
                                    interchangeable -- the correctness of a transaction is independent
                                    of this choice. However, such a change will have a strong impact on
                                    the performance of a transaction:
                                    %
                                    If an entity is locked with isolation-level pessimistic, then it is
                                    guaranteed that the corresponding transaction will succeed in
                                    validating the accesses this entity. In other words, once the
                                    transaction has a pessimistic transactional lock on all locked
                                    entities, it knows it will be committable.\\
                                    %
                                    This isolation-level is useful for accessing high-contention data,
                                    i.e., entities which are modified by many transactions concurrently
                                    such that conflicts arise often. Naturally, obtaining a pessimistic
                                    lock might fail more often than acquiring an accurate lock.
                                    %
                                    \item[Exclusive:] This isolation-level gives exclusive access to an
                                        entity, thus it subsumes the guarantees of pessimistic. This
                                        isolation-level is mainly used as a synchronization primitive. 
                                \end{description}

                                Furthermore, the required isolation-level of a locked entity state
                                can be expanded during the transaction, i.e., new guarantees can be
                                added to the already established set of guarantees by locking the same
                                entity again. 

                                In particular, \SYNEIGHT allows the application to specify an
                                isolation-level which is required immediately and another one which is
                                required directly before committing to the database. 
                                \begin{description}
                                    \item We call the first isolation-level the \textbf{running
                                        isolation-level}. The application uses the running isolation-level
                                        to specify the isolation-level which is required such that the
                                        transaction itself does not crash.\\
                                        %
                                        For example, a transaction might
                                        crash if the referential integrity of a set of entities is not
                                        guaranteed. In such a case, the application locks them under the
                                        running isolation-level consistent.\\
                                        %
                                        Summarized, the running isolation-level is used to ensure that the
                                        transaction itself does not crash. However, it does not ensure that
                                        the transaction can be committed correctly. 
                                    \item The second one is called the \textbf{commitment isolation-level}.
                                        This isolation-level is enforced during the commitment of the
                                        corresponding transaction. This isolation-level can only be stronger
                                        than the running isolation-level (since the isolation-level can only
                                        be expanded over time). 
                                        %
                                        The commitment isolation-level is used to describe the guarantees
                                        which are required for a transaction such that its outcome is
                                        correct.\\
                                        %
                                        For example, a transaction might access only two entities under the
                                        running isolation-level committed but might require a commitment
                                        isolation-level accurate. In this case, the transaction must
                                        be programmed such that inter-entity inconsistencies does not cause
                                        the transaction to crash, but the outcome of the transaction must
                                        only be correct, if the locked states of the two entities were
                                        up-to-date and are unmodified at the moment of commitment.
                                \end{description}
                                %
                                Both are specified whenever a transactional lock is acquired. \SYNEIGHT
                                allows the application to specify both isolation-levels immediately
                                for the following reasons:
                                \begin{itemize}
                                    \item In situations when both isolation-levels differ, it is less
                                        error-prone to specify both levels at the same time.
                                    \item The transaction processing internals of \SYNEIGHT can be implemented
                                        more efficiently, if \SYNEIGHT does not only know the current
                                        isolation-level but also the isolation-level which is finally
                                        required for commitment. 
                                \end{itemize}

                                %% \begin{description}
                                %% \item The \textbf{running isolation level} describes the guarantees
                                %%   which are required by the corresponding transaction to be executed
                                %%   properly. For example, if the referential integrity within a group
                                %%   of entities is violated, then a transaction which accesses these
                                %%   entities might crash. More precisely, if every transaction maintains
                                %%   the consistency of these entities, then a transaction which accesses
                                %%   this group of entities requires that the modification of any other
                                %%   transaction are either visible completely or not at all. Thus it is
                                %%   necessary to access these entities in isolation during execution.
                                %% \item Second, there is the \textbf{commitment isolation level}. This
                                %%   isolation level describes the degree of isolation which has to be
                                %%   ensured at commitment. For example, a transaction which transfers an
                                %%   amount of money from one account to another will run without
                                %%   crashing, even if the presented versions of the two accounts are not
                                %%   in consistent to each other. However, such a transaction can only be
                                %%   committed, if the employed versions of the two accounts were
                                %%   uptodate and no other transaction modified these accounts in the
                                %%   meantime. Therefore, such a transaction requires a weak running
                                %%   isolation level, but a strong commitment isolation level. 
                                %% \end{description}
                                %% %
                                %% The reason for employing both, the running and the commitment
                                %% isolation level is performance -- in some cases it is more efficient
                                %% to follow an optimistic strategy, i.e., to check some required
                                %% constraints when the transaction commits. On the other hand, some
                                %% transactions would be very error-prone, if it would be impossible to
                                %% ensure that the involved entity states are consistent to each
                                %% other. 
                                %% 
                                \subsubsection{Transactions}

                                The transaction framework of \SYNEIGHT provides sub-transactions. Each
                                sub-transaction can be committed separately -- if a sub-transaction
                                fails, it can be restarted without requiring to rerun the complete
                                transaction. However, the modifications of sub-transaction are only
                                made effective if the outer most transaction is committed
                                successfully.
                                \begin{description}
                                    \item[Nested transactions] form a stack, i.e., within a (nested)
                                        transaction, another nested transaction can be opened. Once a
                                        nested transaction is committed successfully, modifications
                                        which were done in the context of this nested transaction are
                                        guaranteed to be committable. Thus, nested transactions are used to
                                        group transactions recursively into blocks which are committed
                                        separately and which can be rerun if necessary.
                                    \item[Split transactions] allow the application to split the
                                        processing of a transaction into several threads, i.e., based on a
                                        single transaction several split transactions can be opened. Each of
                                        these split transactions can acquire locks on entities concurrently
                                        and independently, i.e., \SYNEIGHT guarantees that only one split
                                        transaction can write on an entity. 
                                \end{description}
                                %
                                The transactions of \SYNEIGHT are generally prioritized. A transaction
                                with a higher priority will be \textbf{preferred} in all
                                \textbf{queues} and might \textbf{break locks}.



                                \subsubsection{Development Stages}
                                \label{sec:development-stages}


                                The entity access facade consists of \textbf{interface classes}
                                which are visible to the application developer. These interface
                                classes include root, nested, and split transactions, as well as
                                bindings or rollback-points. These classes have to be designed in a
                                way which minimizes the dependency of the application on the internal
                                details of \SYNEIGHT.

                                The implementation of these interface classes will be built atop of
                                the \textbf{transaction monitor}\footnote{See subsection
                                \vref{sec:transaction-monitor}.} and the \textbf{metadata monitor}
                                \footnote{See subsection \vref{sec:metadata-monitor}.}.
                                %
                                In general, it is a design goal to keep the transaction monitor as
                                small as possible because of its inherent complexity, i.e., the
                                transaction monitor will be designed in as generic as possible.

                                So for example, we believe that it is possible to design the
                                transaction monitor such that it does not have to distinguish between
                                nested and split transactions but uses a more abstract sub-transaction
                                concept.

                                It is important to note that the entity access facade is designed to
                                be independent from the distribution capabilities of \SYNEIGHT, i.e., the
                                entity access facade is not implemented differently for a
                                single-server system and for a distributed system.

                                Also, to obtain a complete specification of the \SYNEIGHT interfaces, we
                                believe that the structure of the complete entity access facade should
                                be written out as soon as possible. Thus the development can be
                                structured into 

                                \begin{description}
                                    \item[Interface] The first step in the development of the entity
                                        access facade is the implementation and the documentation of all
                                        \textbf{interface classes}. This formalized specification of the
                                        entity access facade will also allow the development team to derive
                                        a precise specification of the transaction monitor.
                                    \item[Protected Access] As a next step, the \textbf{transactions
                                        (without sub-transactions)} and the lock-types \textbf{protected
                                        read and protected write} must be implemented. This stage will
                                        allow to make the first test-runs on the system -- we want to
                                        establish a prototype which employs all components together as soon
                                        as possible.
                                    \item[Raw Access] In the third stage, the remaining raw locks have to
                                        implemented. This stage already allows to use \SYNEIGHT in a restricted
                                        manner -- nevertheless, serious performance tests can be already
                                        implemented and will be valuable as feedback for the future phases.
                                    \item[Full Transactions] This stage introduces the
                                        \textbf{transactional locks} with the \textbf{isolation levels
                                        committed} and \textbf{accurate}. This version can be used as
                                        production system -- the remaining features are important but not
                                        essential. Full transactions will require the implementation 
                                        of rollbacks, i.e. the ability to make former changes undone. 
                                    \item[Completion] The final phase introduces the remaining isolation
                                        levels. 
                                \end{description}



                                \subsection{Meta Access Facade}
                                \label{sec:meta-access-facade}


                                \subsubsection{Revisions}
                                \label{sec:revisions}

                                Each database can contain several \textbf{revisions}, each
                                revision is a collection of entities which either represents the
                                current state of the corresponding database or a frozen database
                                state.\\
                                %
                                When a database is created, it contains a single, empty revision. This
                                revision can be loaded and manipulated, by creating, modifying and
                                deleting entities. The following operations are available on a
                                revision as a whole and must be made available through the meta access
                                facade.
                                \begin{description}
                                    \item[Loading] a revision. This might sound like a trivial task,
                                        however, in the distributed case,  inconsistencies can arise between
                                        the different nodes. Therefore, corresponding protocols must ensure
                                        the mutual consistency of the distributed and shared databases.
                                        %
                                        Clearly, a revision can be \textbf{unloaded}.
                                    \item[Activating] a revision. Initially, after loading a revision, it
                                        is still passive. To make it available for modifying access it needs
                                        to be activated.
                                        %
                                        On the other hand, a revision can be \textbf{deactivated} again.
                                        %
                                        If a revision is passive, it cannot be altered. This state will be
                                        used for on the fly backups -- the current revision is deactivated,
                                        another is created a top of it (see the next item in this list) and
                                        the passive revision is stored on disk in the background.\\
                                        %
                                        The activation of revision implicitly requires the corresponding
                                        process to serve its peers if they request the process to perform
                                        any operation on the revision.
                                    \item[Creating] a revision atop of another passive revision. This
                                        operation makes a new revision available, which is based on the
                                        other passive one. The new revision is initially identical to the
                                        passive one, and can be modified in any way. It is also possible to
                                        create several revisions atop of a single passive revision. This is
                                        a useful feature to work with several extensions of the same
                                        database simultaneously. We refer to this mechanism as
                                        \textbf{revision chaining}.
                                    \item[Locking] a revision. An application can lock an entire revision
                                        to gain exclusive access to it. This is for necessary to perform
                                        revision-global offline and online updates. The lock prevents any
                                        other application from reading or writing into the revision. 
                                    \item[Completing] a revision. A revision which is built a top of
                                        another one might not be complete, i.e., only entities which are
                                        modified in the new revision are copied. Indeed only the
                                        table entries of those entities which are accessed in the new
                                        revision are copied.\\
                                        %
                                        Completing a revision can be done at two levels:
                                        \begin{description}
                                            \item[Index Completing] refers to the process of copying the
                                                complete index from the older revision into the new one.
                                            \item[Data Completing] is the process of copying all entities,
                                                independently of whether is has been modified or not. Data
                                                completing implies index completing. 
                                        \end{description}
                                        %
                                        The predecessor of a loaded revision in the revision-tree can be
                                        unloaded if and only if the loaded revision is data-complete.
                                    \item[Deleting] a revision. A revision can be deleted, if it is not an
                                        ancestor of an incomplete revision and if it is passive (or
                                        unloaded).
                                    \item[Updating] a revision. The global updating mechanism is
                                        implemented in terms of revisions. To initiate a global update, the
                                        application can install a filter\footnote{See subsection
                                        \vref{sec:how-does-update}.}.  A process which wants to install a
                                        filter has to acquire the corresponding revision-global lock.  
                                    \item[Iterating] through a locked or passive revision. This mechanism
                                        will be used for example to store a backup of the revision. It can
                                        also be used for offline database updates.  Since the revision can
                                        be distributed over a number of nodes, and no node might have the
                                        complete index available, the application can issue a conditional
                                        iteration, i.e., a predicate is used to determine whether an entity
                                        should be included in the enumeration.  Each node is subsequently
                                        reporting the identities of the matching entities, and a complete
                                        index of the corresponding subset is created and iterated through.
                                    \item[Renaming ] a revision. This allows the application to drop a
                                        revision in the case of inconsistencies and to go on with a blank
                                        revision. For example, if a node crashes, after rebooting, it might
                                        rename its old revision and start a blank revision. This allows to
                                        re-integrate the node into the cluster, and it also allows a
                                        developer or an administrator to inspect the last database-state
                                        before the node crashed away. 
                                    \item[ETI Handling] subsumes a list of operations related to entity
                                        type implementation. Each entity type implementation which should be
                                        available within a revision must be loaded into the revision. Each
                                        application which subsequently wants to access this revision must
                                        have loaded the corresponding entity type implementations. Also, it
                                        must be possible to remove an unused entity type implementation from
                                        a revision.
                                \end{description}


                                \subsubsection{Databases}

                                The revision management occupies the largest part of the meta access
                                interface. At the database global scale, it remains to bookkeep the
                                currently used and available revisions. The operations available on
                                the database level are following.
                                %
                                \begin{description}
                                    \item[Loading] a database. This operation allows the application to
                                        access the revisions of the corresponding database. Again, as in the
                                        case of revisions, this operations is complicated in the context of
                                        distributed environment, since the different nodes have to exchange
                                        their metadata on the database and agree on a common view. 
                                        %
                                        A database can be loaded from disk or from peer nodes. 
                                    \item[Activating] a database. Once a database is activated, the
                                        processes are able to access the revisions of the database. 
                                    \item[Locking] a database. This can be done at two levels: First the
                                        database can be locked to modify its metadata (e.g. create a new
                                        revision) without locking any currently open revision. The stronger
                                        lock allows to lock the entire database and prohibit any access to
                                        the database and its revisions.
                                    \item[Renaming] a database. This can only be done, if the database is
                                        not activated. 
                                \end{description}


                                \subsubsection{Processes}
                                \label{sec:processes}

                                The meta access facade has to provide interfaces to configure the
                                processes which are connected with each other to form a cluster. A
                                group of processes which is accessing concurrently and
                                collaboratively a set of databases is called \textbf{peer group}.\\
                                %
                                The peer group defines a context which is the basis for accessing any
                                database -- thus a database has to be loaded into a peer group. Each
                                process has to load its fragment of a database into the peer group,
                                the different fragments of the same database are put together within
                                the peer group. Therefore, the peer group is also responsible for
                                determining the consistency status of a database fragment which is
                                maintained by a process.

                                To get access to a peer group, a process has to set up a corresponding
                                logical networking manager\footnote{See subsection
                                \vref{sec:logic-netw-manag}.}. The logical networking manager allows
                                the process to browse and enter the peer groups which are accessible
                                over the corresponding networking system.

                                There is also a special peer group which is only containing the local
                                process, the \textbf{private peer group}. 

                                Once a process enters a peer group, it can subsequently load
                                database fragments from stable storage and make them available to the
                                peer group. Once enough fragments are loaded, the database as a whole
                                can be activated, which allows the corresponding processes to access
                                the revisions of the database. If a database is activated, no process
                                can load another fragment of the database, it is treated as
                                inconsistent from that moment on, i.e., the common view of the peer
                                group is defining the consistency of the database. 

                                Finally, the process can give control over itself to the peer group,
                                i.e., it can allow any application which participated within the peer
                                group to change the process configuration. The different process-level
                                configurations are listed in the following.

                                \begin{description}
                                    \item[Module Management:] \SYNEIGHT is a framework which is designed to
                                        place most of its functionality into compact modules. These modules
                                        can be linked statically or can be assembled into dynamically linked
                                        libraries. Examples for such modules include ETIs, requests, stable
                                        storage channel managers, and logical network channel
                                        managers\footnote{See the subsections \vref{sec:entity-type-impl},
                                        \vref{sec:request-factory}, \vref{sec:stable-stor-manag} and
                                        \vref{sec:logic-netw-manag} respectively.}. Clearly, modules can
                                        be unloaded again if they are not in use anymore.
                                    \item[Stable Storage Organization:] The stable storage which is
                                        available to a process is configurable -- after loading a specific
                                        stable storage manager, the process can open with it a specific 
                                        stable storage channel.
                                    \item[Logical Network Organization:] Once a process loads a given
                                        logical network manager, it can use this manager to open a
                                        correspondingly configured logical network channel.
                                    \item[Handling Peer Groups:] A process can create, enter, leave and
                                        destroy (if it is empty) peer groups. 
                                    \item[Resource Control:] The resources of a process such as the size
                                        of the entity table, the number of internally used threads are
                                        subject to configuration. The precise configuration parameters are
                                        not determined yet, however, they will be accessible through the
                                        meta access facade.
                                \end{description}

                                \subsubsection{Development Stages}
                                \label{sec:development-stages-3}

                                Planning the development of the metadata handling is crucial in the
                                development of \SYNEIGHT. It is the final goal, to access the revisions,
                                databases and processes in terms of ordinary transactions, i.e., all
                                metadata is wrapped again into special system databases. But this goal
                                cannot be achieved directly since the transaction monitor and the
                                entity access facade need to be developed first while they already
                                need the metadata monitor. The meta access facade is also required
                                from the very beginning, since it will be used to open a database or
                                to load request-modules into the system.


                                The meta access facade is designed to be independent of the underlying
                                representation of the metadata, i.e., it must be possible to replace a
                                non-distributed metadata model with a distributed one without
                                jeopardizing the meta access facade. 

                                \begin{description}
                                    \item[Dummy Metadata:] This stage is only providing the interfaces to
                                        the entity access facade, for example the entity access facade will
                                        have to know which entry to use to access a specific revision in the
                                        entity table of the transaction monitor.\\
                                        %
                                        On the other hand it is not necessary to build the complete revision
                                        management to develop the entity access facade and the transaction
                                        monitor, i.e., all features mentioned here are left out -- since
                                        only the \textbf{interface to the entity access facade} matters.\\
                                        %
                                        This interface will be backed by a dummy implementation which allows
                                        to place an arbitrary revision into the metadata monitor. Also, only
                                        this interface will be used in the following stages.
                                        %
                                        In particular, the meta access facade will provide direct access to
                                        the metadata monitor instead of wrapping it entirely. 
                                    \item[Single Server:] As long as \SYNEIGHT is not working a distributed
                                        manner, the metadata is also not required to be distributed.
                                        Therefore, the single server stage is only required to provide a
                                        classical object orient interface.
                                        %
                                        However, the \textbf{interface of the metadata access} is completed
                                        and frozen in this stage.
                                        %
                                        The development is further subdivided into the following milestones:
                                        \begin{description}
                                            \item[Revision Handling:] This stage includes the revision handling
                                                features. However, revisions are still isolated insofar as they
                                                are not positioned in the context of database. Instead, revisions
                                                are introduced and chained directly with the the meta access
                                                facade.
                                                %
                                                This stage will still require some direct access to the metadata
                                                monitor. 
                                            \item[Database Handling:] This includes the complete database and
                                                revision handling. From that point on, no direct calls to the
                                                metadata monitor are required. All remaining features (such as
                                                module management) are controlled directly, i.e., the metadata
                                                monitor as well as the meta access facade are bypassed. 
                                            \item[Interface Completion:] This step requires the integration of all
                                                remaining features into the meta access facade. Module
                                                management is integrated as well as the process resource
                                                control and the peer group management.
                                        \end{description}
                                    \item[Metadata Persistence:] Since the metadata will be wrapped into
                                        common databases, and by doing so distribution as well as
                                        persistence will be made available, to complete the entire
                                        development it is not necessary to provide an extra persistence
                                        layer for the metadata.\\
                                        %
                                        On the other hand, if the single server is used in the mean time, it
                                        will be necessary to implement a metadata persistence layer in
                                        addition -- to be thrown away later.
                                    \item[Distributed Server:] Once \SYNEIGHT support the distributed access
                                        of databases, it will be required to distribute the metadata as
                                        well. This will be done by employing the common distribution
                                        capabilities of \SYNEIGHT. In consequence, all the object-classes which
                                        are part of the meta access facade (such as revisions, databases,
                                        processes) have to wrapped into entity type implementations.\\
                                        %
                                        Once that happened, there are two ways to access the metadata:
                                        \begin{description}
                                            \item First, the metadata can be accessed \textbf{over the metadata
                                                access facade}. Such an access will utilize the interface which
                                                has been frozen during the single server development. All arising
                                                synchronization issues are handled by the metadata monitor, i.e.,
                                                it will issue the corresponding transactions internally.
                                            \item Second, the metadata can be accessed \textbf{directly in terms
                                                of the underlying system databases}. Since all metadata will be
                                                wrapped internally into common databases, the application will
                                                have the option to manipulate these databases directly. This form
                                                of access gives the application a wider range of possibilities,
                                                but at the same time, this interface will be much more
                                                complicated.
                                        \end{description}
                                        %% only the very first accesses to the meta access facade use direct
                                        %% access. All subsequent requests will be formulated as ordinary
                                        %% transactions. For example, a process will be join a peer group by
                                        %% direct access. Then, in the context of a transaction, a peer group
                                        %% object will be bound and used to load a database. The database
                                        %% object itself will be bound again, and used to load a revision,
                                        %% etc.
                                        The meta access facade is only required to be extended such that the
                                        application can get access to the internal meta-databases.
                                \end{description}


                                \subsection{Transaction Monitor}
                                \label{sec:transaction-monitor}

                                The transaction monitor is completely responsible completely for the
                                coordination of the transactions.
                                %
                                To separate the transaction monitoring from the metadata monitoring,
                                the transaction monitor maintains revisions based on a stable
                                storage channel and a local network channel. 
                                %
                                The stable storage channel allows the transaction monitor to read and
                                write from the persistently stored database while the logical network
                                channel allows the transaction monitor to communicate with other nodes
                                in the cluster. 
                                %
                                However, both interfaces are generic, i.e., the transaction monitor is
                                not burdened with the implementation details of the networking and
                                stable storage management. Indeed, the transaction monitor does not
                                even know the concept of a database -- it will use the revision
                                data-structure to load the accessed entities from disk or request them
                                from a peer in the cluster.
                                %
                                %
                                The main components of the transaction monitor are described in the
                                following subsections.


                                \subsubsection{Cache}

                                The cache maintains all necessary information on currently
                                loaded revisions and its entities. It fulfills three functionalities,
                                namely
                                \begin{description}
                                    \item[Revision Table] The revision table contains for each
                                        loaded revision an entry which describes the state of the revision
                                        and which refers to a possible predecessor of this revision.
                                    \item[Entity Table] The entity table is maintaining instances of
                                        those entities which are accessed recently. The access can be either
                                        locally or remotely issued -- the entity might be only present as a
                                        passive replica.\\
                                        %
                                        However, to be able to implement the more advanced transaction
                                        processing features of \SYNEIGHT efficiently, the entity table will even
                                        maintain two copies of the same entity at the same time, one is used
                                        for write-accesses, while the other one serves as a backup in the
                                        case of an aborted transaction. The second copy will be used
                                        for read-only accesses and will be updated when the changes to first
                                        copy are committed successfully by the application.\\
                                        %
                                        The entity table must swap out infrequently used entities.
                                    \item[Coordination Bookkeeping] Second, the entity table contains the
                                        current coordination state (described in the next subsection) of
                                        each locally maintained entity-instance. The coordination state is
                                        internally maintained by \SYNEIGHT and contains management information
                                        such as the distribution state the locking state of a entity.
                                        %
                                        Basically, it has to contain all information which is necessary for
                                        \SYNEIGHT to coordinate all the complete transaction processing. 
                                \end{description}


                                \subsubsection{Entity Coordination State}

                                The coordination state of each entity is based on a finite state
                                machine whose states are abstractions of the complete coordination
                                state -- we call these state abstract coordination states. 
                                %
                                This finite state machine will determine how to react on any
                                specific application request.

                                We are employing state machines for this purpose since this will allow
                                to describe an entity's collective\footnote{See subsection
                                \vref{sec:entities}.} as a set of state-machines (one state machine
                                for each instance) which are changing their state because of internal
                                communication and because of external inputs. Such a model can be used
                                as a basis for formal verification procedures.

                                The state machine is certainly the core of the transaction monitor --
                                therefore it has to be designed with great care.
                                %
                                The complete coordination state includes 
                                \begin{itemize}
                                    \item the current lock-holders (if any),
                                    \item references to pending locking requests, 
                                    \item incoming messages which are generated by remote method invocations, 
                                    \item the distribution state (i.e., which nodes are maintaining a
                                        copy of the entity),
                                    \item and the distribution configuration (i.e., which nodes are
                                        allowed to hold a copy of the entity, and how many nodes must hold a
                                        copy of the entity simultaneously),
                                    \item incoming updates from other nodes,
                                    \item the stable storage state of the entity,
                                    \item the relationship between the two copies of the entity state,
                                        i.e., which one is accurate, and which update will make the
                                        older copy accurate,
                                    \item the rollback points between the old and new copy.
                                \end{itemize}
                                %


                                \subsubsection{Transaction Table}

                                The transaction table contains all currently running transactions
                                which are directly or indirectly accessing the corresponding node. On
                                each transaction This table contains and monitors the following
                                information :
                                \begin{description}
                                    \item The currently open \textbf{sub-transactions} and their internal
                                        structure.
                                    \item The \textbf{locks} and their specific state. If the application
                                        tries to lock or bind an entity, this table is checked first.
                                \end{description}



                                \subsubsection{Request Factory}
                                \label{sec:request-factory}

                                The request factory is used by other components to place requests in
                                the transaction monitor. The transaction monitor treats any method as
                                request which might be blocked. 
                                %
                                Every request can be executed in a blocking, asynchronous, or timed
                                manner. The \textbf{request interface} will be the basis for any
                                kind of request to be answered by the transaction monitor.
                                %
                                The general properties of a request are the following:
                                \begin{itemize}
                                    \item Every request can be constructed by a corresponding
                                        \textbf{factory method}. This method either
                                        \begin{itemize}
                                            \item executes the request immediately and returns without creating
                                                an explicit request object, or
                                            \item creates the a request-object and returns without completing
                                                the request. In this case, the request is registered in one queue
                                                of the request broker (described next), at the corresponding
                                                resource, and in the completion port of the caller. The completion
                                                port is an object which allows a caller to wait for the
                                                completion of several requests simultaneously and is comparable to
                                                the future pattern\cite{schmidt00}.
                                        \end{itemize}
                                    \item Requests execute storage and networking calls asynchronously and
                                        interrupt themselves if they have to wait for some temporarily
                                        unavailable resource. In such a case requests suspend themselves
                                        return to the caller. They can be resumed subsequently at the point
                                        where the interruption occurred.
                                        %
                                        For example, if a request requires a lock which is temporarily
                                        unavailable, the request will suspend itself and return to the
                                        caller. The calling procedure might issue a number of other
                                        operations in the meantime. When the conflicting lock is released,
                                        the original request is resumed and might be completed
                                        successfully. 
                                        In such a case, when the caller resumes the original request, the
                                        request is already processed and the results are available
                                        immediately. 
                                    \item Requests have a short execution time (not counting possible
                                        interruptions). 
                                    \item Requests can be marshaled, thus they can be sent over the
                                        logical networking channel to another node for processing. 
                                    \item Requests can issue other requests. The ability to build complex
                                        requests out of simpler ones will be important for the later stages
                                        of development.\\
                                        %
                                        For example there will be set of requests which deal with the
                                        distribution of entities. Atop these requests, another layer of
                                        requests will be built, which is not only distributing entities but
                                        is also enforcing its distribution configuration.
                                \end{itemize}


                                \subsubsection{Request Broker}

                                This component is maintaining a list of pending requests which could
                                not be satisfied immediately such as a lock request which has been
                                blocked by another already established lock. The request broker must
                                also take the priorities of transactions in account, i.e., maintaining
                                for all resources priority queues. 
                                %
                                The request broker is responsible for coordinating between these
                                conflicting requests. Also, it has to abort requests which exceeded
                                their time-limits (all operations of \SYNEIGHT which are possibly blocked
                                take as an optional parameter a time-out).



                                \subsubsection{Request Library}


                                Examples of requests are acquiring and releasing locks, opening,
                                committing and aborting of transitions, all operations which are
                                related to the distribution of entities.

                                These requests are implemented in terms of modules which are loaded 
                                into the request factory. This design allows a flexible development
                                of the transition monitor since it is subdivided into a framework and
                                a set of plug-ins, the requests. 



                                \subsubsection{Development Stages}
                                \label{sec:development-stages-4}

                                %
                                The transaction monitor is designed to be a relatively small component
                                which is dealing with the most fundamental transaction processing
                                issues. Because of the complexity of the arising coordination issues,
                                it will be a challenge to debug this module. Most errors will only
                                arise under certain race conditions and might render themselves as
                                almost impossible to reproduce. Therefore, the core algorithms and
                                protocols should be verified formally on a conceptual level. 

                                \begin{description}
                                    \item[Interface] The interface of this component should be specified
                                        completely at the beginning. Although only parts of it will be
                                        filled with implementations, already in this stage, it is important
                                        to oversee the complete functionality of this component. 
                                        %
                                        This will include the request factory and the interface which allows
                                        other components to load a given revision into the transaction
                                        monitor. 
                                    \item[Internal Framework] The two central data-structures, i.e., the
                                        cache and the transaction table, as well as the request broker
                                        compromise the internal framework. The interfaces of these modules
                                        must be complete. However, the following features are postponed to
                                        later steps:
                                        \begin{itemize}
                                            \item The management of the revision chaining in the cache.
                                            \item The support for sub-transactions in the transaction table.
                                            \item The prioritized handling of requests within the request
                                                broker.
                                        \end{itemize}
                                    \item[Single Server Coordination] The following sub-stages follow the
                                        corresponding stages of the entity access facade -- each of these
                                        stages will require an expansion of the feature set of the
                                        transaction monitor\footnote{See subsection
                                        \vref{sec:development-stages}.}.
                                        \begin{itemize}
                                            \item Protected Access
                                            \item Raw Access
                                            \item Full Transactions
                                            \item Complete
                                        \end{itemize}
                                        %
                                        These expansions will effect the request library, the entity state
                                        machine and the transaction table.
                                    \item[Stable Storage] This stage adds the capability to load and store
                                        entities by employing the stable storage channel, consequently, it
                                        requires the complete specification of the corresponding interface
                                        along with a simple implementation, i.e., it requires the ``RAM
                                        Implementation'' milestone of subsection
                                        \vref{sec:development-stages-1}. This stage will include further
                                        additions in the request library and an expansion of the state space
                                        of the entity state machine.
                                    \item[Revision Chaining] In this stage the chaining of revisions is
                                        added to the entity table. 
                                    \item[Single Server] The completion of the milestones ``stable
                                        storage'', ``revision chaining'' and the ``single server''
                                        milestone of the metadata monitor\footnote{See subsection
                                        \vref{sec:development-stages-2} }allows to employ \SYNEIGHT fully
                                        features as single server system.
                                    \item[Distributed Server] This is definitely the largest step in the
                                        development of the transaction monitor. It has to synchronized with
                                        the development of the logical network manager and includes vast
                                        expansions in terms of the entity state space and the request
                                        library. The following sub-stages should be implemented:
                                        \begin{description}
                                            \item[Distribution Requests:] These requests allow to replicate an
                                                entity between several nodes. Examples for such requests are
                                                asking all other peers whether a certain entity exists, fetching
                                                an entity state, pushing an entity to another node, updating an
                                                entity which resides at another machine, sending a message to an
                                                entity which resides on another node. Having these requests in
                                                place, one can start to implement the transaction processing atop
                                                of them.
                                            \item[Distributed Transaction Requests:] These requests include the
                                                opening of a remote transaction, the locking of a remote entity,
                                                the committing or the aborting remote transactions. This phase
                                                has to be done in stages, following the stages ``protected
                                                access'', ``raw access'' and ``full transactions'' again. 
                                            \item[Distribution Policy Integration:] Having the distributed
                                                transaction processing in place, the fault-tolerance constraints
                                                must be integrated, i.e., the middleware must ensure that the
                                                required number of replicas is always existing. This stage
                                                requires to implement a second layer atop of the distribution
                                                requests. Instead of directly requesting an entity state, the
                                                a corresponding higher level request is used. This request will
                                                use the low level request, however, it will also enforce the
                                                distribution policy. For example, such a request might delete
                                                another replica, since a new is created locally. 
                                        \end{description}
                                \end{description}



                                \subsection{Metadata Monitor}
                                \label{sec:metadata-monitor}

                                The metadata monitor is responsible for maintaining the \SYNEIGHT-internal
                                components and data in a consistent fashion. The metadata can be
                                structured into the following areas as listed in subsection
                                \vref{sec:entity-access-facade}:
                                %
                                \begin{description}
                                    \item[Database-wide] This metadata is associated with databases and
                                        revisions directly. It is maintained within a special system
                                        revision within each database.
                                    \item[Process-Wide] The metadata on processes used for two
                                        main-purposes: First, by making the local as well as the remote
                                        processes available to any application, it can configure these
                                        processes as required by the application. Second, it is used to
                                        determine whether a process is able to access a given database or
                                        revision. For example, a process cannot access a revision which
                                        contains entities whose entity type implementation is not loaded
                                        into this process.
                                \end{description}
                                %

                                \subsubsection{Registries}

                                The module manager is wrapped into the meta monitor such that it is
                                also accessible to the other remote processes. However, all specific
                                modules of \SYNEIGHT are further managed by registries within the metadata
                                monitor. There are four module registries within the metadata monitor.
                                \begin{description}
                                    \item[Kernel Modules] At the moment, it is only planned to implement
                                        requests as modules. Later in the development, further parts of the
                                        kernel might be considered to be exported into modules.
                                        %
                                        Independently of this decision, \SYNEIGHT must know which modules are
                                        loaded into the \SYNEIGHT kernel. Different modules sets might lead to
                                        incompatibilities, therefore, each \SYNEIGHT-enabled process must be
                                        able to announce its own kernel module configuration before entering
                                        in communication with any other \SYNEIGHT-enabled process.
                                    \item[ETIs] Likewise, an \SYNEIGHT-enabled process must have all ETIs
                                        which are in use by a given revision to be able to load
                                        it. Therefore, \SYNEIGHT needs to reflect on the accessible ETIs. 
                                    \item The repositories on \textbf{Stable Storage Managers} and
                                        \textbf{Logical Network Managers} are used by \SYNEIGHT-enabled
                                        processes to load databases and to enter in communication with other
                                        processes. To wrap it reflectively into metadata allows 
                                        \SYNEIGHT-enabled processes to reconfigure other processes by using the
                                        meta access facade. 
                                \end{description}
                                %
                                %%Each of these registries have specific features, especially in terms
                                %%of their lookup procedures, i.e., the algorithm which chooses a
                                %%specific module for a certain application. For example, the
                                %%ETI-registry contains all information which is necessary to decide
                                %%which ETI must be chosen to create a new entity. This is not trivial,
                                %%since the application can load different versions for the same
                                %%application type. Thus, the ETI-registry has to distinguish logical
                                %%types and their implementation and has to maintain a mapping between
                                %%them.


                                \subsubsection{Directories}

                                In addition, the metadata monitor has directories for all remaining
                                metadata which is not available directly through the database and
                                revision metadata.

                                \begin{description}
                                    \item[Logical Network Channel] and \textbf{Stable Storage Channel Directory:}
                                        All currently open channels are listed in these directories along
                                        with their configuration data. 
                                    \item[Peer Group Directory:] All peer groups which are reachable over
                                        the currently open logical network channels are listed in this
                                        directory.
                                    \item[Process Directory:] Each process which is a member of a
                                        currently open logical network channel is represented by an entry in
                                        this directory. By default, a process entry is read-only accessible
                                        to other processes, however, every process can delegate its control
                                        to a single peer group. Then all other processes within the same
                                        peer group can manipulate the given process entry. A process entry
                                        gives access to all metadata of the corresponding process and allows
                                        its manipulation.
                                    \item[Database Directory:] The database directory lists all currently
                                        opened databases and their revisions. This directory is used by the
                                        entity access facade to for any access to find the right entries in
                                        the entity table of the transaction monitor. 
                                \end{description}
                                %%
                                %%\begin{itemize}
                                %%\item opened logical network channels
                                %%\item opened stable storage channels
                                %%\item loaded databases
                                %%\item process statistics and general configuration (such as the
                                %%  current load, the currently used main memory and its limit, or the
                                %%  number of internally used threads)
                                %%\end{itemize}
                                %%%


                                \subsubsection{Metadata Distribution}

                                All the metadata must be distributed for the full-featured version of
                                \SYNEIGHT. The concept followed here is to use the common distribution
                                mechanics of \SYNEIGHT to distribute this metadata. Thus, \SYNEIGHT has to
                                contain a number of meta databases which distribute the metadata
                                over the involved the processes. 

                                \begin{description}
                                    \item[Peer Group Meta Database:] Each peer group comes with a meta
                                        database which contains all processes which are currently in the
                                        peer group. If a process delegates its control to this peer group,
                                        the peer group meta database does not only allow to read the
                                        current state of the process but also allows to control the entire
                                        process, i.e., all metadata of the process can be modified. 
                                    \item[Meta Peer Group:] When a process opens a logical network
                                        channel, it implicitly enters a corresponding meta peer
                                        group. This peer group is used to list all peer groups which are
                                        available on the corresponding logical network channel. Moreover,
                                        since each peer group comes with a meta database, each process can
                                        inspect all processes which opened the same logical network
                                        channel. 
                                    \item[Meta Revision:] Each database contains a meta revision, which
                                        contains all metadata which is associated with a database, i.e., its
                                        revision structure, the processes which have been accessing it, the
                                        used ETI etc.
                                \end{description}



                                \subsubsection{Development Stages}
                                \label{sec:development-stages-2}

                                The development of metadata monitor can be divided into three layers
                                such that almost no code has to be thrown away during the development.
                                The only exception is the very first implementation which is only used
                                to serve as a development environment for the transaction monitor and
                                the entity access facade. The three layers are:
                                \begin{description}
                                    \item[Local Representation:] This layer contains a local
                                        representation of the registries and of the directories. Thus it is
                                        complete implementation of the metadata monitor -- it is only
                                        lacking the distribution. It is important that the interface of the
                                        local representation implementation is the same as the one of the
                                        final metadata monitor. 
                                    \item[Meta Databases:] This layer wraps the local representation into
                                        the meta databases, i.e., it adds the distribution of the meta data.
                                        To do so, it utilizes and controls the local representation layer.
                                    \item[Adaption:] This layer integrates the meta database and the local
                                        representation: Since the metadata is mostly read, for all common
                                        read accesses, the local representation will be used. However, when
                                        the meta data is changed, instead of operating on the local
                                        representation, the adaption layer delegates the request to the meta
                                        databases, which will if the corresponding transaction succeeds,
                                        update the local representation as well. 
                                \end{description}
                                In general, the stages of the metadata monitor mirror the stages of
                                the meta access facade, see subsection \vref{sec:development-stages-3}.

                                \begin{description}
                                    \item[Registries and Dummy Directories:] This milestone provides the
                                        interface for the entity access facade which is required for every
                                        access to an entity. This stage requires the implementation of 
                                        \begin{description}
                                            \item[All registries] since they are needed to assemble a runnable
                                                \SYNEIGHT-instance. 
                                            \item[Dummy Database Directory] which is needed by the entity access
                                                facade to access an entity. The database directory has two
                                                interfaces, one for the entity access facade and another one for
                                                the configuration by the meta access facade. While the former must
                                                be completed, the former can defined in any way which is
                                                convenient for development. 
                                        \end{description}
                                        The completion of the milestone allows the entire development of the
                                        entity access facade and of the transaction monitor. The meta access
                                        facade can be implemented up to the dummy metadata milestone. 
                                    \item[Single Server:] The single server implementation has to provide
                                        the local representation and to make it directly accessible, i.e.,
                                        the interface of the metadata monitor delegates all requests to the
                                        local representation. The sub states of the single server
                                        implementation follow the sub-stages of single server implementation
                                        of the meta access facade. 
                                    \item[Distributed Server:] This implementation adds the meta databases
                                        and the adaption layer. This milestone has following sub-stages:
                                        \begin{description}
                                            \item[Manual Distribution:] The internal data-structures are
                                                manually configured for distributed operation, i.e., instead of
                                                using the interface of the metadata monitor, special applications
                                                set the meta data manually. This stage is used to establish the
                                                first running distributed system. This stage will be used to
                                                develop distributed server phase of the transaction
                                                monitor\footnote{See subsection \vref{sec:development-stages-4}.}
                                            \item[Meta Databases:] The meta databases are implemented as
                                                ordinary databases, i.e., their entity type implementation are
                                                designed and implemented. This phase allows the testing of the
                                                databases atop of a stable system, namely the single server
                                                implementation. This stage can be implemented in parallel to the
                                                last milestone.
                                            \item[Adaption:] This stage integrates the local representation and
                                                the meta databases, as described above. The integration will start
                                                with the meta revision, followed by the peer group meta database
                                                and finish with the meta peer group. 
                                        \end{description}
                                \end{description}


                                \subsection{Stable Storage Manager}
                                \label{sec:stable-stor-manag}

                                The stable storage management is responsible for storing and
                                retrieving the entities of revisions onto stable storage. To do so,
                                \SYNEIGHT allows the application to load so called stable storage managers
                                into the framework. Each stable storage manager is dedicated to
                                certain type of stable storage such as a file, an entire partition of
                                a hard-disk, or a relational database.\\
                                %
                                A stable storage manager allows the application to open \textbf{stable
                                storage channels}. A stable storage channel gives \SYNEIGHT access to a
                                set of entities where the channel treats entities as blobs, i.e.,
                                entities are byte-streams of variable sizes and are associated with a
                                unique numeric key.
                                %
                                The functionality of a
                                \begin{description}
                                    \item[stable storage channel] are the classical tasks of a simple
                                        indexed table, i.e., inserting, deleting, updating, searching,
                                        enumerating the contents of the table. The channel must also be able
                                        to delete itself entirely. 
                                    \item The \textbf{stable storage manager} acts as a factory for
                                        stable storage channels, i.e., given a string argument, it
                                        initializes a stable storage channel, either from scratch or by
                                        loading the stored contents into the channel.  
                                \end{description}

                                \subsubsection{Development Stages}
                                \label{sec:development-stages-1}

                                The development plan is also straight forward.
                                \begin{description}
                                    \item[Interface] Defining the interface of the stable storage channel
                                        and the stable storage manager. 
                                    \item[RAM Implementation] To allow the development of the other
                                        modules, the first stable storage manager provides only an
                                        implementation which builds the table in the main memory.
                                    \item[Production Implementation] The most important implementation to
                                        be used in a production scenario will most likely be a file
                                        implementation, i.e., the table is stored in an ordinary file.
                                        However, the rest of \SYNEIGHT is completely independent of this
                                        implementation, thus in terms of the development of \SYNEIGHT itself
                                        this implementation is unimportant.
                                \end{description}

                                \subsection{Logical Network Manager}
                                \label{sec:logic-netw-manag}

                                A logical network manager enables a certain networking technology, for
                                example, a specific manager will allow to create channels which are
                                solely based on TCP, another one might be based directly on Ethernet,
                                or another could use more than one physical network in parallel to
                                provide a higher bandwidth and fault-tolerance.

                                The logical network manager is also to create \textbf{logical network
                                channels}, such as stable storage managers are used to create stable
                                storage channels. A logical network channel is used host one or more
                                peer group\footnote{See subsection \vref{sec:processes}.}.
                                %
                                Such a channel is providing all the methods which are necessary to
                                communicate with other \SYNEIGHT-enabled processes. At the low level, this
                                means to be able to send uni-, multi-, and broadcasts to the processes
                                which share the same channel.\\
                                %
                                The higher level functionality of the logical network channel is not
                                yet determined. It is preferable to keep the channels as independent
                                as possible from the protocols which are executed atop of
                                them. However, some protocols will executable in a more efficient way,
                                if the channel is more involved. For example, it is conceivable to
                                implement a 2-phase commit protocol directly in the channel
                                implementations.\\
                                %
                                At this point is clear, that the channels must provide an interface
                                for prioritization since transactions are executed at different
                                priorities.  

                                An important feature of the \textbf{logical network manager} is its
                                \textbf{activity}. The manager includes a thread pool which is waiting
                                for requests from remote processes to execute them locally. It will
                                use the transaction monitor and a special set of requests to do
                                so. More precisely, the manager will receive marshaled requests and
                                activate them on the local site. Therefore, the transaction monitor is
                                not required to provide any special interface, instead only a
                                dedicated set of requests has to be assembled. 


                                \subsubsection{Development Stages}

                                \begin{description}
                                    \item[Loop Back Manager] The first logical network manager to be
                                        implemented will only allow one process to participate, the local
                                        one. This manager will be used for the private peer
                                        group\footnote{See subsection. \vref{sec:processes}.}
                                    \item[TCP Based Manager] The next network manager will be built atop
                                        of TCP and will require each process which joins a channel to
                                        connect to all other processes on the same channel. This
                                        implementation will serve as an easy implementation which is useful
                                        for testing purposes and it can be used, if no dedicated LAN is
                                        available to an \SYNEIGHT-cluster. 
                                    \item[Ethernet Based Manager] This network manager will be able to
                                        employ a set of Ethernets in a fault-tolerant and balanced way. It
                                        is planned to use Ethernet in raw-mode in a time-controlled way,
                                        i.e., each process gets a time-slot to be used exclusively by this
                                        process. Thus, the process knows that no collision will occur. 
                                \end{description}


                                \subsection{Module Manager}
                                \label{sec:module-manager}

                                The module manager is a relative simple component -- it loads and
                                unloads modules and manages their dependencies. It also executes
                                safety checks before each operation, for example it only unloads
                                modules which are not in use anymore, and it only loads modules whose
                                dependencies are matched. There is only one development stage --
                                complete. 


                                \subsection{Domain Independent Services}
                                \label{sec:high-level-services}

                                The high level services are built atop of the entity access facade and
                                the meta data access facade. They utilize these two modules to
                                implement the following two features.



                                \subsubsection{Task Scheduler}

                                This task is responsible for maintaining the tasks of the application
                                and of the middleware itself. Therefore, it is the most important task
                                in the system -- and for this reason it is the only which is known by
                                the distribution layer of \SYNEIGHT such that it can be respawned if it
                                fails.

                                Each application which is built atop of \SYNEIGHT can submit so-called
                                \textbf{tasks} to \SYNEIGHT, more specifically, to the task scheduler. A
                                task is described in terms of an entity which uses an entity type
                                implementation that has to implement a specific application interface,
                                namely, the task interface. The task interface allows the task
                                scheduler to access the following features:
                                \begin{description}
                                    \item[Execution Control:] Starting, stopping, suspending, and resuming
                                        a task. All data which is required by the task must be initially
                                        stored in the corresponding entity. The distribution configuration
                                        of this entity is also controlled whether the task data is
                                        replicated over several systems. Clearly, the task is
                                        self-responsible for keeping the information in the entity
                                        up-to-date such that it can be resumed again based on this
                                        information. If the task is requested to suspend, it has to store
                                        all necessary information in the entity, such that it can be resumed
                                        solely based on this information. 
                                    \item[Migration:] When a task is suspended, all critical information
                                        is stored in the entity which represents the task. Therefore it can
                                        be migrated from one machine to another at ease since the entity
                                        type implementation provides all necessary features and is already
                                        embedded into a distribution layer. However, the task is still
                                        informed, if it is moved from one location to another, since it
                                        might have used some node-specific resources such that it requires
                                        to reinitialize itself. 
                                    \item[Statistics:] The task must be able to report to the task
                                        scheduler how much resources it required. It must also be able to
                                        account which entities it has been accessing\footnote{The mechanism
                                        for the latter is based on so-called entity-access-accounts. Each
                                        entity can be a member of an entity-access-account. Whenever a
                                        task is accessing such an entity, the amount of bytes which were
                                        involved in this access are added to the entity-access-account.
                                        This accounting is guaranteed to be exact, however, exactness is
                                        unnecessary for this purpose. This feature requires support of the
                                        transaction monitor.}. This data will be used by the task
                                        scheduler to build a graph of all tasks which reflects the
                                        communication bandwidth between the tasks and their internal
                                        resource consumption (such as CPU time and main memory consumption).
                                        Based on this graph, the task scheduler will reassign the tasks to
                                        the cluster nodes.
                                \end{description}
                                %
                                The design of the task scheduler is not done at this point -- however
                                it is clear which features of the distribution middleware it will
                                require and which features every task will have to implement.

                                \subsubsection{Snapshot Generator}

                                The snapshot generator generates partial or complete snapshots of the
                                database in configurable intervals. Each time a snapshot of a revision
                                is generated, this service locks and deactivates the revision, renames
                                it, and creates a new revision using the old name atop of the now
                                passive one.
                                %
                                Then the snapshot generator collects those parts of the revision
                                which have to be saved in the backup.\\
                                %
                                The locking, deactivating and renaming of revisions is directly
                                provided by the meta access facade. The collection of those entities
                                which have to be stored can be implemented in a flexible way -- the
                                revision management offers the possibility to enumerate the entire
                                revision (or only those parts which match a given predicate). The
                                snapshot generation uses this feature to obtain the set of entities to
                                be stored in the snapshot. The storage itself is implemented in terms
                                of the common persistence subsystem.


                                \subsubsection{Development Stages}
                                \label{sec:development-stages-5}

                                The development of the domain-independent services is not planned at
                                this point. However, they can be implemented independently as soon as
                                the entity access facade and the meta access facade are frozen.\\
                                %
                                Thus they will be implemented during the development of the single
                                server version to complete the single server implementation. Since
                                they are mainly utilizing the features of the distribution layer, they
                                will be relatively small components. 


                                \section{Implementations of \SYNEIGHT}
                                \label{sec:implementations-syneight}

                                In this section, we briefly present four useful implementation stages
                                of \SYNEIGHT. 
                                %
                                Because of the modular structure of \SYNEIGHT, many components of \SYNEIGHT
                                can be developed in parallel and consequently, there are many
                                different configurations of \SYNEIGHT. Indeed, \SYNEIGHT is designed to be
                                a framework which allows the development team to enhance \SYNEIGHT
                                continuously without jeopardizing the applications which are running
                                atop of it. 
                                %

                                \subsection{Single Server Prototype}
                                \label{sec:single-serv-prot}

                                The single server prototype is kept as small as possible, to be
                                developed as quickly as possible. This stage has the purposes to
                                establish a running proof of concept and to serve as a basis to
                                evaluate the main characteristics of the future middleware. In
                                particular, this stage has the following aims:
                                \begin{description}
                                    \item It allows to \textbf{evaluate the interfaces} of \SYNEIGHT. It is
                                        important to gain experience in using these interfaces to improve
                                        them before freezing them. Most importantly, the entity type
                                        implementation interface has to be determined for this
                                        prototype. 
                                    \item This version will allow the development team to issue
                                        \textbf{performance evaluations}. Once the detailed design is
                                        frozen, performance improvements will become very tedious. Thus,
                                        this stage should be used by the development team to evaluate
                                        different implementation strategies, especially of the
                                        \textbf{transaction monitor}. Also, the efficient use of
                                        \textbf{multi-threading} should be evaluated in this stage.
                                    \item Finally, once this version is stable, it will allow the team to
                                        develop all further components in the context of a running system,
                                        i.e., every developed component can be \textbf{immediately
                                        integrated} into an established framework.
                                \end{description}


                                \begin{center}\begin{footnotesize}\begin{tabular}{||l|l||} \hhline{|t:==:t|}
                                    \textbf{Component}          & \textbf{Milestones}                            %% & \textbf{Comment} 
                                    \\ \hhline{|:==:|} 
                                    Entity Type Implementation  & completion                                     %% & 
                                    \\ \hhline{||--||}
                                    Entity Access Facade        & protected access                                    %% & 
                                    \\ \hhline{||--||}
                                    Meta Access Facade          & dummy metadata                                %% & 
                                    \\ \hhline{||--||}
                                    Transaction Monitor         & single server coordination/protected access         %% & 
                                    \\ \hhline{||--||}
                                    Metadata Monitor            & dummy metadata                                %% & 
                                    \\ \hhline{||--||}
                                    Stable Storage Manager      & RAM implementation                             %% & 
                                    \\ \hhline{||--||}
                                    Logical Network Manager     & loop back manager                              %% & 
                                    \\ \hhline{||--||}
                                    Module Manager              & completion                                     %% & 
                                    \\ \hhline{||--||}
                                    Domain Independent Services & -- %% & 
                                    \\ \hhline{|b:==:b|}
                                \end{tabular}\end{footnotesize}\end{center}
                                %
                                This prototype must be used to do a first evaluation of the expected
                                performance of the distributed middleware. This evaluation does not
                                have to provide a generally useful system, but it must allow to
                                estimate the impact of distribution on the overall system.

                                %% 
                                %% \begin{description}
                                %% \item[Entity Type Implementation:] complete. 
                                %% \item[Entity Access Facade:] completion.
                                %% \item[Meta Access Facade:] single server.
                                %% \item[Transaction Monitor:] single server.  
                                %% \item[Metadata Monitor:] single server.
                                %% \item[Stable Storage Manager:] 
                                %% \item[Logical Network Manager:]
                                %% \item[Module Manager:] 
                                %% \item[Domain Independent Services:] 
                                %% \end{description}
                                %% 

                                \subsection{Single Server Production}
                                \label{sec:single-serv-prod}

                                The single server production version has two goals:
                                \begin{description}
                                    \item To provide the \textbf{complete} and \textbf{final interfaces}
                                        of \SYNEIGHT. In consequence, all application can be developed
                                        independently from the middleware development, which will speed up
                                        the overall development and which will allow to collect real-use
                                        experience with the middleware.
                                    \item To be used as a \textbf{first release}. Certainly, this version
                                        is projected to be a very efficient multi-threaded transaction
                                        monitor, with all features which are critical to a \MMORG. It can be
                                        assumed that this server will be able to handle at least 500 players
                                        (assuming current typical load characteristics of \MMORGS) which is
                                        enough to go into a limited production phase.
                                        %
                                        \end{description}

                                        \begin{center}\begin{footnotesize}\begin{tabular}{||l|l||} \hhline{|t:==:t|}
                                            \textbf{Component}          & \textbf{Milestones}                            %% & \textbf{Comment} 
                                            \\ \hhline{|:==:|} 
                                            Entity Type Implementation  & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Entity Access Facade        & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Meta Access Facade          & metadata persistence                           %% & 
                                            \\ \hhline{||--||}
                                            Transaction Monitor         & single server                                  %% & 
                                            \\ \hhline{||--||}
                                            Metadata Monitor            & single server                                  %% & 
                                            \\ \hhline{||--||}
                                            Stable Storage Manager      & production implementation              %% & 
                                            \\ \hhline{||--||}
                                            Logical Network Manager     & loop back manager                              %% & 
                                            \\ \hhline{||--||}
                                            Module Manager              & completion                                       %% & 
                                            \\ \hhline{||--||}
                                            Domain Independent Services & task scheduler and snapshot generator  %% & 
                                            \\ \hhline{|b:==:b|}
                                        \end{tabular}\end{footnotesize}\end{center}
                                        %
                                        Depending on the situation, several variants of this configuration are
                                        conceivable.
                                        %
                                        For the completion of the interfaces, the production implementation of
                                        the stable storage manager and the complete implementation of the
                                        domain independent services has lower priority. On the other hand, if
                                        this version is used in a production context, these features are
                                        important. In a detailed development plan, this might be reflected in
                                        the following way: First the interfaces are frozen, and the majority
                                        of the development team moves on to the distributed server prototype
                                        while a smaller part of the team finalizes this stage.


                                        %% 
                                        %% The single server implementation requires the following milestones:
                                        %% 
                                        %% \begin{description}
                                        %% \item[Entity Type Implementation:] complete. 
                                        %% \item[Entity Access Facade:] completion.
                                        %% \item[Meta Access Facade:] metadata persistence.
                                        %% \item[Transaction Monitor:] single server.  
                                        %% \item[Metadata Monitor:] single server.
                                        %% \item[Stable Storage Manager:] production implementation.
                                        %% \item[Logical Network Manager:] loop back manager.
                                        %% \item[Module Manager:] complete.
                                        %% \item[Domain Independent Services:] task scheduler and snapshot
                                        %%   generator complete.
                                        %% \end{description}
                                        %% 

                                        \subsection{Distributed Server Prototype}
                                        \label{sec:distr-serv-prot}

                                        The distributed server prototype is built atop of the single server
                                        production version. All interfaces have been frozen for the single
                                        server production stage, thus all applications can be migrated
                                        smoothly.\\ 
                                        %
                                        The complexity of the distribution management of  of \SYNEIGHT is
                                        encapsulated into the following three components: 
                                        %
                                        \begin{itemize}
                                            \item transaction monitor
                                            \item metadata monitor
                                            \item logical network manager
                                        \end{itemize}
                                        %
                                        Thus these three components are expanded in this stage to allow the
                                        evaluation and detailed design of the distribution subsystems. The
                                        distribution management of this version will be manual, i.e., the
                                        application itself will be responsible for determining the
                                        distribution of the entities. Thus, this version is only partly useful
                                        for real-world applications. Especially, no fault-tolerance aspects
                                        are implemented in this version. 

                                        \begin{center}\begin{footnotesize}\begin{tabular}{||l|l||} \hhline{|t:==:t|}
                                            \textbf{Component}          & \textbf{Milestones}                            %% & \textbf{Comment} 
                                            \\ \hhline{|:==:|} 
                                            Entity Type Implementation  & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Entity Access Facade        & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Meta Access Facade          & completion                           %% & 
                                            \\ \hhline{||--||}
                                            Transaction Monitor         & distributed server/distributed transaction requests                             %% & 
                                            \\ \hhline{||--||}
                                            Metadata Monitor            & distributed server/manual distribution                                  %% & 
                                            \\ \hhline{||--||}
                                            Stable Storage Manager      & production implementation              %% & 
                                            \\ \hhline{||--||}
                                            Logical Network Manager     & TCP implementation          %% & 
                                            \\ \hhline{||--||}
                                            Module Manager              & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Domain Independent Services & task scheduler and snapshot generator  %% & 
                                            \\ \hhline{|b:==:b|}
                                        \end{tabular}\end{footnotesize}\end{center}



                                        \subsection{Distributed Server Production}
                                        \label{sec:distr-serv-prod}

                                        This is the final version of \SYNEIGHT. All main components are finished
                                        and production level modules for the stable storage manager and the
                                        logical network manager are provided. Also fault-tolerant behavior is
                                        implemented in the transaction monitor. However, the concrete but
                                        exchangeable version of the logical network layer has a strong
                                        influence on the scope of this version: 
                                        \begin{description}
                                            \item The \textbf{scalability} of this version is determined by the
                                                logical network layer. For high scalability, it will be necessary to
                                                provide an Ethernet implementation or at least a UDP-multicast
                                                implementation. It might be sufficient to use a TCP-implementation
                                                at the beginning, and since this implementation can be exchanged
                                                later, a more elaborate implementation might be developed in the
                                                meantime. 
                                            \item The \textbf{fault-tolerance} of the middleware \textbf{with
                                                respect to network failures} is also a responsibility of the logic
                                                network layer. Again, for a first public beta, a non fault-tolerant
                                                version might be employed and exchanged in the subsequent stages.
                                        \end{description}

                                        \begin{center}\begin{footnotesize}\begin{tabular}{||l|l||} \hhline{|t:==:t|}
                                            \textbf{Component}          & \textbf{Milestones}                            %% & \textbf{Comment} 
                                            \\ \hhline{|:==:|} 
                                            Entity Type Implementation  & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Entity Access Facade        & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Meta Access Facade          & completion                           %% & 
                                            \\ \hhline{||--||}
                                            Transaction Monitor         & completion                                  %% & 
                                            \\ \hhline{||--||}
                                            Metadata Monitor            & completion                                  %% & 
                                            \\ \hhline{||--||}
                                            Stable Storage Manager      & production implementation              %% & 
                                            \\ \hhline{||--||}
                                            Logical Network Manager     & TCP \textbf{or} Ethernet implementation          %% & 
                                            \\ \hhline{||--||}
                                            Module Manager              & completion                                     %% & 
                                            \\ \hhline{||--||}
                                            Domain Independent Services & task scheduler and snapshot generator  %% & 
                                            \\ \hhline{|b:==:b|}
                                        \end{tabular}\end{footnotesize}\end{center}




                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                                        \chapter{Estimated Effort \& Conclusion}

                                        The \SYNEIGHT-project is placed between industry and academia -- some
                                        components of \SYNEIGHT are plain engineering tasks, which are based on
                                        known technology and which are certainly feasible, while other
                                        components of \SYNEIGHT are new or used in a new context, i.e., they are
                                        much more research-oriented. There are four main-variables which
                                        determine the feasibility of \SYNEIGHT in the context of \MMORGS and
                                        related applications:
                                        \begin{description}
                                            \item The \textbf{people} who are required to develop \SYNEIGHT. The
                                                development team of \SYNEIGHT requires software engineers and computer
                                                scientists with solid knowledge on various fields, or at least with
                                                the ability to enter a field quickly. The involved areas include
                                                extensive programming and algorithmic skills, system development
                                                (networking, multi-threaded server development, or even kernel
                                                development), as well as transaction processing theory or formal
                                                verification.
                                            \item The \textbf{time} which is required to develop \SYNEIGHT. Especially
                                                during the initial phase, only a small amount of work can be
                                                parallelized since the conceptual integrity of the design requires a
                                                small and tightly cooperating team. This team will have to define
                                                all major interfaces. Once these interfaces are well-defined, more
                                                people can be integrated into the team, and consequently, it becomes
                                                partly possible to trade people for time -- \SYNEIGHT is designed to be
                                                modular, i.e., once these module interfaces are frozen, these
                                                modules can be assigned to new developers easily. However, the team
                                                which develops the core components of \SYNEIGHT will be hard to expand
                                                because of the massive communication overhead.
                                            \item The resulting \textbf{performance} of the envisioned system. A
                                                central reason for building \SYNEIGHT was performance, thus its
                                                key-features are projected to provide a high overall performance. 
                                                %
                                                However, as long as there is no implementation which mimics the
                                                behavior of the final middleware, it is impossible to predict the
                                                real performance characteristics of \SYNEIGHT.
                                            \item The \textbf{usability} of the middleware. \SYNEIGHT follows a
                                                modular framework approach, which allows to plug-in various
                                                sub-subsystems and which is designed to be accessible through
                                                different interfaces. From the point of view of the future users of
                                                \SYNEIGHT, the most critical interface to \SYNEIGHT is the compiler which
                                                translates common class definitions into entity type
                                                implementations\footnote{See subsection
                                                \vref{sec:entity-type-impl}.}. It is definitely infeasible to use
                                                \SYNEIGHT without a compiler for large-scale projects -- thus a compiler
                                                is a must. On the other hand, the design of \SYNEIGHT allows to use
                                                different compilers and to support different languages. Therefore,
                                                it is possible to supply a simple compiler -- for example, such a
                                                compiler could translate simplified class definitions into stubs
                                                which must be augmented by the developers themselves. 
                                        \end{description}



                                        \section{Three Phases}

                                        To account the different aspects of the \SYNEIGHT-project and manage the
                                        development risk, we propose to split the development of \SYNEIGHT into
                                        three distinct phases. Also, these three phases will require different
                                        development styles and development environments. Because of the
                                        originality of \SYNEIGHT, it is hard to estimate the development
                                        time. To ensure that a usable and commercially valuable system is
                                        produced as soon as possible, it is a natural choice to focus on the
                                        single version at the beginning of the project. Also, the distributed
                                        transaction processing is the most complex single feature, i.e., the
                                        transition from the single server system to the distributed server
                                        system will be the step which will require most development resources
                                        before paying off. The distributed system will not only require
                                        distributed transaction processing, but will also rise the most
                                        advanced features of \SYNEIGHT, such as fault-tolerance and
                                        load-balancing. 


                                        \subsection{Phase I -- Research}

                                        In the first phase, the \textbf{single server system} will be designed
                                        and implemented. We will focus on the single server system because it
                                        is a feasible project for a small but dedicated team. In this phase we
                                        will first built the single server prototype, as described in
                                        \vref{sec:single-serv-prot}. Having this stage will allow to give a
                                        firm estimation of the development efforts, at least for the single
                                        server production system. 

                                        Once the single server prototype is developed, the team will follow
                                        two lines of research: 
                                        \begin{itemize}
                                            \item It will design the production level-single server and start
                                                implementing it. 
                                            \item At the same time, the future performance of the distributed
                                                server system will be evaluated. 
                                        \end{itemize}

                                        As outlined in section \vref{sec:implementations-syneight}, the completion
                                        of the production level single server system will provide the detailed
                                        architecture and design of \SYNEIGHT, stable interfaces, and an
                                        implementation of many components of the final system. However, this
                                        first project phase does not include the complete production level
                                        system, it only finishes the interfaces and implements the system
                                        functionally, i.e., it leaves aside non-functional requirements as
                                        long as they are not an architectural concern.

                                        The team required for this project phase of \SYNEIGHT is required to be
                                        small and closely cooperating to achieve a coherent design.  Because
                                        of the research orientation and because of the high qualification
                                        profiles which are required in this phase, the corresponding team is
                                        best situated in an \textbf{academic setting} where it can work
                                        independently from immediate economic pressures.

                                        Three to four dedicated engineers and scientists can be expected to
                                        carry out this phase within a year. However, the qualification profile
                                        of these people is demanding and most importantly, they  must be
                                        dedicated to the project. The involved researchers are required to
                                        combine theoretical knowledge and ability, architectural vision and
                                        solid implementation skills. Therefore, besides providing these people
                                        with a stimulating and stable environment, the biggest problem is
                                        finding and hiring them. The project is infeasible with a smaller team
                                        for several reasons:
                                        \begin{itemize}
                                            \item The required skills and backgrounds are too diverse to be
                                                covered by a smaller team.
                                            \item The architecture will have to meet a broad set of requirements
                                                and therefore different development experiences are necessary to be
                                                able to estimate the consequences of architectural decisions. 
                                            \item The development will involve a lot more people in the later
                                                phases, thus it is necessary to build up a large enough core team to
                                                lead the later project group.
                                        \end{itemize}

                                        \subsection{Phase II -- Maturing}

                                        In the second phase, the single server system is used to develop a
                                        \textbf{first real-world application} based on the \SYNEIGHT-middleware.
                                        The development of a real-world application will help to mature the
                                        interfaces and to enhance the implementation in terms of
                                        non-functional requirements. Thus the outcome of this phase will be
                                        \begin{itemize}
                                            \item a production level single server system,
                                            \item a running application atop of \SYNEIGHT which can be used as a
                                                future test-application for further development,
                                            \item the potential to generate monetary revenue.
                                        \end{itemize}

                                        While the first phase was mainly driven by the design of \SYNEIGHT, the
                                        second phase is driven by the implementation of a concrete application
                                        atop of \SYNEIGHT. Thus, the usability of the middleware will become
                                        central, and consequently an appropriate compiler will be developed.

                                        This phase will require a larger team, and will also provide the
                                        opportunity to integrate new developers easily into the team. Most
                                        notable, the compiler can be developed almost independently from the
                                        \SYNEIGHT-core. The modular design of \SYNEIGHT and the already existing
                                        framework will allow new developers to improve or replace modules such
                                        as the stable storage manager to gain better performance
                                        characteristics.

                                        In this phase, the emphasis is much more \textbf{industry-oriented} --
                                        \SYNEIGHT will mature in this phase and become a product. The academic
                                        core team will serve its first client, a game developer team. At the
                                        same time, routine tasks will become more prominent, and the volume of
                                        tasks to be executed will increase quickly. Therefore, a more
                                        organized industrial setting will be required. 

                                        In the second phase, the team will have to grow to a size of at least
                                        five members. Most notable, there has to be a dedicated compiler
                                        developer. The functionality of the system will not be changed in this
                                        phase, therefore, it is a good time introduce people to the
                                        project. In general, the qualification of the new team members
                                        should match the already involved people.


                                        \subsection{Phase III -- Expansion}

                                        In the third phase, \SYNEIGHT will be brought into the distributed server
                                        production stage. Based on the already stabilized interfaces, this
                                        phase will be independent from the application development. 

                                        Again, extensive research is required and complex design issues have
                                        to be settled to come up with the detailed design and an
                                        implementation of the components which are necessary for running \SYNEIGHT
                                        in a distributed fashion, i.e., the beginning of this phase shifts the
                                        emphasis back to academia.
                                        %
                                        However, this phase is different from the first one in three ways:
                                        \begin{itemize}
                                            \item The development effort will be larger than in the first phase. 
                                            \item Second, the already established framework will allow to
                                                subdivide the work easier -- the changes to migrate \SYNEIGHT from a
                                                single server solution to a distributed server solution are
                                                encapsulated into the transaction monitor, the metadata monitor and
                                                the logical network manager.
                                            \item A running application needs to be supported at a standard which
                                                meets industry requirements.
                                        \end{itemize}
                                        Therefore, the development of this phase will be executed by
                                        \textbf{research-oriented teams} and by an \textbf{industry-oriented
                                        team}. The research team will expand the core of \SYNEIGHT, i.e., build
                                        an initial logical network manager and develop the distributed
                                        transaction processing. At the meantime the industry oriented team
                                        will provide support for the game development, i.e., it will build the
                                        domain-specific services. The research-team will focus on developing a
                                        compiler for entity type implementations which is general enough, to
                                        be used to develop the meta-databases. The development and integration
                                        of these databases will mark the end of the first distributed \SYNEIGHT
                                        server system.

                                        By the time, the original research team starts to develop the
                                        meta-databases, it has to have a size of seven to eight people.
                                        %
                                        At the same time, the industry-oriented team will be build up, which
                                        develops the domain-specific middleware services. In contrast to the
                                        research-oriented team, the industrial team has a narrower set of
                                        requirements to be fulfilled and is able to integrate and test their
                                        applications immediately. Therefore, the style of development will
                                        differ from the style of the research-oriented team.

                                        The new industry-oriented team will be served as a customer by the
                                        first team -- to avoid a close inter-winding of the different software
                                        layers, we believe that it is important to separate these teams.

                                        This team will include five to six developers. Their qualification
                                        profiles do not have to match the research-oriented developers,
                                        mainly, these people are required 
                                        \begin{itemize}
                                            \item to have solid implementation skills,
                                            \item to be able to work with a transaction based system,
                                            \item to have experience with client server applications. 
                                        \end{itemize}


                                        \section{Conclusion}

                                        We conclude that the \SYNEIGHT project \textbf{requires both, the academic
                                        and the industry environment}. Academic resources and freedom are
                                        required to build the first core of the \SYNEIGHT-system. But at the same
                                        time, the industrial environment is necessary to transform the initial
                                        core system into a reliable and usable product. Therefore, we
                                        restructured the project into three different phases, according to
                                        their settings. 
                                        %
                                        The first phase must be continued as a research project which is
                                        motivated and based on an industrial requirement set.
                                        %  
                                        However, it has to be driven independently from immediate economic
                                        pressures, while the second phase is necessarily placed in an
                                        industrial context to mature \SYNEIGHT.  In the third phase the work is
                                        perused by both, a research and an industrial team.

                                        In the past year of development, much work of the first phase was
                                        done. However, the team which worked on \SYNEIGHT could not work freely,
                                        and was constantly facing short-term development needs and goals. 
                                        %
                                        The software which has been developed can serve as a basis -- partly
                                        as prototype, and partly it serves directly as a foundation.\\
                                        %
                                        In consequence, we believe that the \SYNEIGHT-project has to be further
                                        developed in close cooperation with an academic environment, i.e., a
                                        team at the Institute for Information Systems at Vienna University of
                                        Technology has to be established.
                                        %
                                        The single server system is definitely a feasible project in such a
                                        context, once an appropriate skilled team could be assembled.
                                        %
                                        This step will allow the team to come up with an initial
                                        implementation which embodies the core architecture without being
                                        forced to compromises.
                                        %
                                        Building upon the already existing work this phase is a fairly small
                                        risk and is expected to be closed within a year.

                                        Once, this step is done, the system must be matured. Many software
                                        development projects, especially projects which stem out of research
                                        efforts, suffer the problem of requiring an initial industrial
                                        customer who is willing to invest the human and time resources to
                                        bring a research system to a product level.
 
                                        The third phase will only be started, once it is proven that the
                                        \SYNEIGHT-project provides the properties which it is projected to
                                        deliver. Also, we want to note that the end of the second phase is a
                                        possible exit-point from the project -- a commercially valuable
                                        product is already developed. The development of the domain specific
                                        services is definitely feasible, while the development of the various
                                        distribution features of \SYNEIGHT is again a more research-driven
                                        effort. We believe that \SYNEIGHT is definitely offering the potential to
                                        satisfy the projected feature set, but at the same time, the
                                        experience of the preceding two phases will certainly lead to
                                        modifications in the set of the distribution features to be integrated
                                        into \SYNEIGHT. From this point of view, it is the modular architecture of
                                        \SYNEIGHT which will ensure the feasibility of the project. 

                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




                                        \bibliographystyle{alpha}
                                        \bibliography{feasibility-study}


                                        \end{document}

                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                                        %\subsection{Online-Maintenance}

                                        %\item \textbf{Multi-Threading.}

                                        %% \item {\bf Ausfallsicherheit.} Das Gesamtsystem soll durch Ausf"alle von
                                        %%   Einzelkomponenten nicht wesentlich in Mitleidenschaft gezogen
                                        %%   werden. 
                                        %% \item {\bf Skalierbarkeit.} Hardware-Erweiterungen sollen einen, im
                                        %%   Wesentlichen, linearen Performance Zugewinn erzielen. Das Serversystem
                                        %%   sollte zumindest 10.000 gleichzeitig verbundene Clients bedienen k"onnen. 
                                        %% \item {\bf Parallelisierbarkeit.} Aufgrund der recht aufwendigen Berechnungen,
                                        %%   die sich pro Objekt im Spiel ergeben, ist ein nicht hochgradig
                                        %%   parallelisierter Ansatz zu Gunsten einer Cluster-L"osung auszuschlie"sen.
                                        %% \item {\bf Realtime.} Eines der wichtigsten Ziele f"ur ein Spiel wie
                                        %%   Iritor Online ist eine fl"ussige Spielbarkeit. Daraus resultieren
                                        %%   Echtzeit-Anforderungen an das Serversystem. Dabei ist zu beachten, da"s in
                                        %%   einer Spiele-Umgebung eine gewisse Unsch"arfe in der vorhandenen Information
                                        %%   durchaus tolerierbar ist. Da das Verhalten des Gesamtsystems nicht
                                        %%   vorhersagbar ist, erm"oglicht erst eine kontrollierte zeitliche Unsch"arfe in der
                                        %%   verarbeiteten Information die Realisierung eines Echtzeitspiels. 
                                        %% \item {\bf Load Balancing.} Die Last der Einzelserver im Cluster sollte
                                        %%   in einem jeweils gleichm"a"sigen Verh"altnis zueinander stehen. Dies betrifft zum einen die Clientanfragen, und
                                        %%   mehr noch die Ausf"uhrung der Spiellogik, die parallel verteilt auf den
                                        %%   Clusterknoten ausgef"uhrt werden wird. Das Load-Balancing darf mit den
                                        %%   Realtime-Anforderungen nicht in Konflikt geraten, daher mu"s eine
                                        %%   Umschichtung nach au"sen hin ohne weitere Performance Einbu"sen
                                        %%   bewerkstelligt werden.
                                        %% \item {\bf Transparentes Netzwerk.} Die konkreten Netzwerkoperationen
                                        %%   sollten durch eine Abstraktionsschicht gekapselt werden. Diese Schicht sollte
                                        %%   sich an die konkreten Charakteristika einer Verbindung anpassen. Diese
                                        %%   Schicht mu"s verschiedene Netzwerktopologien (gerade im Cluster) ausn"utzen
                                        %%   und in der Lage sein, unter Vernachl"assigung der Zuverl"assigkeit,
                                        %%   einen h"oheren Durchsatz zu erzielen.\newline
                                        %%   Ebenso sollte eine Anpassung an zuk"unftige Entwicklungen (IPv6) in der
                                        %%   Netzwerktechnologie in transparenter Weise erm"oglicht werden.
                                        %% \item {\bf Veraltete Information.} Das System mu"s sinnvoll mit leicht
                                        %%   veralteter und unscharfer Information umgehen k"onnen, das hei"st,
                                        %%   da"s die Daten zwar veraltet sein m"ogen, gleichzeitig aber
                                        %%   zueinander konsistent gehalten werden m"ussen. Da es immer zu einem
                                        %%   Trade-Off zwischen Aktualit"at, Konsistenz und Effizienz kommt,
                                        %%   sollte dieser Trade-Off zumindest m"oglichst frei w"ahlbar sein.
                                        %% \item {\bf Flexibles Transaktionssystem.} Aus dem vorigen Punkt ergibt sich
                                        %%   die Notwendigkeit, einen konsistenten, effizienten, wenn auch nicht
                                        %%   erzwungener Ma"sen aktuellen Transaktionsbegriff in orthogonaler Weise zur
                                        %%   klassischen Transaktionssemantik anzubieten.
                                        %% \item {\bf Concurrency Locks.} Da in unserer Anwendung bestimmte Objekte eine
                                        %%   besonders zentrale Stellung einnehmen werden, und oftmals im Zuge von
                                        %%   parallel stattfindenden Transaktionen ausgelesen bzw.~beschrieben werden, mu"s eine M"oglichkeit geschaffen werden,
                                        %%   m"oglichst viele Locks parallel zu erlauben. Insbesondere sollte w"ahrend
                                        %%   eines Write-Locks die M"oglichkeit eines lesenden Zugriffs auf die letzte
                                        %%   konsistente Version des Objekts bestehen.
                                        %% \item {\bf Systemwartung.} Die Systemwartung mu"s im laufenden Betrieb
                                        %%   erfolgen. Insbesondere m"ussen Ver"anderungen in der Spiellogik zur Laufzeit
                                        %%   m"oglich sein, ohne einen Ausfall des Serversystems nach sich zu ziehen.
                                        %%   Dies ist unabdingbar, da eine Instanz eines Spiels wie Iritor Online
                                        %%   "uber Jahre hinweg in Produktion steht, und in dieser Zeit kontinuierlich
                                        %%   erweitert wird.
                                        %% \item {\bf Entwicklung einer Game-Engine.} "Ahnlich einer Grafik-Engine, die
                                        %%   unabh"angig von einem konkreten Spiel entwickelt und verkauft werden kann,
                                        %%   sollte auch das Server-System als eine abstrakte Engine entwickelt
                                        %%   werden. Die Server- und Grafik-Engine bilden zusammen die abstrakte
                                        %%   Plattform, auf der ein weitestgehend beliebiges \MMOG entwickelt werden
                                        %%   kann. 
                                        %% \item {\bf Entwicklung des Content-Codes in einer High-Level-Language.} Die
                                        %%   Spiellogik selbst, unter Vernachl"assigung der grafischen Effekte, sollte
                                        %%   in einer eigenen, angepa"sten und entsprechend komfortablen
                                        %%   Programmiersprache implementiert werden k"onnen. Iritor Online selbst wird in
                                        %%   dieser Programmiersprache entwickelt werden. 
                                        %% \item {\bf Objektorientiere Modellierung.} Die objektorientierte
                                        %%   Programmierung setzte sich in den letzten Jahren immer mehr durch und
                                        %%   wird heute als Standard betrachtet. Gerade ein Spiel l"a"st sich in
                                        %%   hervorragender Weise in ein objektorientiertes Modell "ubertragen. Daher
                                        %%   betrachten wir diesen Punkt nicht als Design-Entscheidung, sondern als
                                        %%   Anforderung an das System, mit dem die Spielwelt umgesetzt werden wird. 
                                        %% \item {\bf Hoher Integrationsgrad.} Die vorgestellten Anforderungen m"ussen
                                        %%   von einem gut integrierten Softwaresystem abgedeckt werden. Dies bedeutet,
                                        %%   da"s Produkte, die eine Teilmenge der vorherigen Anforderungen erf"ullen,
                                        %%   kaum benutzt bzw.~erweitert werden k"onnen. 





                                        %%\item[Logging Server:] To develop and administrate a server system of
                                        %%  this complexity, a massive logging mechanism is required. A services
                                        %%  of the should send their log messages to a central logging
                                        %%  facility. If this logging server fails, an alternative logging
                                        %%  server should be chosen and used from that moment on. 



                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

                                        %
                                        % Forget the game -- what is the middlewaring challenge?
                                        %
                                        Beneath every \MMORG are comprehensive server solution has to provide
                                        the following key features:
                                        \begin{itemize}
                                            \item \textbf{Persistence.} A main feature of each \MMORG is the
                                                persistence of the represented world and its characters. 
                                            \item \textbf{Scalability.} 
                                            \item \textbf{Availability.} One of the most disturbing features of
                                                today's \MMORGS is their regular down-time and data-loss. Nothing is
                                                more discouraging to subscribers than losing the latest overly-cool
                                                item which was conquered during a quest which took three days. 
                                                %
                                                Even if there is no data-loss, it is disturbing for subscribers to
                                                wait in front of their PCs for the servers to come up again. All
                                                currently available \MMORGS are down several times per month, and in
                                                extreme cases almost every day. 
                                                %
                                                Therefore, a certain degree of availability is a requirement for any
                                                \MMORG to be economically successful. Moreover, high availability
                                                would be a distinguishing feature for any new \MMORG which would
                                                make it a lot more attractive to potential new subscribers.
                                            \item \textbf{Soft-Realtime.} To achieve a strong immersion, a bound
                                                reaction time of the server system is necessary. On the other hand,
                                                seldomly occurring longer latencies of even disruptions of the game
                                                play are agreeable. Therefore, a middleware for \MMORGS must achieve
                                                soft-realtime qualities, i.e., it must be possible to predict the
                                                temporal behavior of the system during normal work-loads. 
                                        \end{itemize}



                                        These simulations are highly parallel by nature and therefore
                                        conceptually they are can be easily distributed over a large number
                                        of nodes.

                                        is an object-oriented transaction monitor which employs
                                        weak-isolation levels to reach soft-realtime qualities.


                                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                        %% 
                                        %% %
                                        %% The following different levels of change can be differentiated:
                                        %% \begin{description}
                                        %% \item[Changing Objects:] Besides addition, it will be necessary to
                                        %%   update existing objects in a consistent and global manner. While
                                        %%   updating a single object can be done in terms of an ordinary
                                        %%   transaction, there are updates required which involve all entities
                                        %%   of a certain type. For example, it might be necessary to multiply
                                        %%   the the strength of all spiders in the game with a certain factor.
                                        %%   %
                                        %%   If such updates are to be done online, dedicated mechanisms are
                                        %%   necessary which avoid the locking all entities of this type.
                                        %%   %
                                        %%   Basically, we can distinguish three different modes of such a change
                                        %%   operation. 
                                        %% \item[Changing Types:] A stronger level of change management is the
                                        %%   replacement of one entity type implementation with another one.
                                        %%   Switching from one implementation to another one involves in general
                                        %%   the conversion of the entities' state since the two
                                        %%   implementations might not use the same state representation.\\
                                        %%   %
                                        %%   Again, the three different synchronization 
                                        %% \item[Schema Evolution:] There can be situations where it
                                        %%   is not enough to exchange one entity type implementation with
                                        %%   another one since the exchange of one type might require further
                                        %%   changes. This leads to schema evolution, where a pattern which
                                        %%   describes related entities has to be converted into a new
                                        %%   structure.\\
                                        %%   %
                                        %%   The complexity of such a mechanism depends on the supported patterns
                                        %%   which can be evolved into new structures and on the synchronization
                                        %%   semantics, which determines the application's view on the evolution,
                                        %%   i.e., whether intermediate stages are visible to the application,
                                        %%   and if so, which intermediate stages are visible to the application.
                                        %% \end{description}
                                        %% 
                                        %% 
                                        %% 
                                        %% To expand the word by adding new
                                        %% zones, the corresponding server-side representation has to be
                                        %% instantiated. 
                                        %% 
                                        %% existing database is
                                        %% relatively easy
                                        %% 
                                        %% Expansion, more precisely, the adding
                                        %% of new zones, will be the dominating 
                                        %% 
                                        %% In the case of expanding the world,
                                        %% the situation is slightly easier. 
                                        %% data structures for the new area, 
                                        %% 

                                        %%% Local Variables: 
                                        %%% mode: latex
                                        %%% TeX-master: t
                                        %%% End: 
% vim:ts=4:sw=4
